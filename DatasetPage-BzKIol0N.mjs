var yx = Object.defineProperty;
var xx = (I, k, B) => k in I ? yx(I, k, { enumerable: !0, configurable: !0, writable: !0, value: B }) : I[k] = B;
var mh = (I, k, B) => xx(I, typeof k != "symbol" ? k + "" : k, B);
import vx from "./DatasetPageQuery.graphql-BpQujekp.mjs";
import { c as vh, j as xt, g as fu, R as di, d as oc, a as bh, f as bx, u as En, b as fl, L as _h, C as ep, i as wx, e as Tx, v as wh, h as tp, k as ip, l as l_, m as c_, n as rp, o as du, p as ml, s as u_, q as Ex, t as Sx, w as Mx, x as Cx, y as Th, z as Ax, A as $m, B as Ix, D as dl, P as Px, E as h_, F as gh, H as d_, O as p_, G as f_, I as Lx, J as m_, K as __, M as g_, N as y_, Q as zx, T as x_, U as v_, V as b_, W as Eh, X as w_, Y as kx, Z as Dx, _ as Rx, $ as Ox, a0 as Bx, a1 as Fx, a2 as Zm, a3 as Ux, a4 as Nx, a5 as jx, r as Vx, a6 as Gx, a7 as $x, a8 as Zx, a9 as qx, S as Wx } from "./index-DhESz6lu.mjs";
import { N as Xx, s as Hx, S as Kx } from "./index.module-FsAl3M7A.mjs";
import * as Sa from "react";
import _r, { useState as pl, useEffect as nr, useMemo as Hs, useRef as Yr, Fragment as Jx, useLayoutEffect as Yx, useContext as lc, useImperativeHandle as Sh, memo as _l, forwardRef as np, cloneElement as Qx, useCallback as Yd } from "react";
import { createPortal as T_ } from "react-dom";
function ev(I, k) {
  for (var B = 0; B < k.length; B++) {
    const V = k[B];
    if (typeof V != "string" && !Array.isArray(V)) {
      for (const J in V)
        if (J !== "default" && !(J in I)) {
          const ee = Object.getOwnPropertyDescriptor(V, J);
          ee && Object.defineProperty(I, J, ee.get ? ee : {
            enumerable: !0,
            get: () => V[J]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(I, Symbol.toStringTag, { value: "Module" }));
}
const E_ = vh(/* @__PURE__ */ xt.jsx("path", {
  d: "M5 15H3v4c0 1.1.9 2 2 2h4v-2H5zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2m0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2zM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4m0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2"
}), "CenterFocusWeak"), tv = vh(/* @__PURE__ */ xt.jsx("path", {
  d: "M17 5h-2V3h2zm-2 16h2v-2.59L19.59 21 21 19.59 18.41 17H21v-2h-6zm4-12h2V7h-2zm0 4h2v-2h-2zm-8 8h2v-2h-2zM7 5h2V3H7zM3 17h2v-2H3zm2 4v-2H3c0 1.1.9 2 2 2M19 3v2h2c0-1.1-.9-2-2-2m-8 2h2V3h-2zM3 9h2V7H3zm4 12h2v-2H7zm-4-8h2v-2H3zm0-8h2V3c-1.1 0-2 .9-2 2"
}), "HighlightAlt"), iv = vh(/* @__PURE__ */ xt.jsx("path", {
  d: "M10 9h4V6h3l-5-5-5 5h3zm-1 1H6V7l-5 5 5 5v-3h3zm14 2-5-5v3h-3v4h3v3zm-9 3h-4v3H7l5 5 5-5h-3z"
}), "OpenWith"), S_ = vh(/* @__PURE__ */ xt.jsx("path", {
  d: "M1 21h22L12 2zm12-3h-2v-2h2zm0-4h-2v-4h2z"
}), "Warning");
async function rv(I) {
  return Mh(
    await fu()("POST", "/embeddings/selection", I)
  );
}
async function nv(I) {
  return Mh(
    await fu()("POST", "/embeddings/extended-stage", I)
  );
}
async function ov(I) {
  return Mh(
    await fu()("POST", "/embeddings/color-by-choices", I)
  );
}
async function sv({
  datasetName: I,
  brainKey: k,
  view: B,
  labelField: V,
  slices: J
}) {
  const ee = await fu()("POST", "/embeddings/plot", {
    datasetName: I,
    brainKey: k,
    view: B,
    labelField: V,
    slices: J
  });
  return Mh(ee);
}
function Mh(I) {
  if (!I || !I.error)
    return I;
  throw new Error(
    (I == null ? void 0 : I.error) || "Unknown error fetching embeddings plot data."
  );
}
function av() {
  const I = di(oc), [k] = mu(), [B, V] = pl(!1), [J, ee] = pl(null), [he, s] = pl(null);
  return nr(() => {
    k && (V(!0), ov({ datasetName: I, brainKey: k }).then((re) => {
      V(!1), ee(["uncolored", ...re.fields]);
    }).catch((re) => {
      V(!1), s(re);
    }));
  }, [I, k]), {
    availableFields: J,
    isLoading: B
  };
}
const op = () => En("colorByField", null);
function lv() {
  di(bh), di(bx);
  const [I, k] = op(), { availableFields: B, isLoading: V } = av();
  return {
    label: I,
    handlers: {
      onSelect(ee) {
        ee === "uncolored" && (ee = null), k(ee);
      },
      value: I,
      toKey: (ee) => ee,
      useSearch: (ee) => ({
        values: B && B.filter(
          (he) => he.toLowerCase().includes(ee.toLowerCase())
        )
      })
    },
    isLoading: V,
    canSelect: !V && B && B.length > 0
  };
}
const mu = () => En("brainResult", null);
function cv() {
  const [I, k] = mu(), B = di(bh), [V, J] = op();
  return {
    handlers: {
      onSelect(he) {
        k(he), J(null);
      },
      value: I,
      useSearch: (he) => ({
        values: uv(B).filter(
          (s) => s.toLowerCase().includes(he.toLowerCase())
        )
      })
    },
    brainKey: I,
    canSelect: hv(B) > 0,
    hasSelection: I !== null
  };
}
function uv(I) {
  return I.brainMethods.filter(M_).map((k) => k.key);
}
function hv(I) {
  return ((I == null ? void 0 : I.brainMethods) || []).filter(M_).length;
}
function M_(I) {
  return I.config.cls.includes("fiftyone.brain.visualization");
}
const dv = fl.div`
  margin: 0;
  height: 100%;
  width: 100%;
  position: relative;
`, pv = fl.div`
  display: flex;
  gap: 1rem;
  position: absolute;
  top: 1rem;
  display: flex;
  column-gap: 1rem;
  z-index: 1;
  padding: 0 1rem;
  > div {
    display: flex;
    column-gap: 1rem;
  }
`, nc = fl(_h)`
  display: flex;
  color: var(--fo-palette-primary-plainColor);
  align-items: center;
  cursor: pointer;
  border-bottom: 1px var(--fo-palette-primary-plainColor) solid;
  background: var(--fo-palette-neutral-softBg);
  border-top-left-radius: 3px;
  border-top-right-radius: 3px;
  padding: 0.25rem;
`, fv = fl.ul`
  position: absolute;
  top: 3rem;
  z-index: 1;
  list-style: none;
  padding-inline-start: 0;
  background: var(--fo-palette-background-level1);
  > li {
    margin: 1rem 0;
  }
`, mv = fl.li`
  display: flex;
  column-gap: 1rem;
  color: var(--fo-palette-text-plainColor);
  padding: 0 2.5rem 0 1rem;
  border-radius: 3px;
  list-style: none;
  svg {
    position: relative;
    top: 3px;
  }
`, _v = fl.div`
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  cursor: pointer;
`;
function sp() {
  const [I, k] = En(
    "warnings",
    { warnings: [] },
    !0
  ), { warnings: B } = I, V = Array.isArray(B) && B.length > 0, J = (ee) => {
    k((he) => ee(he || { warnings: [] }));
  };
  return {
    hasWarnings: V,
    items: B,
    visible: V && I.visible,
    count: Array.isArray(B) ? B.length : null,
    show() {
      J((ee) => ({ ...ee, visible: !0 }));
    },
    hide() {
      J((ee) => ({ ...ee, visible: !1, userHidden: !0 }));
    },
    clear() {
      J((ee) => ({ ...ee, warnings: null }));
    },
    add(ee) {
      J((he) => ({
        ...he,
        visible: !0,
        warnings: [...he.warnings || [], ee]
      }));
    }
  };
}
function gv() {
  const I = sp();
  return I.visible ? /* @__PURE__ */ xt.jsxs(fv, { children: [
    /* @__PURE__ */ xt.jsx(_v, { children: /* @__PURE__ */ xt.jsx(ep, { onClick: I.hide }) }),
    I.items.map((k) => /* @__PURE__ */ xt.jsxs(mv, { children: [
      /* @__PURE__ */ xt.jsx("div", { children: /* @__PURE__ */ xt.jsx(S_, {}) }),
      /* @__PURE__ */ xt.jsx("div", { children: k })
    ] }))
  ] }) : null;
}
class Xs {
  constructor(k, B, V) {
    this.r = k, this.g = B, this.b = V;
  }
  static fromCSSRGBValues(k, B, V) {
    return new Xs(k / 255, B / 255, V / 255);
  }
  setBrightness(k) {
    const B = this.getBrightness(), V = k - B;
    return new Xs(this.r + V, this.g + V, this.b + V);
  }
  getBrightness() {
    return (this.r + this.g + this.b) / 3;
  }
  toCSSRGBString() {
    return `rgb(${this.r * 255}, ${this.g * 255}, ${this.b * 255})`;
  }
}
const qm = {
  name: [
    "AliceBlue",
    "AntiqueWhite",
    "Aqua",
    "Aquamarine",
    "Azure",
    "Beige",
    "Bisque",
    "Black",
    "BlanchedAlmond",
    "Blue",
    "BlueViolet",
    "Brown",
    "BurlyWood",
    "CadetBlue",
    "Chartreuse",
    "Chocolate",
    "Coral",
    "CornflowerBlue",
    "Cornsilk",
    "Crimson",
    "Cyan",
    "DarkBlue",
    "DarkCyan",
    "DarkGoldenRod",
    "DarkGray",
    "DarkGrey",
    "DarkGreen",
    "DarkKhaki",
    "DarkMagenta",
    "DarkOliveGreen",
    "DarkOrange",
    "DarkOrchid",
    "DarkRed",
    "DarkSalmon",
    "DarkSeaGreen",
    "DarkSlateBlue",
    "DarkSlateGray",
    "DarkSlateGrey",
    "DarkTurquoise",
    "DarkViolet",
    "DeepPink",
    "DeepSkyBlue",
    "DimGray",
    "DimGrey",
    "DodgerBlue",
    "FireBrick",
    "FloralWhite",
    "ForestGreen",
    "Fuchsia",
    "Gainsboro",
    "GhostWhite",
    "Gold",
    "GoldenRod",
    "Gray",
    "Grey",
    "Green",
    "GreenYellow",
    "HoneyDew",
    "HotPink",
    "IndianRed",
    "Indigo",
    "Ivory",
    "Khaki",
    "Lavender",
    "LavenderBlush",
    "LawnGreen",
    "LemonChiffon",
    "LightBlue",
    "LightCoral",
    "LightCyan",
    "LightGoldenRodYellow",
    "LightGray",
    "LightGrey",
    "LightGreen",
    "LightPink",
    "LightSalmon",
    "LightSeaGreen",
    "LightSkyBlue",
    "LightSlateGray",
    "LightSlateGrey",
    "LightSteelBlue",
    "LightYellow",
    "Lime",
    "LimeGreen",
    "Linen",
    "Magenta",
    "Maroon",
    "MediumAquaMarine",
    "MediumBlue",
    "MediumOrchid",
    "MediumPurple",
    "MediumSeaGreen",
    "MediumSlateBlue",
    "MediumSpringGreen",
    "MediumTurquoise",
    "MediumVioletRed",
    "MidnightBlue",
    "MintCream",
    "MistyRose",
    "Moccasin",
    "NavajoWhite",
    "Navy",
    "OldLace",
    "Olive",
    "OliveDrab",
    "Orange",
    "OrangeRed",
    "Orchid",
    "PaleGoldenRod",
    "PaleGreen",
    "PaleTurquoise",
    "PaleVioletRed",
    "PapayaWhip",
    "PeachPuff",
    "Peru",
    "Pink",
    "Plum",
    "PowderBlue",
    "Purple",
    "RebeccaPurple",
    "Red",
    "RosyBrown",
    "RoyalBlue",
    "SaddleBrown",
    "Salmon",
    "SandyBrown",
    "SeaGreen",
    "SeaShell",
    "Sienna",
    "Silver",
    "SkyBlue",
    "SlateBlue",
    "SlateGray",
    "SlateGrey",
    "Snow",
    "SpringGreen",
    "SteelBlue",
    "Tan",
    "Teal",
    "Thistle",
    "Tomato",
    "Turquoise",
    "Violet",
    "Wheat",
    "White",
    "WhiteSmoke",
    "Yellow",
    "YellowGreen"
  ],
  hex: [
    "#f0f8ff",
    "#faebd7",
    "#00ffff",
    "#7fffd4",
    "#f0ffff",
    "#f5f5dc",
    "#ffe4c4",
    "#000000",
    "#ffebcd",
    "#0000ff",
    "#8a2be2",
    "#a52a2a",
    "#deb887",
    "#5f9ea0",
    "#7fff00",
    "#d2691e",
    "#ff7f50",
    "#6495ed",
    "#fff8dc",
    "#dc143c",
    "#00ffff",
    "#00008b",
    "#008b8b",
    "#b8860b",
    "#a9a9a9",
    "#a9a9a9",
    "#006400",
    "#bdb76b",
    "#8b008b",
    "#556b2f",
    "#ff8c00",
    "#9932cc",
    "#8b0000",
    "#e9967a",
    "#8fbc8f",
    "#483d8b",
    "#2f4f4f",
    "#2f4f4f",
    "#00ced1",
    "#9400d3",
    "#ff1493",
    "#00bfff",
    "#696969",
    "#696969",
    "#1e90ff",
    "#b22222",
    "#fffaf0",
    "#228b22",
    "#ff00ff",
    "#dcdcdc",
    "#f8f8ff",
    "#ffd700",
    "#daa520",
    "#808080",
    "#808080",
    "#008000",
    "#adff2f",
    "#f0fff0",
    "#ff69b4",
    "#cd5c5c",
    "#4b0082",
    "#fffff0",
    "#f0e68c",
    "#e6e6fa",
    "#fff0f5",
    "#7cfc00",
    "#fffacd",
    "#add8e6",
    "#f08080",
    "#e0ffff",
    "#fafad2",
    "#d3d3d3",
    "#d3d3d3",
    "#90ee90",
    "#ffb6c1",
    "#ffa07a",
    "#20b2aa",
    "#87cefa",
    "#778899",
    "#778899",
    "#b0c4de",
    "#ffffe0",
    "#00ff00",
    "#32cd32",
    "#faf0e6",
    "#ff00ff",
    "#800000",
    "#66cdaa",
    "#0000cd",
    "#ba55d3",
    "#9370db",
    "#3cb371",
    "#7b68ee",
    "#00fa9a",
    "#48d1cc",
    "#c71585",
    "#191970",
    "#f5fffa",
    "#ffe4e1",
    "#ffe4b5",
    "#ffdead",
    "#000080",
    "#fdf5e6",
    "#808000",
    "#6b8e23",
    "#ffa500",
    "#ff4500",
    "#da70d6",
    "#eee8aa",
    "#98fb98",
    "#afeeee",
    "#db7093",
    "#ffefd5",
    "#ffdab9",
    "#cd853f",
    "#ffc0cb",
    "#dda0dd",
    "#b0e0e6",
    "#800080",
    "#663399",
    "#ff0000",
    "#bc8f8f",
    "#4169e1",
    "#8b4513",
    "#fa8072",
    "#f4a460",
    "#2e8b57",
    "#fff5ee",
    "#a0522d",
    "#c0c0c0",
    "#87ceeb",
    "#6a5acd",
    "#708090",
    "#708090",
    "#fffafa",
    "#00ff7f",
    "#4682b4",
    "#d2b48c",
    "#008080",
    "#d8bfd8",
    "#ff6347",
    "#40e0d0",
    "#ee82ee",
    "#f5deb3",
    "#ffffff",
    "#f5f5f5",
    "#ffff00",
    "#9acd32"
  ]
};
function Wm(I, k, B) {
  for (var V = 0; V < I.length; V++)
    if (I[V][k] === B)
      return V;
  return null;
}
function yv(I, k) {
  let B = Wm(I, "id", k);
  return B == null && (B = Wm(I, "sample_id", k)), B;
}
function xv(I, k) {
  return I.localeCompare(k);
}
const ap = 35, vv = new RegExp(`.{1,${ap}}(\\s|$)`, "g"), bv = new RegExp(`.{1,${ap}}`, "g");
function wv(I, k, B, V, J, ee, he) {
  const s = k === "categorical", re = k === "continuous", Be = k === "uncolored";
  return Object.entries(I).sort((Qe, Ie) => xv(Qe[0], Ie[0])).map(Tv).map(([Qe, Ie]) => {
    const rt = V != null && V.length ? V.map((Ke) => yv(Ie, Ke)).filter((Ke) => Ke !== null) : null, ut = Ev(Qe, he) ?? C_(B(Qe)) ?? new Xs(255, 165, 0), lt = ee.map(
      (Ke, mt) => {
        const kt = Xs.fromCSSRGBValues(...Ke);
        return [mt / (ee.length - 1), kt.toCSSRGBString()];
      }
    );
    return {
      x: Ie.map((Ke) => Ke.points[0]),
      y: Ie.map((Ke) => Ke.points[1]),
      ids: Ie.map((Ke) => Ke.id),
      type: "scattergl",
      mode: "markers",
      marker: {
        autocolorscale: !re,
        // isCategorical || isUncolored,
        colorscale: lt,
        color: s ? ut.toCSSRGBString() : Be ? null : Ie.map((Ke) => Ke.label),
        size: 6,
        colorbar: s || Be ? void 0 : {
          lenmode: "fraction",
          x: 1,
          y: 0.5
        }
      },
      name: Qe,
      selectedpoints: rt,
      selected: {
        marker: {
          opacity: 1,
          size: J === "selected" ? 10 : 6,
          color: J === "selected" ? "orange" : void 0
        }
      },
      unselected: {
        marker: {
          opacity: 0.2
        }
      }
    };
  });
}
const Tv = ([I, k]) => {
  if (I && I.length > ap) {
    let B = I.match(vv);
    B.length === 1 && (B = I.match(bv)), I = B.join("<br />");
  }
  return [I, k];
}, Ev = (I, k) => {
  var V;
  if (!k || !k.valueColors)
    return null;
  const B = (V = k.valueColors.find((J) => J.value === I)) == null ? void 0 : V.color;
  return C_(B);
}, C_ = (I) => {
  if (Array.isArray(I))
    return Xs.fromCSSRGBValues(...I);
  if (!wx(I))
    return null;
  if (I.startsWith("#")) {
    const B = Xm(I);
    return Xs.fromCSSRGBValues(B.r, B.g, B.b);
  }
  if (I.startsWith("rgb")) {
    const B = I.split("(")[1].split(")")[0].split(",");
    return Xs.fromCSSRGBValues(
      parseInt(B[0]),
      parseInt(B[1]),
      parseInt(B[2])
    );
  }
  const k = qm.name.map((B) => B.toLowerCase()).indexOf(I);
  if (k > -1) {
    const B = Xm(qm.hex[k]);
    return Xs.fromCSSRGBValues(B.r, B.g, B.b);
  }
  return null;
};
function Xm(I) {
  const k = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(I);
  return k ? {
    r: parseInt(k[1], 16),
    g: parseInt(k[2], 16),
    b: parseInt(k[3], 16)
  } : null;
}
function Wd(I, k, B = []) {
  nr(() => {
    const V = (J) => {
      J.key === I && k(!0);
    };
    return document.addEventListener("keydown", V), () => {
      document.removeEventListener("keydown", V);
    };
  }, [I, ...B]);
}
function Sv() {
  const I = di(Tx), k = di(oc), [B, V] = mu(), [J] = op(), ee = di(wh), he = di(tp(!1)), s = di(ip), [re, Be] = En(
    "loadedPlot",
    null,
    !0
  ), [Qe, Ie] = En(
    "loadingPlot",
    !0,
    !0
  ), [rt, ut] = En(
    "loadingPlotError",
    null,
    !0
  ), lt = l_(
    c_
  ), Ke = sp();
  nr(() => {
    lt(null), Ie(!0), sv({ datasetName: k, filters: s, brainKey: B, view: ee, labelField: J, slices: he }).catch((mt) => {
      ut(mt);
    }).then((mt) => {
      if (!mt || !mt.index_size) {
        (mt == null ? void 0 : mt.index_size) === 0 && Ke.add("No samples in the current view.");
        return;
      }
      const kt = mt.index_size - mt.available_count, Qt = mt.missing_count;
      mt.index_size;
      const St = mt.patches_field ? "patches" : "samples";
      Ke.clear(), Qt > 0 && Ke.add(
        `${Qt} ${St} in the current view do not have corresponding embeddings.`
      ), kt > 0 && Ke.add(
        `${kt} embeddings in the index correspond to samples not in the current view`
      ), ut(null), Be(mt);
    }).finally(() => Ie(!1));
  }, [k, B, J, ee, I, he, s]);
}
function Mv() {
  di(oc);
  const [I] = mu(), k = di(bh);
  return I && k ? k.brainMethods.find((V) => V.key === I) : null;
}
const Qd = "embe@fiftyone/embeddingsddings";
function lp() {
  var It;
  const I = Mv(), k = (It = I == null ? void 0 : I.config) == null ? void 0 : It.patchesField, B = rp(), [{ selection: V, scope: J }, ee] = du(
    ml
  ), [he, s] = du(
    u_
  ), [re, Be] = En(
    "plotSelection",
    [],
    !0
  ), Qe = di(Ex(k)), Ie = di(Sx);
  function rt(ni) {
    s(/* @__PURE__ */ new Set()), ee({
      selection: ni,
      scope: Qd
    }), ni === null && ut();
  }
  function ut() {
    B(), Be(null), s(/* @__PURE__ */ new Set());
  }
  let lt = null;
  const Ke = Array.from(he), mt = Array.from(Qe), kt = Array.from(Ie);
  let Qt = null;
  return !k && kt && kt.length ? (Qt = kt, lt = "selected") : mt && mt.length ? (Qt = mt, lt = "selected") : Ke && Ke.length ? (Qt = Ke, lt = "selected") : re && re.length ? (Qt = re, lt = "plot") : V && V.length && (Qt = V, lt = "extended"), {
    setPlotSelection: Be,
    handleSelected: rt,
    clearSelection: ut,
    resolvedSelection: Qt,
    hasSelection: Qt !== null,
    selectionStyle: lt,
    selectionIsExternal: J !== Qd
  };
}
function Cv() {
  const { setPlotSelection: I } = lp(), k = di(oc), B = di(u_), [V] = mu(), J = di(wh), [ee] = En("loadedPlot", null, !0), he = di(ip), s = di(Mx), { selection: re } = di(ml), Be = di(tp(!1));
  nr(() => {
    ee && rv({
      datasetName: k,
      brainKey: V,
      view: J,
      filters: he,
      extended: re ? s : null,
      extendedSelection: re,
      slices: Be
    }).then((Ie) => {
      let rt = null;
      Ie.selected ? rt = Ie.selected : B && B.size && (rt = Array.from(B)), I(rt);
    });
  }, [k, V, J, he, re, B]);
}
function Av() {
  const I = di(oc), k = di(wh), [B] = En("loadedPlot", null, !0), V = l_(
    c_
  ), { selection: J } = di(ml), ee = Cx(({ snapshot: s }) => async () => s.getPromise(oc)), he = di(tp(!1));
  nr(() => {
    B && Array.isArray(J) && nv({
      datasetName: I,
      view: k,
      patchesField: B.patches_field,
      selection: J,
      slices: he
    }).then(async (s) => {
      await ee() === I && V({
        [s._cls]: s.kwargs
      });
    });
  }, [I, B == null ? void 0 : B.patches_field, k, J]);
}
function Iv({ clearSelection: I, setPlotSelection: k }) {
  const [B] = En("loadedPlot", null, !0), [V] = En("loadingPlot", !0, !0), [J] = En(
    "loadingPlotError",
    null,
    !0
  );
  return Sv(), Cv(), Av(), {
    ...B || {},
    isLoading: V,
    error: J
  };
}
const A_ = () => En("zoomRevision", 1, !0);
function I_() {
  const [I, k] = A_();
  return () => {
    k((V) => typeof V == "number" ? V + 1 : 2);
  };
}
function Pv({
  labelSelectorLoading: I,
  labelField: k,
  bounds: B,
  plotSelection: V
}) {
  var Dr;
  const J = Th(), ee = di(Ax), he = di($m).fields, s = di($m), re = di(Ix).scale, Be = ((Dr = s.colorscales.find((or) => or.path === k)) == null ? void 0 : Dr.rgb) ?? s.defaultColorscale.rgb ?? re, Qe = Hs(() => he == null ? void 0 : he.find((or) => k == null ? void 0 : k.includes((or == null ? void 0 : or.path) ?? "")), [he, k]), {
    resolvedSelection: Ie,
    clearSelection: rt,
    hasSelection: ut,
    handleSelected: lt,
    selectionStyle: Ke
  } = V, [mt] = A_(), kt = I_(), { isLoading: Qt, traces: St, style: It, error: ni } = Iv(V), [Qr, ui] = En(
    "dragMode",
    "lasso",
    !0
  );
  if (Wd("s", () => ui("lasso")), Wd("g", () => ui("pan")), Wd(
    "Escape",
    () => {
      ut ? rt() : kt();
    },
    [ut]
  ), ni)
    return /* @__PURE__ */ xt.jsx(dl, { children: ni.message });
  if (I || Qt || !St)
    return /* @__PURE__ */ xt.jsx(dl, { children: "Pixelating..." });
  const $i = wv(
    St,
    It,
    ee,
    Ie,
    Ke,
    Be,
    Qe
  ), et = It === "categorical";
  return /* @__PURE__ */ xt.jsx("div", { style: { height: "100%" }, "data-cy": "embeddings-plot-container", children: (B == null ? void 0 : B.width) && /* @__PURE__ */ xt.jsx(
    Px,
    {
      data: $i,
      style: { zIndex: 1 },
      onSelected: (or, Pt) => {
        var Fn;
        if (!or || ((Fn = or == null ? void 0 : or.points) == null ? void 0 : Fn.length) === 0) return;
        const Fi = {}, Zr = [];
        for (const br of or.points)
          Fi[br.fullData.name] || (Fi[br.fullData.name] = []), Fi[br.fullData.name].push(br.id), Zr.push(br.id);
        lt(Zr);
      },
      onDeselect: () => {
        lt(null);
      },
      config: {
        scrollZoom: !0,
        displaylogo: !1,
        responsive: !0,
        displayModeBar: !1
      },
      layout: {
        dragmode: Qr,
        uirevision: mt,
        font: {
          family: "var(--fo-fontFamily-body)",
          size: 14
        },
        showlegend: et,
        width: B.width,
        height: B.height,
        hovermode: !1,
        xaxis: {
          showgrid: !1,
          zeroline: !1,
          visible: !1
        },
        yaxis: {
          showgrid: !1,
          zeroline: !1,
          visible: !1,
          scaleanchor: "x",
          scaleratio: 1
        },
        autosize: !0,
        margin: {
          t: 0,
          l: 0,
          b: 0,
          r: 0,
          pad: 0
        },
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        legend: {
          x: 1,
          y: 1,
          bgcolor: J.background.level1,
          font: {
            color: J.text.secondary
          }
        }
      }
    }
  ) });
}
const Hm = ({ value: I }) => /* @__PURE__ */ xt.jsx(xt.Fragment, { children: I });
function Lv({ containerHeight: I, dimensions: k }) {
  const B = Yr(), V = Th(), J = I_(), ee = cv(), he = lv(), s = ee.canSelect, re = ee.hasSelection, Be = lp(), [Qe, Ie] = En(
    "dragMode",
    "lasso",
    !0
  ), rt = sp(), ut = h_(), lt = m_();
  nr(() => {
    ut(() => {
      Be.clearSelection();
    });
  }, [ut, Be]);
  const Ke = {
    background: V.neutral.softBg,
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
    padding: "0.25rem"
  };
  return s ? /* @__PURE__ */ xt.jsxs(dv, { ref: B, "data-cy": "embeddings-container", children: [
    /* @__PURE__ */ xt.jsx(pv, { children: /* @__PURE__ */ xt.jsxs("div", { children: [
      /* @__PURE__ */ xt.jsx(
        gh,
        {
          cy: "embeddings",
          ...ee.handlers,
          placeholder: "Select brain key",
          overflow: !0,
          component: Hm,
          resultsPlacement: "bottom-start",
          containerStyle: Ke
        }
      ),
      ee.hasSelection && !he.isLoading && /* @__PURE__ */ xt.jsx(
        gh,
        {
          cy: "embeddings-colorby",
          ...he.handlers,
          placeholder: "Color by",
          overflow: !0,
          component: Hm,
          resultsPlacement: "bottom-start",
          containerStyle: Ke
        }
      ),
      !Be.selectionIsExternal && /* @__PURE__ */ xt.jsx(
        nc,
        {
          to: Be.clearSelection,
          title: "Clear selection (Esc)",
          children: /* @__PURE__ */ xt.jsx(ep, {})
        }
      ),
      re && /* @__PURE__ */ xt.jsxs(Jx, { children: [
        /* @__PURE__ */ xt.jsx(nc, { to: () => J(), title: "Reset zoom (Esc)", children: /* @__PURE__ */ xt.jsx(E_, {}) }),
        /* @__PURE__ */ xt.jsx(
          nc,
          {
            cy: "embeddings-plot-option-lasso",
            style: { opacity: Qe !== "lasso" ? 0.5 : 1 },
            to: () => Ie("lasso"),
            title: "Select (s)",
            children: /* @__PURE__ */ xt.jsx(tv, {})
          }
        ),
        /* @__PURE__ */ xt.jsx(
          nc,
          {
            style: { opacity: Qe !== "pan" ? 0.5 : 1 },
            to: () => Ie("pan"),
            title: "Pan (g)",
            children: /* @__PURE__ */ xt.jsx(iv, {})
          }
        ),
        rt.count > 0 && /* @__PURE__ */ xt.jsxs(nc, { to: () => rt.show(), title: "Warnings", children: [
          /* @__PURE__ */ xt.jsx(S_, { style: { marginRight: "0.5rem" } }),
          rt.count
        ] }),
        /* @__PURE__ */ xt.jsx(gv, {}),
        /* @__PURE__ */ xt.jsx(
          nc,
          {
            href: "https://docs.voxel51.com/user_guide/app.html#embeddings-panel",
            title: "Help",
            to: lt,
            target: "_blank",
            children: /* @__PURE__ */ xt.jsx(d_, {})
          }
        )
      ] }),
      /* @__PURE__ */ xt.jsx(p_, { place: f_.EMBEDDINGS_ACTIONS })
    ] }) }),
    re && /* @__PURE__ */ xt.jsx(
      Pv,
      {
        labelSelectorLoading: he.isLoading,
        plotSelection: Be,
        bounds: k.bounds,
        el: B,
        brainKey: ee.brainKey,
        labelField: he.label,
        containerHeight: I
      }
    )
  ] }) : /* @__PURE__ */ xt.jsx(dl, { style: { background: V.background.mediaSpace }, children: /* @__PURE__ */ xt.jsxs(zv, { style: { textAlign: "center" }, children: [
    /* @__PURE__ */ xt.jsx("h3", { children: "No embeddings visualizations found." }),
    /* @__PURE__ */ xt.jsxs("p", { children: [
      /* @__PURE__ */ xt.jsx(
        Lx,
        {
          style: { color: V.text.primary },
          href: "https://docs.voxel51.com/user_guide/app.html#embeddings-panel",
          children: "Learn more"
        }
      ),
      " ",
      "about using this feature."
    ] })
  ] }) });
}
const zv = fl.div`
  text-align: center;
`;
function kv() {
  const { selection: I, scope: k } = di(ml), B = lp();
  return k !== Qd ? null : /* @__PURE__ */ xt.jsx(
    __,
    {
      selectionCount: I == null ? void 0 : I.length.toString(),
      onClickSelection: B.clearSelection
    }
  );
}
g_({
  name: "Embeddings",
  label: "Embeddings",
  component: Lv,
  type: y_.Panel,
  activator: () => !0,
  Icon: zx,
  panelOptions: {
    TabIndicator: kv,
    priority: x_
  }
});
const Dv = "_container_1wrzk_1";
var P_ = { exports: {} };
(function(I, k) {
  (function(B, V) {
    I.exports = V();
  })(v_, function() {
    var B = function(y, E) {
      var O = { drag: [], click: [], mousemove: [], mousedown: [], mouseup: [], mouseout: [], keydown: [], keyup: [], touchstart: [], touchmove: [], touchend: [], tap: [] }, Y = { on: function(fe, _e, qe) {
        if (O[fe] === void 0) throw new Error("Invalid event type: " + fe);
        O[fe].push({ selector: _e, fn: qe });
      }, render: function(fe) {
        E.store.featureChanged(fe);
      } }, ne = function(fe, _e) {
        for (var qe = O[fe], tt = qe.length; tt--; ) {
          var dt = qe[tt];
          if (dt.selector(_e)) {
            dt.fn.call(Y, _e) || E.store.render(), E.ui.updateMapClasses();
            break;
          }
        }
      };
      return y.start.call(Y), { render: y.render, stop: function() {
        y.stop && y.stop();
      }, trash: function() {
        y.trash && (y.trash(), E.store.render());
      }, combineFeatures: function() {
        y.combineFeatures && y.combineFeatures();
      }, uncombineFeatures: function() {
        y.uncombineFeatures && y.uncombineFeatures();
      }, drag: function(fe) {
        ne("drag", fe);
      }, click: function(fe) {
        ne("click", fe);
      }, mousemove: function(fe) {
        ne("mousemove", fe);
      }, mousedown: function(fe) {
        ne("mousedown", fe);
      }, mouseup: function(fe) {
        ne("mouseup", fe);
      }, mouseout: function(fe) {
        ne("mouseout", fe);
      }, keydown: function(fe) {
        ne("keydown", fe);
      }, keyup: function(fe) {
        ne("keyup", fe);
      }, touchstart: function(fe) {
        ne("touchstart", fe);
      }, touchmove: function(fe) {
        ne("touchmove", fe);
      }, touchend: function(fe) {
        ne("touchend", fe);
      }, tap: function(fe) {
        ne("tap", fe);
      } };
    };
    function V(y) {
      return y && y.__esModule && Object.prototype.hasOwnProperty.call(y, "default") ? y.default : y;
    }
    function J(y) {
      if (y.__esModule) return y;
      var E = y.default;
      if (typeof E == "function") {
        var O = function Y() {
          if (this instanceof Y) {
            var ne = [null];
            ne.push.apply(ne, arguments);
            var fe = Function.bind.apply(E, ne);
            return new fe();
          }
          return E.apply(this, arguments);
        };
        O.prototype = E.prototype;
      } else O = {};
      return Object.defineProperty(O, "__esModule", { value: !0 }), Object.keys(y).forEach(function(Y) {
        var ne = Object.getOwnPropertyDescriptor(y, Y);
        Object.defineProperty(O, Y, ne.get ? ne : { enumerable: !0, get: function() {
          return y[Y];
        } });
      }), O;
    }
    var ee = {}, he = { RADIUS: 6378137, FLATTENING: 1 / 298.257223563, POLAR_RADIUS: 63567523142e-4 }, s = he;
    function re(y) {
      var E = 0;
      if (y && y.length > 0) {
        E += Math.abs(Be(y[0]));
        for (var O = 1; O < y.length; O++) E -= Math.abs(Be(y[O]));
      }
      return E;
    }
    function Be(y) {
      var E, O, Y, ne, fe, _e, qe = 0, tt = y.length;
      if (tt > 2) {
        for (_e = 0; _e < tt; _e++) _e === tt - 2 ? (Y = tt - 2, ne = tt - 1, fe = 0) : _e === tt - 1 ? (Y = tt - 1, ne = 0, fe = 1) : (Y = _e, ne = _e + 1, fe = _e + 2), E = y[Y], O = y[ne], qe += (Qe(y[fe][0]) - Qe(E[0])) * Math.sin(Qe(O[1]));
        qe = qe * s.RADIUS * s.RADIUS / 2;
      }
      return qe;
    }
    function Qe(y) {
      return y * Math.PI / 180;
    }
    ee.geometry = function y(E) {
      var O, Y = 0;
      switch (E.type) {
        case "Polygon":
          return re(E.coordinates);
        case "MultiPolygon":
          for (O = 0; O < E.coordinates.length; O++) Y += re(E.coordinates[O]);
          return Y;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
          return 0;
        case "GeometryCollection":
          for (O = 0; O < E.geometries.length; O++) Y += y(E.geometries[O]);
          return Y;
      }
    }, ee.ring = Be;
    var Ie = { CONTROL_BASE: "mapboxgl-ctrl", CONTROL_PREFIX: "mapboxgl-ctrl-", CONTROL_BUTTON: "mapbox-gl-draw_ctrl-draw-btn", CONTROL_BUTTON_LINE: "mapbox-gl-draw_line", CONTROL_BUTTON_POLYGON: "mapbox-gl-draw_polygon", CONTROL_BUTTON_POINT: "mapbox-gl-draw_point", CONTROL_BUTTON_TRASH: "mapbox-gl-draw_trash", CONTROL_BUTTON_COMBINE_FEATURES: "mapbox-gl-draw_combine", CONTROL_BUTTON_UNCOMBINE_FEATURES: "mapbox-gl-draw_uncombine", CONTROL_GROUP: "mapboxgl-ctrl-group", ATTRIBUTION: "mapboxgl-ctrl-attrib", ACTIVE_BUTTON: "active", BOX_SELECT: "mapbox-gl-draw_boxselect" }, rt = { HOT: "mapbox-gl-draw-hot", COLD: "mapbox-gl-draw-cold" }, ut = { ADD: "add", MOVE: "move", DRAG: "drag", POINTER: "pointer", NONE: "none" }, lt = { POLYGON: "polygon", LINE: "line_string", POINT: "point" }, Ke = { FEATURE: "Feature", POLYGON: "Polygon", LINE_STRING: "LineString", POINT: "Point", FEATURE_COLLECTION: "FeatureCollection", MULTI_PREFIX: "Multi", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon" }, mt = { DRAW_LINE_STRING: "draw_line_string", DRAW_POLYGON: "draw_polygon", DRAW_POINT: "draw_point", SIMPLE_SELECT: "simple_select", DIRECT_SELECT: "direct_select", STATIC: "static" }, kt = { CREATE: "draw.create", DELETE: "draw.delete", UPDATE: "draw.update", SELECTION_CHANGE: "draw.selectionchange", MODE_CHANGE: "draw.modechange", ACTIONABLE: "draw.actionable", RENDER: "draw.render", COMBINE_FEATURES: "draw.combine", UNCOMBINE_FEATURES: "draw.uncombine" }, Qt = { MOVE: "move", CHANGE_COORDINATES: "change_coordinates" }, St = { FEATURE: "feature", MIDPOINT: "midpoint", VERTEX: "vertex" }, It = { ACTIVE: "true", INACTIVE: "false" }, ni = ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"], Qr = -85, ui = Object.freeze({ __proto__: null, classes: Ie, sources: rt, cursors: ut, types: lt, geojsonTypes: Ke, modes: mt, events: kt, updateActions: Qt, meta: St, activeStates: It, interactions: ni, LAT_MIN: -90, LAT_RENDERED_MIN: Qr, LAT_MAX: 90, LAT_RENDERED_MAX: 85, LNG_MIN: -270, LNG_MAX: 270 }), $i = { Point: 0, LineString: 1, MultiLineString: 1, Polygon: 2 };
    function et(y, E) {
      var O = $i[y.geometry.type] - $i[E.geometry.type];
      return O === 0 && y.geometry.type === Ke.POLYGON ? y.area - E.area : O;
    }
    function Dr(y) {
      return y.map(function(E) {
        return E.geometry.type === Ke.POLYGON && (E.area = ee.geometry({ type: Ke.FEATURE, property: {}, geometry: E.geometry })), E;
      }).sort(et).map(function(E) {
        return delete E.area, E;
      });
    }
    function or(y, E) {
      return E === void 0 && (E = 0), [[y.point.x - E, y.point.y - E], [y.point.x + E, y.point.y + E]];
    }
    function Pt(y) {
      if (this._items = {}, this._nums = {}, this._length = y ? y.length : 0, y) for (var E = 0, O = y.length; E < O; E++) this.add(y[E]), y[E] !== void 0 && (typeof y[E] == "string" ? this._items[y[E]] = E : this._nums[y[E]] = E);
    }
    Pt.prototype.add = function(y) {
      return this.has(y) || (this._length++, typeof y == "string" ? this._items[y] = this._length : this._nums[y] = this._length), this;
    }, Pt.prototype.delete = function(y) {
      return this.has(y) === !1 || (this._length--, delete this._items[y], delete this._nums[y]), this;
    }, Pt.prototype.has = function(y) {
      return (typeof y == "string" || typeof y == "number") && (this._items[y] !== void 0 || this._nums[y] !== void 0);
    }, Pt.prototype.values = function() {
      var y = this, E = [];
      return Object.keys(this._items).forEach(function(O) {
        E.push({ k: O, v: y._items[O] });
      }), Object.keys(this._nums).forEach(function(O) {
        E.push({ k: JSON.parse(O), v: y._nums[O] });
      }), E.sort(function(O, Y) {
        return O.v - Y.v;
      }).map(function(O) {
        return O.k;
      });
    }, Pt.prototype.clear = function() {
      return this._length = 0, this._items = {}, this._nums = {}, this;
    };
    var Fi = [St.FEATURE, St.MIDPOINT, St.VERTEX], Zr = { click: function(y, E, O) {
      return Fn(y, E, O, O.options.clickBuffer);
    }, touch: function(y, E, O) {
      return Fn(y, E, O, O.options.touchBuffer);
    } };
    function Fn(y, E, O, Y) {
      if (O.map === null) return [];
      var ne = y ? or(y, Y) : E, fe = {};
      O.options.styles && (fe.layers = O.options.styles.map(function(dt) {
        return dt.id;
      }).filter(function(dt) {
        return O.map.getLayer(dt) != null;
      }));
      var _e = O.map.queryRenderedFeatures(ne, fe).filter(function(dt) {
        return Fi.indexOf(dt.properties.meta) !== -1;
      }), qe = new Pt(), tt = [];
      return _e.forEach(function(dt) {
        var ft = dt.properties.id;
        qe.has(ft) || (qe.add(ft), tt.push(dt));
      }), Dr(tt);
    }
    function br(y, E) {
      var O = Zr.click(y, null, E), Y = { mouse: ut.NONE };
      return O[0] && (Y.mouse = O[0].properties.active === It.ACTIVE ? ut.MOVE : ut.POINTER, Y.feature = O[0].properties.meta), E.events.currentModeName().indexOf("draw") !== -1 && (Y.mouse = ut.ADD), E.ui.queueMapClasses(Y), E.ui.updateMapClasses(), O[0];
    }
    function ao(y, E) {
      var O = y.x - E.x, Y = y.y - E.y;
      return Math.sqrt(O * O + Y * Y);
    }
    function Vt(y, E, O) {
      O === void 0 && (O = {});
      var Y = O.fineTolerance != null ? O.fineTolerance : 4, ne = O.grossTolerance != null ? O.grossTolerance : 12, fe = O.interval != null ? O.interval : 500;
      y.point = y.point || E.point, y.time = y.time || E.time;
      var _e = ao(y.point, E.point);
      return _e < Y || _e < ne && E.time - y.time < fe;
    }
    function Sn(y, E, O) {
      O === void 0 && (O = {});
      var Y = O.tolerance != null ? O.tolerance : 25, ne = O.interval != null ? O.interval : 250;
      return y.point = y.point || E.point, y.time = y.time || E.time, ao(y.point, E.point) < Y && E.time - y.time < ne;
    }
    var Zi = { exports: {} }, er = Zi.exports = function(y, E) {
      if (E || (E = 16), y === void 0 && (y = 128), y <= 0) return "0";
      for (var O = Math.log(Math.pow(2, y)) / Math.log(E), Y = 2; O === 1 / 0; Y *= 2) O = Math.log(Math.pow(2, y / Y)) / Math.log(E) * Y;
      var ne = O - Math.floor(O), fe = "";
      for (Y = 0; Y < Math.floor(O); Y++)
        fe = Math.floor(Math.random() * E).toString(E) + fe;
      if (ne) {
        var _e = Math.pow(E, ne);
        fe = Math.floor(Math.random() * _e).toString(E) + fe;
      }
      var qe = parseInt(fe, E);
      return qe !== 1 / 0 && qe >= Math.pow(2, y) ? er(y, E) : fe;
    };
    er.rack = function(y, E, O) {
      var Y = function(fe) {
        var _e = 0;
        do {
          if (_e++ > 10) {
            if (!O) throw new Error("too many ID collisions, use more bits");
            y += O;
          }
          var qe = er(y, E);
        } while (Object.hasOwnProperty.call(ne, qe));
        return ne[qe] = fe, qe;
      }, ne = Y.hats = {};
      return Y.get = function(fe) {
        return Y.hats[fe];
      }, Y.set = function(fe, _e) {
        return Y.hats[fe] = _e, Y;
      }, Y.bits = y || 128, Y.base = E || 16, Y;
    };
    var Mn = V(Zi.exports), si = function(y, E) {
      this.ctx = y, this.properties = E.properties || {}, this.coordinates = E.geometry.coordinates, this.id = E.id || Mn(), this.type = E.geometry.type;
    };
    si.prototype.changed = function() {
      this.ctx.store.featureChanged(this.id);
    }, si.prototype.incomingCoords = function(y) {
      this.setCoordinates(y);
    }, si.prototype.setCoordinates = function(y) {
      this.coordinates = y, this.changed();
    }, si.prototype.getCoordinates = function() {
      return JSON.parse(JSON.stringify(this.coordinates));
    }, si.prototype.setProperty = function(y, E) {
      this.properties[y] = E;
    }, si.prototype.toGeoJSON = function() {
      return JSON.parse(JSON.stringify({ id: this.id, type: Ke.FEATURE, properties: this.properties, geometry: { coordinates: this.getCoordinates(), type: this.type } }));
    }, si.prototype.internal = function(y) {
      var E = { id: this.id, meta: St.FEATURE, "meta:type": this.type, active: It.INACTIVE, mode: y };
      if (this.ctx.options.userProperties) for (var O in this.properties) E["user_" + O] = this.properties[O];
      return { type: Ke.FEATURE, properties: E, geometry: { coordinates: this.getCoordinates(), type: this.type } };
    };
    var Rr = function(y, E) {
      si.call(this, y, E);
    };
    (Rr.prototype = Object.create(si.prototype)).isValid = function() {
      return typeof this.coordinates[0] == "number" && typeof this.coordinates[1] == "number";
    }, Rr.prototype.updateCoordinate = function(y, E, O) {
      this.coordinates = arguments.length === 3 ? [E, O] : [y, E], this.changed();
    }, Rr.prototype.getCoordinate = function() {
      return this.getCoordinates();
    };
    var Or = function(y, E) {
      si.call(this, y, E);
    };
    (Or.prototype = Object.create(si.prototype)).isValid = function() {
      return this.coordinates.length > 1;
    }, Or.prototype.addCoordinate = function(y, E, O) {
      this.changed();
      var Y = parseInt(y, 10);
      this.coordinates.splice(Y, 0, [E, O]);
    }, Or.prototype.getCoordinate = function(y) {
      var E = parseInt(y, 10);
      return JSON.parse(JSON.stringify(this.coordinates[E]));
    }, Or.prototype.removeCoordinate = function(y) {
      this.changed(), this.coordinates.splice(parseInt(y, 10), 1);
    }, Or.prototype.updateCoordinate = function(y, E, O) {
      var Y = parseInt(y, 10);
      this.coordinates[Y] = [E, O], this.changed();
    };
    var sr = function(y, E) {
      si.call(this, y, E), this.coordinates = this.coordinates.map(function(O) {
        return O.slice(0, -1);
      });
    };
    (sr.prototype = Object.create(si.prototype)).isValid = function() {
      return this.coordinates.length !== 0 && this.coordinates.every(function(y) {
        return y.length > 2;
      });
    }, sr.prototype.incomingCoords = function(y) {
      this.coordinates = y.map(function(E) {
        return E.slice(0, -1);
      }), this.changed();
    }, sr.prototype.setCoordinates = function(y) {
      this.coordinates = y, this.changed();
    }, sr.prototype.addCoordinate = function(y, E, O) {
      this.changed();
      var Y = y.split(".").map(function(ne) {
        return parseInt(ne, 10);
      });
      this.coordinates[Y[0]].splice(Y[1], 0, [E, O]);
    }, sr.prototype.removeCoordinate = function(y) {
      this.changed();
      var E = y.split(".").map(function(Y) {
        return parseInt(Y, 10);
      }), O = this.coordinates[E[0]];
      O && (O.splice(E[1], 1), O.length < 3 && this.coordinates.splice(E[0], 1));
    }, sr.prototype.getCoordinate = function(y) {
      var E = y.split(".").map(function(Y) {
        return parseInt(Y, 10);
      }), O = this.coordinates[E[0]];
      return JSON.parse(JSON.stringify(O[E[1]]));
    }, sr.prototype.getCoordinates = function() {
      return this.coordinates.map(function(y) {
        return y.concat([y[0]]);
      });
    }, sr.prototype.updateCoordinate = function(y, E, O) {
      this.changed();
      var Y = y.split("."), ne = parseInt(Y[0], 10), fe = parseInt(Y[1], 10);
      this.coordinates[ne] === void 0 && (this.coordinates[ne] = []), this.coordinates[ne][fe] = [E, O];
    };
    var Un = { MultiPoint: Rr, MultiLineString: Or, MultiPolygon: sr }, Io = function(y, E, O, Y, ne) {
      var fe = O.split("."), _e = parseInt(fe[0], 10), qe = fe[1] ? fe.slice(1).join(".") : null;
      return y[_e][E](qe, Y, ne);
    }, tr = function(y, E) {
      if (si.call(this, y, E), delete this.coordinates, this.model = Un[E.geometry.type], this.model === void 0) throw new TypeError(E.geometry.type + " is not a valid type");
      this.features = this._coordinatesToFeatures(E.geometry.coordinates);
    };
    function Wt(y) {
      this.map = y.map, this.drawConfig = JSON.parse(JSON.stringify(y.options || {})), this._ctx = y;
    }
    (tr.prototype = Object.create(si.prototype))._coordinatesToFeatures = function(y) {
      var E = this, O = this.model.bind(this);
      return y.map(function(Y) {
        return new O(E.ctx, { id: Mn(), type: Ke.FEATURE, properties: {}, geometry: { coordinates: Y, type: E.type.replace("Multi", "") } });
      });
    }, tr.prototype.isValid = function() {
      return this.features.every(function(y) {
        return y.isValid();
      });
    }, tr.prototype.setCoordinates = function(y) {
      this.features = this._coordinatesToFeatures(y), this.changed();
    }, tr.prototype.getCoordinate = function(y) {
      return Io(this.features, "getCoordinate", y);
    }, tr.prototype.getCoordinates = function() {
      return JSON.parse(JSON.stringify(this.features.map(function(y) {
        return y.type === Ke.POLYGON ? y.getCoordinates() : y.coordinates;
      })));
    }, tr.prototype.updateCoordinate = function(y, E, O) {
      Io(this.features, "updateCoordinate", y, E, O), this.changed();
    }, tr.prototype.addCoordinate = function(y, E, O) {
      Io(this.features, "addCoordinate", y, E, O), this.changed();
    }, tr.prototype.removeCoordinate = function(y) {
      Io(this.features, "removeCoordinate", y), this.changed();
    }, tr.prototype.getFeatures = function() {
      return this.features;
    }, Wt.prototype.setSelected = function(y) {
      return this._ctx.store.setSelected(y);
    }, Wt.prototype.setSelectedCoordinates = function(y) {
      var E = this;
      this._ctx.store.setSelectedCoordinates(y), y.reduce(function(O, Y) {
        return O[Y.feature_id] === void 0 && (O[Y.feature_id] = !0, E._ctx.store.get(Y.feature_id).changed()), O;
      }, {});
    }, Wt.prototype.getSelected = function() {
      return this._ctx.store.getSelected();
    }, Wt.prototype.getSelectedIds = function() {
      return this._ctx.store.getSelectedIds();
    }, Wt.prototype.isSelected = function(y) {
      return this._ctx.store.isSelected(y);
    }, Wt.prototype.getFeature = function(y) {
      return this._ctx.store.get(y);
    }, Wt.prototype.select = function(y) {
      return this._ctx.store.select(y);
    }, Wt.prototype.deselect = function(y) {
      return this._ctx.store.deselect(y);
    }, Wt.prototype.deleteFeature = function(y, E) {
      return E === void 0 && (E = {}), this._ctx.store.delete(y, E);
    }, Wt.prototype.addFeature = function(y) {
      return this._ctx.store.add(y);
    }, Wt.prototype.clearSelectedFeatures = function() {
      return this._ctx.store.clearSelected();
    }, Wt.prototype.clearSelectedCoordinates = function() {
      return this._ctx.store.clearSelectedCoordinates();
    }, Wt.prototype.setActionableState = function(y) {
      y === void 0 && (y = {});
      var E = { trash: y.trash || !1, combineFeatures: y.combineFeatures || !1, uncombineFeatures: y.uncombineFeatures || !1 };
      return this._ctx.events.actionable(E);
    }, Wt.prototype.changeMode = function(y, E, O) {
      return E === void 0 && (E = {}), O === void 0 && (O = {}), this._ctx.events.changeMode(y, E, O);
    }, Wt.prototype.updateUIClasses = function(y) {
      return this._ctx.ui.queueMapClasses(y);
    }, Wt.prototype.activateUIButton = function(y) {
      return this._ctx.ui.setActiveButton(y);
    }, Wt.prototype.featuresAt = function(y, E, O) {
      if (O === void 0 && (O = "click"), O !== "click" && O !== "touch") throw new Error("invalid buffer type");
      return Zr[O](y, E, this._ctx);
    }, Wt.prototype.newFeature = function(y) {
      var E = y.geometry.type;
      return E === Ke.POINT ? new Rr(this._ctx, y) : E === Ke.LINE_STRING ? new Or(this._ctx, y) : E === Ke.POLYGON ? new sr(this._ctx, y) : new tr(this._ctx, y);
    }, Wt.prototype.isInstanceOf = function(y, E) {
      if (y === Ke.POINT) return E instanceof Rr;
      if (y === Ke.LINE_STRING) return E instanceof Or;
      if (y === Ke.POLYGON) return E instanceof sr;
      if (y === "MultiFeature") return E instanceof tr;
      throw new Error("Unknown feature class: " + y);
    }, Wt.prototype.doRender = function(y) {
      return this._ctx.store.featureChanged(y);
    }, Wt.prototype.onSetup = function() {
    }, Wt.prototype.onDrag = function() {
    }, Wt.prototype.onClick = function() {
    }, Wt.prototype.onMouseMove = function() {
    }, Wt.prototype.onMouseDown = function() {
    }, Wt.prototype.onMouseUp = function() {
    }, Wt.prototype.onMouseOut = function() {
    }, Wt.prototype.onKeyUp = function() {
    }, Wt.prototype.onKeyDown = function() {
    }, Wt.prototype.onTouchStart = function() {
    }, Wt.prototype.onTouchMove = function() {
    }, Wt.prototype.onTouchEnd = function() {
    }, Wt.prototype.onTap = function() {
    }, Wt.prototype.onStop = function() {
    }, Wt.prototype.onTrash = function() {
    }, Wt.prototype.onCombineFeature = function() {
    }, Wt.prototype.onUncombineFeature = function() {
    }, Wt.prototype.toDisplayFeatures = function() {
      throw new Error("You must overwrite toDisplayFeatures");
    };
    var ei = { drag: "onDrag", click: "onClick", mousemove: "onMouseMove", mousedown: "onMouseDown", mouseup: "onMouseUp", mouseout: "onMouseOut", keyup: "onKeyUp", keydown: "onKeyDown", touchstart: "onTouchStart", touchmove: "onTouchMove", touchend: "onTouchEnd", tap: "onTap" }, Yo = Object.keys(ei);
    function qr(y) {
      var E = Object.keys(y);
      return function(O, Y) {
        Y === void 0 && (Y = {});
        var ne = {}, fe = E.reduce(function(_e, qe) {
          return _e[qe] = y[qe], _e;
        }, new Wt(O));
        return { start: function() {
          var _e = this;
          ne = fe.onSetup(Y), Yo.forEach(function(qe) {
            var tt, dt = ei[qe], ft = function() {
              return !1;
            };
            y[dt] && (ft = function() {
              return !0;
            }), _e.on(qe, ft, (tt = dt, function(nt) {
              return fe[tt](ne, nt);
            }));
          });
        }, stop: function() {
          fe.onStop(ne);
        }, trash: function() {
          fe.onTrash(ne);
        }, combineFeatures: function() {
          fe.onCombineFeatures(ne);
        }, uncombineFeatures: function() {
          fe.onUncombineFeatures(ne);
        }, render: function(_e, qe) {
          fe.toDisplayFeatures(ne, _e, qe);
        } };
      };
    }
    function Nn(y) {
      return [].concat(y).filter(function(E) {
        return E !== void 0;
      });
    }
    function Ui() {
      var y = this;
      if (!(y.ctx.map && y.ctx.map.getSource(rt.HOT) !== void 0)) return tt();
      var E = y.ctx.events.currentModeName();
      y.ctx.ui.queueMapClasses({ mode: E });
      var O = [], Y = [];
      y.isDirty ? Y = y.getAllIds() : (O = y.getChangedIds().filter(function(dt) {
        return y.get(dt) !== void 0;
      }), Y = y.sources.hot.filter(function(dt) {
        return dt.properties.id && O.indexOf(dt.properties.id) === -1 && y.get(dt.properties.id) !== void 0;
      }).map(function(dt) {
        return dt.properties.id;
      })), y.sources.hot = [];
      var ne = y.sources.cold.length;
      y.sources.cold = y.isDirty ? [] : y.sources.cold.filter(function(dt) {
        var ft = dt.properties.id || dt.properties.parent;
        return O.indexOf(ft) === -1;
      });
      var fe = ne !== y.sources.cold.length || Y.length > 0;
      function _e(dt, ft) {
        var nt = y.get(dt).internal(E);
        y.ctx.events.currentModeRender(nt, function(zt) {
          y.sources[ft].push(zt);
        });
      }
      if (O.forEach(function(dt) {
        return _e(dt, "hot");
      }), Y.forEach(function(dt) {
        return _e(dt, "cold");
      }), fe && y.ctx.map.getSource(rt.COLD).setData({ type: Ke.FEATURE_COLLECTION, features: y.sources.cold }), y.ctx.map.getSource(rt.HOT).setData({ type: Ke.FEATURE_COLLECTION, features: y.sources.hot }), y._emitSelectionChange && (y.ctx.map.fire(kt.SELECTION_CHANGE, { features: y.getSelected().map(function(dt) {
        return dt.toGeoJSON();
      }), points: y.getSelectedCoordinates().map(function(dt) {
        return { type: Ke.FEATURE, properties: {}, geometry: { type: Ke.POINT, coordinates: dt.coordinates } };
      }) }), y._emitSelectionChange = !1), y._deletedFeaturesToEmit.length) {
        var qe = y._deletedFeaturesToEmit.map(function(dt) {
          return dt.toGeoJSON();
        });
        y._deletedFeaturesToEmit = [], y.ctx.map.fire(kt.DELETE, { features: qe });
      }
      function tt() {
        y.isDirty = !1, y.clearChangedIds();
      }
      tt(), y.ctx.map.fire(kt.RENDER, {});
    }
    function oi(y) {
      var E, O = this;
      this._features = {}, this._featureIds = new Pt(), this._selectedFeatureIds = new Pt(), this._selectedCoordinates = [], this._changedFeatureIds = new Pt(), this._deletedFeaturesToEmit = [], this._emitSelectionChange = !1, this._mapInitialConfig = {}, this.ctx = y, this.sources = { hot: [], cold: [] }, this.render = function() {
        E || (E = requestAnimationFrame(function() {
          E = null, Ui.call(O);
        }));
      }, this.isDirty = !1;
    }
    function ws(y, E) {
      var O = y._selectedCoordinates.filter(function(Y) {
        return y._selectedFeatureIds.has(Y.feature_id);
      });
      y._selectedCoordinates.length === O.length || E.silent || (y._emitSelectionChange = !0), y._selectedCoordinates = O;
    }
    oi.prototype.createRenderBatch = function() {
      var y = this, E = this.render, O = 0;
      return this.render = function() {
        O++;
      }, function() {
        y.render = E, O > 0 && y.render();
      };
    }, oi.prototype.setDirty = function() {
      return this.isDirty = !0, this;
    }, oi.prototype.featureChanged = function(y) {
      return this._changedFeatureIds.add(y), this;
    }, oi.prototype.getChangedIds = function() {
      return this._changedFeatureIds.values();
    }, oi.prototype.clearChangedIds = function() {
      return this._changedFeatureIds.clear(), this;
    }, oi.prototype.getAllIds = function() {
      return this._featureIds.values();
    }, oi.prototype.add = function(y) {
      return this.featureChanged(y.id), this._features[y.id] = y, this._featureIds.add(y.id), this;
    }, oi.prototype.delete = function(y, E) {
      var O = this;
      return E === void 0 && (E = {}), Nn(y).forEach(function(Y) {
        O._featureIds.has(Y) && (O._featureIds.delete(Y), O._selectedFeatureIds.delete(Y), E.silent || O._deletedFeaturesToEmit.indexOf(O._features[Y]) === -1 && O._deletedFeaturesToEmit.push(O._features[Y]), delete O._features[Y], O.isDirty = !0);
      }), ws(this, E), this;
    }, oi.prototype.get = function(y) {
      return this._features[y];
    }, oi.prototype.getAll = function() {
      var y = this;
      return Object.keys(this._features).map(function(E) {
        return y._features[E];
      });
    }, oi.prototype.select = function(y, E) {
      var O = this;
      return E === void 0 && (E = {}), Nn(y).forEach(function(Y) {
        O._selectedFeatureIds.has(Y) || (O._selectedFeatureIds.add(Y), O._changedFeatureIds.add(Y), E.silent || (O._emitSelectionChange = !0));
      }), this;
    }, oi.prototype.deselect = function(y, E) {
      var O = this;
      return E === void 0 && (E = {}), Nn(y).forEach(function(Y) {
        O._selectedFeatureIds.has(Y) && (O._selectedFeatureIds.delete(Y), O._changedFeatureIds.add(Y), E.silent || (O._emitSelectionChange = !0));
      }), ws(this, E), this;
    }, oi.prototype.clearSelected = function(y) {
      return y === void 0 && (y = {}), this.deselect(this._selectedFeatureIds.values(), { silent: y.silent }), this;
    }, oi.prototype.setSelected = function(y, E) {
      var O = this;
      return E === void 0 && (E = {}), y = Nn(y), this.deselect(this._selectedFeatureIds.values().filter(function(Y) {
        return y.indexOf(Y) === -1;
      }), { silent: E.silent }), this.select(y.filter(function(Y) {
        return !O._selectedFeatureIds.has(Y);
      }), { silent: E.silent }), this;
    }, oi.prototype.setSelectedCoordinates = function(y) {
      return this._selectedCoordinates = y, this._emitSelectionChange = !0, this;
    }, oi.prototype.clearSelectedCoordinates = function() {
      return this._selectedCoordinates = [], this._emitSelectionChange = !0, this;
    }, oi.prototype.getSelectedIds = function() {
      return this._selectedFeatureIds.values();
    }, oi.prototype.getSelected = function() {
      var y = this;
      return this._selectedFeatureIds.values().map(function(E) {
        return y.get(E);
      });
    }, oi.prototype.getSelectedCoordinates = function() {
      var y = this;
      return this._selectedCoordinates.map(function(E) {
        return { coordinates: y.get(E.feature_id).getCoordinate(E.coord_path) };
      });
    }, oi.prototype.isSelected = function(y) {
      return this._selectedFeatureIds.has(y);
    }, oi.prototype.setFeatureProperty = function(y, E, O) {
      this.get(y).setProperty(E, O), this.featureChanged(y);
    }, oi.prototype.storeMapConfig = function() {
      var y = this;
      ni.forEach(function(E) {
        y.ctx.map[E] && (y._mapInitialConfig[E] = y.ctx.map[E].isEnabled());
      });
    }, oi.prototype.restoreMapConfig = function() {
      var y = this;
      Object.keys(this._mapInitialConfig).forEach(function(E) {
        y._mapInitialConfig[E] ? y.ctx.map[E].enable() : y.ctx.map[E].disable();
      });
    }, oi.prototype.getInitialConfigValue = function(y) {
      return this._mapInitialConfig[y] === void 0 || this._mapInitialConfig[y];
    };
    var jn = function() {
      for (var y = arguments, E = {}, O = 0; O < arguments.length; O++) {
        var Y = y[O];
        for (var ne in Y) Wr.call(Y, ne) && (E[ne] = Y[ne]);
      }
      return E;
    }, Wr = Object.prototype.hasOwnProperty, en = V(jn), Qo = ["mode", "feature", "mouse"];
    function Ts(y) {
      var E = null, O = null, Y = { onRemove: function() {
        return y.map.off("load", Y.connect), clearInterval(O), Y.removeLayers(), y.store.restoreMapConfig(), y.ui.removeButtons(), y.events.removeEventListeners(), y.ui.clearMapClasses(), y.boxZoomInitial && y.map.boxZoom.enable(), y.map = null, y.container = null, y.store = null, E && E.parentNode && E.parentNode.removeChild(E), E = null, this;
      }, connect: function() {
        y.map.off("load", Y.connect), clearInterval(O), Y.addLayers(), y.store.storeMapConfig(), y.events.addEventListeners();
      }, onAdd: function(ne) {
        var fe = ne.fire;
        return ne.fire = function(_e, qe) {
          var tt = arguments;
          return fe.length === 1 && arguments.length !== 1 && (tt = [en({}, { type: _e }, qe)]), fe.apply(ne, tt);
        }, y.map = ne, y.events = function(_e) {
          var qe = Object.keys(_e.options.modes).reduce(function(De, bt) {
            return De[bt] = qr(_e.options.modes[bt]), De;
          }, {}), tt = {}, dt = {}, ft = {}, nt = null, zt = null;
          ft.drag = function(De, bt) {
            bt({ point: De.point, time: (/* @__PURE__ */ new Date()).getTime() }) ? (_e.ui.queueMapClasses({ mouse: ut.DRAG }), zt.drag(De)) : De.originalEvent.stopPropagation();
          }, ft.mousedrag = function(De) {
            ft.drag(De, function(bt) {
              return !Vt(tt, bt);
            });
          }, ft.touchdrag = function(De) {
            ft.drag(De, function(bt) {
              return !Sn(dt, bt);
            });
          }, ft.mousemove = function(De) {
            if ((De.originalEvent.buttons !== void 0 ? De.originalEvent.buttons : De.originalEvent.which) === 1) return ft.mousedrag(De);
            var bt = br(De, _e);
            De.featureTarget = bt, zt.mousemove(De);
          }, ft.mousedown = function(De) {
            tt = { time: (/* @__PURE__ */ new Date()).getTime(), point: De.point };
            var bt = br(De, _e);
            De.featureTarget = bt, zt.mousedown(De);
          }, ft.mouseup = function(De) {
            var bt = br(De, _e);
            De.featureTarget = bt, Vt(tt, { point: De.point, time: (/* @__PURE__ */ new Date()).getTime() }) ? zt.click(De) : zt.mouseup(De);
          }, ft.mouseout = function(De) {
            zt.mouseout(De);
          }, ft.touchstart = function(De) {
            if (_e.options.touchEnabled) {
              dt = { time: (/* @__PURE__ */ new Date()).getTime(), point: De.point };
              var bt = Zr.touch(De, null, _e)[0];
              De.featureTarget = bt, zt.touchstart(De);
            }
          }, ft.touchmove = function(De) {
            if (_e.options.touchEnabled) return zt.touchmove(De), ft.touchdrag(De);
          }, ft.touchend = function(De) {
            if (De.originalEvent.preventDefault(), _e.options.touchEnabled) {
              var bt = Zr.touch(De, null, _e)[0];
              De.featureTarget = bt, Sn(dt, { time: (/* @__PURE__ */ new Date()).getTime(), point: De.point }) ? zt.tap(De) : zt.touchend(De);
            }
          };
          var Oi = function(De) {
            return !(De === 8 || De === 46 || De >= 48 && De <= 57);
          };
          function Ot(De, bt, gi) {
            gi === void 0 && (gi = {}), zt.stop();
            var yi = qe[De];
            if (yi === void 0) throw new Error(De + " is not valid");
            nt = De;
            var xi = yi(_e, bt);
            zt = B(xi, _e), gi.silent || _e.map.fire(kt.MODE_CHANGE, { mode: De }), _e.store.setDirty(), _e.store.render();
          }
          ft.keydown = function(De) {
            (De.srcElement || De.target).classList.contains("mapboxgl-canvas") && (De.keyCode !== 8 && De.keyCode !== 46 || !_e.options.controls.trash ? Oi(De.keyCode) ? zt.keydown(De) : De.keyCode === 49 && _e.options.controls.point ? Ot(mt.DRAW_POINT) : De.keyCode === 50 && _e.options.controls.line_string ? Ot(mt.DRAW_LINE_STRING) : De.keyCode === 51 && _e.options.controls.polygon && Ot(mt.DRAW_POLYGON) : (De.preventDefault(), zt.trash()));
          }, ft.keyup = function(De) {
            Oi(De.keyCode) && zt.keyup(De);
          }, ft.zoomend = function() {
            _e.store.changeZoom();
          }, ft.data = function(De) {
            if (De.dataType === "style") {
              var bt = _e.setup, gi = _e.map, yi = _e.options, xi = _e.store;
              yi.styles.some(function(Js) {
                return gi.getLayer(Js.id);
              }) || (bt.addLayers(), xi.setDirty(), xi.render());
            }
          };
          var pi = { trash: !1, combineFeatures: !1, uncombineFeatures: !1 };
          return { start: function() {
            nt = _e.options.defaultMode, zt = B(qe[nt](_e), _e);
          }, changeMode: Ot, actionable: function(De) {
            var bt = !1;
            Object.keys(De).forEach(function(gi) {
              if (pi[gi] === void 0) throw new Error("Invalid action type");
              pi[gi] !== De[gi] && (bt = !0), pi[gi] = De[gi];
            }), bt && _e.map.fire(kt.ACTIONABLE, { actions: pi });
          }, currentModeName: function() {
            return nt;
          }, currentModeRender: function(De, bt) {
            return zt.render(De, bt);
          }, fire: function(De, bt) {
            ft[De] && ft[De](bt);
          }, addEventListeners: function() {
            _e.map.on("mousemove", ft.mousemove), _e.map.on("mousedown", ft.mousedown), _e.map.on("mouseup", ft.mouseup), _e.map.on("data", ft.data), _e.map.on("touchmove", ft.touchmove), _e.map.on("touchstart", ft.touchstart), _e.map.on("touchend", ft.touchend), _e.container.addEventListener("mouseout", ft.mouseout), _e.options.keybindings && (_e.container.addEventListener("keydown", ft.keydown), _e.container.addEventListener("keyup", ft.keyup));
          }, removeEventListeners: function() {
            _e.map.off("mousemove", ft.mousemove), _e.map.off("mousedown", ft.mousedown), _e.map.off("mouseup", ft.mouseup), _e.map.off("data", ft.data), _e.map.off("touchmove", ft.touchmove), _e.map.off("touchstart", ft.touchstart), _e.map.off("touchend", ft.touchend), _e.container.removeEventListener("mouseout", ft.mouseout), _e.options.keybindings && (_e.container.removeEventListener("keydown", ft.keydown), _e.container.removeEventListener("keyup", ft.keyup));
          }, trash: function(De) {
            zt.trash(De);
          }, combineFeatures: function() {
            zt.combineFeatures();
          }, uncombineFeatures: function() {
            zt.uncombineFeatures();
          }, getMode: function() {
            return nt;
          } };
        }(y), y.ui = /* @__PURE__ */ function(_e) {
          var qe = {}, tt = null, dt = { mode: null, feature: null, mouse: null }, ft = { mode: null, feature: null, mouse: null };
          function nt(De) {
            ft = en(ft, De);
          }
          function zt() {
            var De, bt;
            if (_e.container) {
              var gi = [], yi = [];
              Qo.forEach(function(xi) {
                ft[xi] !== dt[xi] && (gi.push(xi + "-" + dt[xi]), ft[xi] !== null && yi.push(xi + "-" + ft[xi]));
              }), gi.length > 0 && (De = _e.container.classList).remove.apply(De, gi), yi.length > 0 && (bt = _e.container.classList).add.apply(bt, yi), dt = en(dt, ft);
            }
          }
          function Oi(De, bt) {
            bt === void 0 && (bt = {});
            var gi = document.createElement("button");
            return gi.className = Ie.CONTROL_BUTTON + " " + bt.className, gi.setAttribute("title", bt.title), bt.container.appendChild(gi), gi.addEventListener("click", function(yi) {
              if (yi.preventDefault(), yi.stopPropagation(), yi.target === tt) return Ot(), void bt.onDeactivate();
              pi(De), bt.onActivate();
            }, !0), gi;
          }
          function Ot() {
            tt && (tt.classList.remove(Ie.ACTIVE_BUTTON), tt = null);
          }
          function pi(De) {
            Ot();
            var bt = qe[De];
            bt && bt && De !== "trash" && (bt.classList.add(Ie.ACTIVE_BUTTON), tt = bt);
          }
          return { setActiveButton: pi, queueMapClasses: nt, updateMapClasses: zt, clearMapClasses: function() {
            nt({ mode: null, feature: null, mouse: null }), zt();
          }, addButtons: function() {
            var De = _e.options.controls, bt = document.createElement("div");
            return bt.className = Ie.CONTROL_GROUP + " " + Ie.CONTROL_BASE, De && (De[lt.LINE] && (qe[lt.LINE] = Oi(lt.LINE, { container: bt, className: Ie.CONTROL_BUTTON_LINE, title: "LineString tool " + (_e.options.keybindings ? "(l)" : ""), onActivate: function() {
              return _e.events.changeMode(mt.DRAW_LINE_STRING);
            }, onDeactivate: function() {
              return _e.events.trash();
            } })), De[lt.POLYGON] && (qe[lt.POLYGON] = Oi(lt.POLYGON, { container: bt, className: Ie.CONTROL_BUTTON_POLYGON, title: "Polygon tool " + (_e.options.keybindings ? "(p)" : ""), onActivate: function() {
              return _e.events.changeMode(mt.DRAW_POLYGON);
            }, onDeactivate: function() {
              return _e.events.trash();
            } })), De[lt.POINT] && (qe[lt.POINT] = Oi(lt.POINT, { container: bt, className: Ie.CONTROL_BUTTON_POINT, title: "Marker tool " + (_e.options.keybindings ? "(m)" : ""), onActivate: function() {
              return _e.events.changeMode(mt.DRAW_POINT);
            }, onDeactivate: function() {
              return _e.events.trash();
            } })), De.trash && (qe.trash = Oi("trash", { container: bt, className: Ie.CONTROL_BUTTON_TRASH, title: "Delete", onActivate: function() {
              _e.events.trash();
            } })), De.combine_features && (qe.combine_features = Oi("combineFeatures", { container: bt, className: Ie.CONTROL_BUTTON_COMBINE_FEATURES, title: "Combine", onActivate: function() {
              _e.events.combineFeatures();
            } })), De.uncombine_features && (qe.uncombine_features = Oi("uncombineFeatures", { container: bt, className: Ie.CONTROL_BUTTON_UNCOMBINE_FEATURES, title: "Uncombine", onActivate: function() {
              _e.events.uncombineFeatures();
            } }))), bt;
          }, removeButtons: function() {
            Object.keys(qe).forEach(function(De) {
              var bt = qe[De];
              bt.parentNode && bt.parentNode.removeChild(bt), delete qe[De];
            });
          } };
        }(y), y.container = ne.getContainer(), y.store = new oi(y), E = y.ui.addButtons(), y.options.boxSelect && (y.boxZoomInitial = ne.boxZoom.isEnabled(), ne.boxZoom.disable(), ne.dragPan.disable(), ne.dragPan.enable()), ne.loaded() ? Y.connect() : (ne.on("load", Y.connect), O = setInterval(function() {
          ne.loaded() && Y.connect();
        }, 16)), y.events.start(), E;
      }, addLayers: function() {
        y.map.addSource(rt.COLD, { data: { type: Ke.FEATURE_COLLECTION, features: [] }, type: "geojson" }), y.map.addSource(rt.HOT, { data: { type: Ke.FEATURE_COLLECTION, features: [] }, type: "geojson" }), y.options.styles.forEach(function(ne) {
          y.map.addLayer(ne);
        }), y.store.setDirty(!0), y.store.render();
      }, removeLayers: function() {
        y.options.styles.forEach(function(ne) {
          y.map.getLayer(ne.id) && y.map.removeLayer(ne.id);
        }), y.map.getSource(rt.COLD) && y.map.removeSource(rt.COLD), y.map.getSource(rt.HOT) && y.map.removeSource(rt.HOT);
      } };
      return y.setup = Y, Y;
    }
    var Vn = [{ id: "gl-draw-polygon-fill-inactive", type: "fill", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], paint: { "fill-color": "#3bb2d0", "fill-outline-color": "#3bb2d0", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-fill-active", type: "fill", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#fbb03b", "fill-outline-color": "#fbb03b", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-midpoint", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-stroke-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-polygon-stroke-active", type: "line", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-line-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "LineString"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-line-active", type: "line", filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-polygon-and-line-vertex-stroke-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-color": "#fff" } }, { id: "gl-draw-polygon-and-line-vertex-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-point-point-stroke-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-opacity": 1, "circle-color": "#fff" } }, { id: "gl-draw-point-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#3bb2d0" } }, { id: "gl-draw-point-stroke-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "active", "true"], ["!=", "meta", "midpoint"]], paint: { "circle-radius": 7, "circle-color": "#fff" } }, { id: "gl-draw-point-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["!=", "meta", "midpoint"], ["==", "active", "true"]], paint: { "circle-radius": 5, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-fill-static", type: "fill", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#404040", "fill-outline-color": "#404040", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-stroke-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-line-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "LineString"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-point-static", type: "circle", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Point"]], paint: { "circle-radius": 5, "circle-color": "#404040" } }];
    function Gn(y) {
      return function(E) {
        var O = E.featureTarget;
        return !!O && !!O.properties && O.properties.meta === y;
      };
    }
    function Es(y) {
      return !!y.originalEvent && !!y.originalEvent.shiftKey && y.originalEvent.button === 0;
    }
    function Cn(y) {
      return !!y.featureTarget && !!y.featureTarget.properties && y.featureTarget.properties.active === It.ACTIVE && y.featureTarget.properties.meta === St.FEATURE;
    }
    function Br(y) {
      return !!y.featureTarget && !!y.featureTarget.properties && y.featureTarget.properties.active === It.INACTIVE && y.featureTarget.properties.meta === St.FEATURE;
    }
    function mn(y) {
      return y.featureTarget === void 0;
    }
    function Po(y) {
      return !!y.featureTarget && !!y.featureTarget.properties && y.featureTarget.properties.meta === St.FEATURE;
    }
    function _n(y) {
      var E = y.featureTarget;
      return !!E && !!E.properties && E.properties.meta === St.VERTEX;
    }
    function $n(y) {
      return !!y.originalEvent && y.originalEvent.shiftKey === !0;
    }
    function lo(y) {
      return y.keyCode === 27;
    }
    function An(y) {
      return y.keyCode === 13;
    }
    var co = Object.freeze({ __proto__: null, isOfMetaType: Gn, isShiftMousedown: Es, isActiveFeature: Cn, isInactiveFeature: Br, noTarget: mn, isFeature: Po, isVertex: _n, isShiftDown: $n, isEscapeKey: lo, isEnterKey: An, isTrue: function() {
      return !0;
    } }), Lo = tn;
    function tn(y, E) {
      this.x = y, this.y = E;
    }
    tn.prototype = { clone: function() {
      return new tn(this.x, this.y);
    }, add: function(y) {
      return this.clone()._add(y);
    }, sub: function(y) {
      return this.clone()._sub(y);
    }, multByPoint: function(y) {
      return this.clone()._multByPoint(y);
    }, divByPoint: function(y) {
      return this.clone()._divByPoint(y);
    }, mult: function(y) {
      return this.clone()._mult(y);
    }, div: function(y) {
      return this.clone()._div(y);
    }, rotate: function(y) {
      return this.clone()._rotate(y);
    }, rotateAround: function(y, E) {
      return this.clone()._rotateAround(y, E);
    }, matMult: function(y) {
      return this.clone()._matMult(y);
    }, unit: function() {
      return this.clone()._unit();
    }, perp: function() {
      return this.clone()._perp();
    }, round: function() {
      return this.clone()._round();
    }, mag: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }, equals: function(y) {
      return this.x === y.x && this.y === y.y;
    }, dist: function(y) {
      return Math.sqrt(this.distSqr(y));
    }, distSqr: function(y) {
      var E = y.x - this.x, O = y.y - this.y;
      return E * E + O * O;
    }, angle: function() {
      return Math.atan2(this.y, this.x);
    }, angleTo: function(y) {
      return Math.atan2(this.y - y.y, this.x - y.x);
    }, angleWith: function(y) {
      return this.angleWithSep(y.x, y.y);
    }, angleWithSep: function(y, E) {
      return Math.atan2(this.x * E - this.y * y, this.x * y + this.y * E);
    }, _matMult: function(y) {
      var E = y[0] * this.x + y[1] * this.y, O = y[2] * this.x + y[3] * this.y;
      return this.x = E, this.y = O, this;
    }, _add: function(y) {
      return this.x += y.x, this.y += y.y, this;
    }, _sub: function(y) {
      return this.x -= y.x, this.y -= y.y, this;
    }, _mult: function(y) {
      return this.x *= y, this.y *= y, this;
    }, _div: function(y) {
      return this.x /= y, this.y /= y, this;
    }, _multByPoint: function(y) {
      return this.x *= y.x, this.y *= y.y, this;
    }, _divByPoint: function(y) {
      return this.x /= y.x, this.y /= y.y, this;
    }, _unit: function() {
      return this._div(this.mag()), this;
    }, _perp: function() {
      var y = this.y;
      return this.y = this.x, this.x = -y, this;
    }, _rotate: function(y) {
      var E = Math.cos(y), O = Math.sin(y), Y = E * this.x - O * this.y, ne = O * this.x + E * this.y;
      return this.x = Y, this.y = ne, this;
    }, _rotateAround: function(y, E) {
      var O = Math.cos(y), Y = Math.sin(y), ne = E.x + O * (this.x - E.x) - Y * (this.y - E.y), fe = E.y + Y * (this.x - E.x) + O * (this.y - E.y);
      return this.x = ne, this.y = fe, this;
    }, _round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    } }, tn.convert = function(y) {
      return y instanceof tn ? y : Array.isArray(y) ? new tn(y[0], y[1]) : y;
    };
    var es = V(Lo);
    function ts(y, E) {
      var O = E.getBoundingClientRect();
      return new es(y.clientX - O.left - (E.clientLeft || 0), y.clientY - O.top - (E.clientTop || 0));
    }
    function Q(y, E, O, Y) {
      return { type: Ke.FEATURE, properties: { meta: St.VERTEX, parent: y, coord_path: O, active: Y ? It.ACTIVE : It.INACTIVE }, geometry: { type: Ke.POINT, coordinates: E } };
    }
    function D(y, E, O) {
      var Y = E.geometry.coordinates, ne = O.geometry.coordinates;
      if (Y[1] > 85 || Y[1] < Qr || ne[1] > 85 || ne[1] < Qr) return null;
      var fe = { lng: (Y[0] + ne[0]) / 2, lat: (Y[1] + ne[1]) / 2 };
      return { type: Ke.FEATURE, properties: { meta: St.MIDPOINT, parent: y, lng: fe.lng, lat: fe.lat, coord_path: O.properties.coord_path }, geometry: { type: Ke.POINT, coordinates: [fe.lng, fe.lat] } };
    }
    function R(y, E, O) {
      E === void 0 && (E = {}), O === void 0 && (O = null);
      var Y, ne = y.geometry, fe = ne.type, _e = ne.coordinates, qe = y.properties && y.properties.id, tt = [];
      function dt(nt, zt) {
        var Oi = "", Ot = null;
        nt.forEach(function(pi, De) {
          var bt = zt != null ? zt + "." + De : String(De), gi = Q(qe, pi, bt, ft(bt));
          if (E.midpoints && Ot) {
            var yi = D(qe, Ot, gi);
            yi && tt.push(yi);
          }
          Ot = gi;
          var xi = JSON.stringify(pi);
          Oi !== xi && tt.push(gi), De === 0 && (Oi = xi);
        });
      }
      function ft(nt) {
        return !!E.selectedPaths && E.selectedPaths.indexOf(nt) !== -1;
      }
      return fe === Ke.POINT ? tt.push(Q(qe, _e, O, ft(O))) : fe === Ke.POLYGON ? _e.forEach(function(nt, zt) {
        dt(nt, O !== null ? O + "." + zt : String(zt));
      }) : fe === Ke.LINE_STRING ? dt(_e, O) : fe.indexOf(Ke.MULTI_PREFIX) === 0 && (Y = fe.replace(Ke.MULTI_PREFIX, ""), _e.forEach(function(nt, zt) {
        var Oi = { type: Ke.FEATURE, properties: y.properties, geometry: { type: Y, coordinates: nt } };
        tt = tt.concat(R(Oi, E, zt));
      })), tt;
    }
    var H = { enable: function(y) {
      setTimeout(function() {
        y.map && y.map.doubleClickZoom && y._ctx && y._ctx.store && y._ctx.store.getInitialConfigValue && y._ctx.store.getInitialConfigValue("doubleClickZoom") && y.map.doubleClickZoom.enable();
      }, 0);
    }, disable: function(y) {
      setTimeout(function() {
        y.map && y.map.doubleClickZoom && y.map.doubleClickZoom.disable();
      }, 0);
    } }, se = { exports: {} }, de = function(y) {
      if (!y || !y.type) return null;
      var E = ve[y.type];
      if (!E) return null;
      if (E === "geometry") return { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: y }] };
      if (E === "feature") return { type: "FeatureCollection", features: [y] };
      if (E === "featurecollection") return y;
    }, ve = { Point: "geometry", MultiPoint: "geometry", LineString: "geometry", MultiLineString: "geometry", Polygon: "geometry", MultiPolygon: "geometry", GeometryCollection: "geometry", Feature: "feature", FeatureCollection: "featurecollection" }, xe = V(de), pe = Object.freeze({ __proto__: null, default: function y(E) {
      switch (E && E.type || null) {
        case "FeatureCollection":
          return E.features = E.features.reduce(function(O, Y) {
            return O.concat(y(Y));
          }, []), E;
        case "Feature":
          return E.geometry ? y(E.geometry).map(function(O) {
            var Y = { type: "Feature", properties: JSON.parse(JSON.stringify(E.properties)), geometry: O };
            return E.id !== void 0 && (Y.id = E.id), Y;
          }) : [E];
        case "MultiPoint":
          return E.coordinates.map(function(O) {
            return { type: "Point", coordinates: O };
          });
        case "MultiPolygon":
          return E.coordinates.map(function(O) {
            return { type: "Polygon", coordinates: O };
          });
        case "MultiLineString":
          return E.coordinates.map(function(O) {
            return { type: "LineString", coordinates: O };
          });
        case "GeometryCollection":
          return E.geometries.map(y).reduce(function(O, Y) {
            return O.concat(Y);
          }, []);
        case "Point":
        case "Polygon":
        case "LineString":
          return [E];
      }
    } }), Me = de, Xe = J(pe), it = function(y) {
      return function E(O) {
        return Array.isArray(O) && O.length && typeof O[0] == "number" ? [O] : O.reduce(function(Y, ne) {
          return Array.isArray(ne) && Array.isArray(ne[0]) ? Y.concat(E(ne)) : (Y.push(ne), Y);
        }, []);
      }(y);
    };
    Xe instanceof Function || (Xe = Xe.default);
    var Ze = { exports: {} }, Bt = Ze.exports = function(y) {
      return new Lt(y);
    };
    function Lt(y) {
      this.value = y;
    }
    function Rt(y, E, O) {
      var Y = [], ne = [], fe = !0;
      return function _e(qe) {
        var tt = O ? qt(qe) : qe, dt = {}, ft = !0, nt = { node: tt, node_: qe, path: [].concat(Y), parent: ne[ne.length - 1], parents: ne, key: Y.slice(-1)[0], isRoot: Y.length === 0, level: Y.length, circular: null, update: function(Ot, pi) {
          nt.isRoot || (nt.parent.node[nt.key] = Ot), nt.node = Ot, pi && (ft = !1);
        }, delete: function(Ot) {
          delete nt.parent.node[nt.key], Ot && (ft = !1);
        }, remove: function(Ot) {
          Hi(nt.parent.node) ? nt.parent.node.splice(nt.key, 1) : delete nt.parent.node[nt.key], Ot && (ft = !1);
        }, keys: null, before: function(Ot) {
          dt.before = Ot;
        }, after: function(Ot) {
          dt.after = Ot;
        }, pre: function(Ot) {
          dt.pre = Ot;
        }, post: function(Ot) {
          dt.post = Ot;
        }, stop: function() {
          fe = !1;
        }, block: function() {
          ft = !1;
        } };
        if (!fe) return nt;
        function zt() {
          if (typeof nt.node == "object" && nt.node !== null) {
            nt.keys && nt.node_ === nt.node || (nt.keys = Xt(nt.node)), nt.isLeaf = nt.keys.length == 0;
            for (var Ot = 0; Ot < ne.length; Ot++) if (ne[Ot].node_ === qe) {
              nt.circular = ne[Ot];
              break;
            }
          } else nt.isLeaf = !0, nt.keys = null;
          nt.notLeaf = !nt.isLeaf, nt.notRoot = !nt.isRoot;
        }
        zt();
        var Oi = E.call(nt, nt.node);
        return Oi !== void 0 && nt.update && nt.update(Oi), dt.before && dt.before.call(nt, nt.node), ft && (typeof nt.node != "object" || nt.node === null || nt.circular || (ne.push(nt), zt(), ar(nt.keys, function(Ot, pi) {
          Y.push(Ot), dt.pre && dt.pre.call(nt, nt.node[Ot], Ot);
          var De = _e(nt.node[Ot]);
          O && qi.call(nt.node, Ot) && (nt.node[Ot] = De.node), De.isLast = pi == nt.keys.length - 1, De.isFirst = pi == 0, dt.post && dt.post.call(nt, De), Y.pop();
        }), ne.pop()), dt.after && dt.after.call(nt, nt.node)), nt;
      }(y).node;
    }
    function qt(y) {
      if (typeof y == "object" && y !== null) {
        var E;
        if (Hi(y)) E = [];
        else if (bi(y) === "[object Date]") E = new Date(y.getTime ? y.getTime() : y);
        else if (function(ne) {
          return bi(ne) === "[object RegExp]";
        }(y)) E = new RegExp(y);
        else if (function(ne) {
          return bi(ne) === "[object Error]";
        }(y)) E = { message: y.message };
        else if (function(ne) {
          return bi(ne) === "[object Boolean]";
        }(y)) E = new Boolean(y);
        else if (function(ne) {
          return bi(ne) === "[object Number]";
        }(y)) E = new Number(y);
        else if (function(ne) {
          return bi(ne) === "[object String]";
        }(y)) E = new String(y);
        else if (Object.create && Object.getPrototypeOf) E = Object.create(Object.getPrototypeOf(y));
        else if (y.constructor === Object) E = {};
        else {
          var O = y.constructor && y.constructor.prototype || y.__proto__ || {}, Y = function() {
          };
          Y.prototype = O, E = new Y();
        }
        return ar(Xt(y), function(ne) {
          E[ne] = y[ne];
        }), E;
      }
      return y;
    }
    Lt.prototype.get = function(y) {
      for (var E = this.value, O = 0; O < y.length; O++) {
        var Y = y[O];
        if (!E || !qi.call(E, Y)) {
          E = void 0;
          break;
        }
        E = E[Y];
      }
      return E;
    }, Lt.prototype.has = function(y) {
      for (var E = this.value, O = 0; O < y.length; O++) {
        var Y = y[O];
        if (!E || !qi.call(E, Y)) return !1;
        E = E[Y];
      }
      return !0;
    }, Lt.prototype.set = function(y, E) {
      for (var O = this.value, Y = 0; Y < y.length - 1; Y++) {
        var ne = y[Y];
        qi.call(O, ne) || (O[ne] = {}), O = O[ne];
      }
      return O[y[Y]] = E, E;
    }, Lt.prototype.map = function(y) {
      return Rt(this.value, y, !0);
    }, Lt.prototype.forEach = function(y) {
      return this.value = Rt(this.value, y, !1), this.value;
    }, Lt.prototype.reduce = function(y, E) {
      var O = arguments.length === 1, Y = O ? this.value : E;
      return this.forEach(function(ne) {
        this.isRoot && O || (Y = y.call(this, Y, ne));
      }), Y;
    }, Lt.prototype.paths = function() {
      var y = [];
      return this.forEach(function(E) {
        y.push(this.path);
      }), y;
    }, Lt.prototype.nodes = function() {
      var y = [];
      return this.forEach(function(E) {
        y.push(this.node);
      }), y;
    }, Lt.prototype.clone = function() {
      var y = [], E = [];
      return function O(Y) {
        for (var ne = 0; ne < y.length; ne++) if (y[ne] === Y) return E[ne];
        if (typeof Y == "object" && Y !== null) {
          var fe = qt(Y);
          return y.push(Y), E.push(fe), ar(Xt(Y), function(_e) {
            fe[_e] = O(Y[_e]);
          }), y.pop(), E.pop(), fe;
        }
        return Y;
      }(this.value);
    };
    var Xt = Object.keys || function(y) {
      var E = [];
      for (var O in y) E.push(O);
      return E;
    };
    function bi(y) {
      return Object.prototype.toString.call(y);
    }
    var Hi = Array.isArray || function(y) {
      return Object.prototype.toString.call(y) === "[object Array]";
    }, ar = function(y, E) {
      if (y.forEach) return y.forEach(E);
      for (var O = 0; O < y.length; O++) E(y[O], O, y);
    };
    ar(Xt(Lt.prototype), function(y) {
      Bt[y] = function(E) {
        var O = [].slice.call(arguments, 1), Y = new Lt(E);
        return Y[y].apply(Y, O);
      };
    });
    var qi = Object.hasOwnProperty || function(y, E) {
      return E in y;
    }, In = Ze.exports, gr = wi;
    function wi(y) {
      if (!(this instanceof wi)) return new wi(y);
      this._bbox = y || [1 / 0, 1 / 0, -1 / 0, -1 / 0], this._valid = !!y;
    }
    wi.prototype.include = function(y) {
      return this._valid = !0, this._bbox[0] = Math.min(this._bbox[0], y[0]), this._bbox[1] = Math.min(this._bbox[1], y[1]), this._bbox[2] = Math.max(this._bbox[2], y[0]), this._bbox[3] = Math.max(this._bbox[3], y[1]), this;
    }, wi.prototype.equals = function(y) {
      var E;
      return E = y instanceof wi ? y.bbox() : y, this._bbox[0] == E[0] && this._bbox[1] == E[1] && this._bbox[2] == E[2] && this._bbox[3] == E[3];
    }, wi.prototype.center = function(y) {
      return this._valid ? [(this._bbox[0] + this._bbox[2]) / 2, (this._bbox[1] + this._bbox[3]) / 2] : null;
    }, wi.prototype.union = function(y) {
      var E;
      return this._valid = !0, E = y instanceof wi ? y.bbox() : y, this._bbox[0] = Math.min(this._bbox[0], E[0]), this._bbox[1] = Math.min(this._bbox[1], E[1]), this._bbox[2] = Math.max(this._bbox[2], E[2]), this._bbox[3] = Math.max(this._bbox[3], E[3]), this;
    }, wi.prototype.bbox = function() {
      return this._valid ? this._bbox : null;
    }, wi.prototype.contains = function(y) {
      if (!y) return this._fastContains();
      if (!this._valid) return null;
      var E = y[0], O = y[1];
      return this._bbox[0] <= E && this._bbox[1] <= O && this._bbox[2] >= E && this._bbox[3] >= O;
    }, wi.prototype.intersect = function(y) {
      return this._valid ? (E = y instanceof wi ? y.bbox() : y, !(this._bbox[0] > E[2] || this._bbox[2] < E[0] || this._bbox[3] < E[1] || this._bbox[1] > E[3])) : null;
      var E;
    }, wi.prototype._fastContains = function() {
      if (!this._valid) return new Function("return null;");
      var y = "return " + this._bbox[0] + "<= ll[0] &&" + this._bbox[1] + "<= ll[1] &&" + this._bbox[2] + ">= ll[0] &&" + this._bbox[3] + ">= ll[1]";
      return new Function("ll", y);
    }, wi.prototype.polygon = function() {
      return this._valid ? { type: "Polygon", coordinates: [[[this._bbox[0], this._bbox[1]], [this._bbox[2], this._bbox[1]], [this._bbox[2], this._bbox[3]], [this._bbox[0], this._bbox[3]], [this._bbox[0], this._bbox[1]]]] } : null;
    };
    var is = function(y) {
      if (!y) return [];
      var E = Xe(Me(y)), O = [];
      return E.features.forEach(function(Y) {
        Y.geometry && (O = O.concat(it(Y.geometry.coordinates)));
      }), O;
    }, hc = In, yl = gr, ai = { features: ["FeatureCollection"], coordinates: ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], geometry: ["Feature"], geometries: ["GeometryCollection"] }, Ma = Object.keys(ai);
    function zo(y) {
      for (var E = yl(), O = is(y), Y = 0; Y < O.length; Y++) E.include(O[Y]);
      return E;
    }
    se.exports = function(y) {
      return zo(y).bbox();
    }, se.exports.polygon = function(y) {
      return zo(y).polygon();
    }, se.exports.bboxify = function(y) {
      return hc(y).map(function(E) {
        E && Ma.some(function(O) {
          return !!E[O] && ai[O].indexOf(E.type) !== -1;
        }) && (E.bbox = zo(E).bbox(), this.update(E));
      });
    };
    var Ca = V(se.exports), ko = -90;
    function rn(y, E) {
      var O = ko, Y = 90, ne = ko, fe = 90, _e = 270, qe = -270;
      y.forEach(function(dt) {
        var ft = Ca(dt), nt = ft[1], zt = ft[3], Oi = ft[0], Ot = ft[2];
        nt > O && (O = nt), zt < Y && (Y = zt), zt > ne && (ne = zt), nt < fe && (fe = nt), Oi < _e && (_e = Oi), Ot > qe && (qe = Ot);
      });
      var tt = E;
      return O + tt.lat > 85 && (tt.lat = 85 - O), ne + tt.lat > 90 && (tt.lat = 90 - ne), Y + tt.lat < -85 && (tt.lat = -85 - Y), fe + tt.lat < ko && (tt.lat = ko - fe), _e + tt.lng <= -270 && (tt.lng += 360 * Math.ceil(Math.abs(tt.lng) / 360)), qe + tt.lng >= 270 && (tt.lng -= 360 * Math.ceil(Math.abs(tt.lng) / 360)), tt;
    }
    function gn(y, E) {
      var O = rn(y.map(function(Y) {
        return Y.toGeoJSON();
      }), E);
      y.forEach(function(Y) {
        var ne, fe = Y.getCoordinates(), _e = function(tt) {
          var dt = { lng: tt[0] + O.lng, lat: tt[1] + O.lat };
          return [dt.lng, dt.lat];
        }, qe = function(tt) {
          return tt.map(function(dt) {
            return _e(dt);
          });
        };
        Y.type === Ke.POINT ? ne = _e(fe) : Y.type === Ke.LINE_STRING || Y.type === Ke.MULTI_POINT ? ne = fe.map(_e) : Y.type === Ke.POLYGON || Y.type === Ke.MULTI_LINE_STRING ? ne = fe.map(qe) : Y.type === Ke.MULTI_POLYGON && (ne = fe.map(function(tt) {
          return tt.map(function(dt) {
            return qe(dt);
          });
        })), Y.incomingCoords(ne);
      });
    }
    var Yi = { onSetup: function(y) {
      var E = this, O = { dragMoveLocation: null, boxSelectStartLocation: null, boxSelectElement: void 0, boxSelecting: !1, canBoxSelect: !1, dragMoving: !1, canDragMove: !1, initiallySelectedFeatureIds: y.featureIds || [] };
      return this.setSelected(O.initiallySelectedFeatureIds.filter(function(Y) {
        return E.getFeature(Y) !== void 0;
      })), this.fireActionable(), this.setActionableState({ combineFeatures: !0, uncombineFeatures: !0, trash: !0 }), O;
    }, fireUpdate: function() {
      this.map.fire(kt.UPDATE, { action: Qt.MOVE, features: this.getSelected().map(function(y) {
        return y.toGeoJSON();
      }) });
    }, fireActionable: function() {
      var y = this, E = this.getSelected(), O = E.filter(function(qe) {
        return y.isInstanceOf("MultiFeature", qe);
      }), Y = !1;
      if (E.length > 1) {
        Y = !0;
        var ne = E[0].type.replace("Multi", "");
        E.forEach(function(qe) {
          qe.type.replace("Multi", "") !== ne && (Y = !1);
        });
      }
      var fe = O.length > 0, _e = E.length > 0;
      this.setActionableState({ combineFeatures: Y, uncombineFeatures: fe, trash: _e });
    }, getUniqueIds: function(y) {
      return y.length ? y.map(function(E) {
        return E.properties.id;
      }).filter(function(E) {
        return E !== void 0;
      }).reduce(function(E, O) {
        return E.add(O), E;
      }, new Pt()).values() : [];
    }, stopExtendedInteractions: function(y) {
      y.boxSelectElement && (y.boxSelectElement.parentNode && y.boxSelectElement.parentNode.removeChild(y.boxSelectElement), y.boxSelectElement = null), this.map.dragPan.enable(), y.boxSelecting = !1, y.canBoxSelect = !1, y.dragMoving = !1, y.canDragMove = !1;
    }, onStop: function() {
      H.enable(this);
    }, onMouseMove: function(y, E) {
      return Po(E) && y.dragMoving && this.fireUpdate(), this.stopExtendedInteractions(y), !0;
    }, onMouseOut: function(y) {
      return !y.dragMoving || this.fireUpdate();
    } };
    Yi.onTap = Yi.onClick = function(y, E) {
      return mn(E) ? this.clickAnywhere(y, E) : Gn(St.VERTEX)(E) ? this.clickOnVertex(y, E) : Po(E) ? this.clickOnFeature(y, E) : void 0;
    }, Yi.clickAnywhere = function(y) {
      var E = this, O = this.getSelectedIds();
      O.length && (this.clearSelectedFeatures(), O.forEach(function(Y) {
        return E.doRender(Y);
      })), H.enable(this), this.stopExtendedInteractions(y);
    }, Yi.clickOnVertex = function(y, E) {
      this.changeMode(mt.DIRECT_SELECT, { featureId: E.featureTarget.properties.parent, coordPath: E.featureTarget.properties.coord_path, startPos: E.lngLat }), this.updateUIClasses({ mouse: ut.MOVE });
    }, Yi.startOnActiveFeature = function(y, E) {
      this.stopExtendedInteractions(y), this.map.dragPan.disable(), this.doRender(E.featureTarget.properties.id), y.canDragMove = !0, y.dragMoveLocation = E.lngLat;
    }, Yi.clickOnFeature = function(y, E) {
      var O = this;
      H.disable(this), this.stopExtendedInteractions(y);
      var Y = $n(E), ne = this.getSelectedIds(), fe = E.featureTarget.properties.id, _e = this.isSelected(fe);
      if (!Y && _e && this.getFeature(fe).type !== Ke.POINT) return this.changeMode(mt.DIRECT_SELECT, { featureId: fe });
      _e && Y ? (this.deselect(fe), this.updateUIClasses({ mouse: ut.POINTER }), ne.length === 1 && H.enable(this)) : !_e && Y ? (this.select(fe), this.updateUIClasses({ mouse: ut.MOVE })) : _e || Y || (ne.forEach(function(qe) {
        return O.doRender(qe);
      }), this.setSelected(fe), this.updateUIClasses({ mouse: ut.MOVE })), this.doRender(fe);
    }, Yi.onMouseDown = function(y, E) {
      return Cn(E) ? this.startOnActiveFeature(y, E) : this.drawConfig.boxSelect && Es(E) ? this.startBoxSelect(y, E) : void 0;
    }, Yi.startBoxSelect = function(y, E) {
      this.stopExtendedInteractions(y), this.map.dragPan.disable(), y.boxSelectStartLocation = ts(E.originalEvent, this.map.getContainer()), y.canBoxSelect = !0;
    }, Yi.onTouchStart = function(y, E) {
      if (Cn(E)) return this.startOnActiveFeature(y, E);
    }, Yi.onDrag = function(y, E) {
      return y.canDragMove ? this.dragMove(y, E) : this.drawConfig.boxSelect && y.canBoxSelect ? this.whileBoxSelect(y, E) : void 0;
    }, Yi.whileBoxSelect = function(y, E) {
      y.boxSelecting = !0, this.updateUIClasses({ mouse: ut.ADD }), y.boxSelectElement || (y.boxSelectElement = document.createElement("div"), y.boxSelectElement.classList.add(Ie.BOX_SELECT), this.map.getContainer().appendChild(y.boxSelectElement));
      var O = ts(E.originalEvent, this.map.getContainer()), Y = Math.min(y.boxSelectStartLocation.x, O.x), ne = Math.max(y.boxSelectStartLocation.x, O.x), fe = Math.min(y.boxSelectStartLocation.y, O.y), _e = Math.max(y.boxSelectStartLocation.y, O.y), qe = "translate(" + Y + "px, " + fe + "px)";
      y.boxSelectElement.style.transform = qe, y.boxSelectElement.style.WebkitTransform = qe, y.boxSelectElement.style.width = ne - Y + "px", y.boxSelectElement.style.height = _e - fe + "px";
    }, Yi.dragMove = function(y, E) {
      y.dragMoving = !0, E.originalEvent.stopPropagation();
      var O = { lng: E.lngLat.lng - y.dragMoveLocation.lng, lat: E.lngLat.lat - y.dragMoveLocation.lat };
      gn(this.getSelected(), O), y.dragMoveLocation = E.lngLat;
    }, Yi.onTouchEnd = Yi.onMouseUp = function(y, E) {
      var O = this;
      if (y.dragMoving) this.fireUpdate();
      else if (y.boxSelecting) {
        var Y = [y.boxSelectStartLocation, ts(E.originalEvent, this.map.getContainer())], ne = this.featuresAt(null, Y, "click"), fe = this.getUniqueIds(ne).filter(function(_e) {
          return !O.isSelected(_e);
        });
        fe.length && (this.select(fe), fe.forEach(function(_e) {
          return O.doRender(_e);
        }), this.updateUIClasses({ mouse: ut.MOVE }));
      }
      this.stopExtendedInteractions(y);
    }, Yi.toDisplayFeatures = function(y, E, O) {
      E.properties.active = this.isSelected(E.properties.id) ? It.ACTIVE : It.INACTIVE, O(E), this.fireActionable(), E.properties.active === It.ACTIVE && E.geometry.type !== Ke.POINT && R(E).forEach(O);
    }, Yi.onTrash = function() {
      this.deleteFeature(this.getSelectedIds()), this.fireActionable();
    }, Yi.onCombineFeatures = function() {
      var y = this.getSelected();
      if (!(y.length === 0 || y.length < 2)) {
        for (var E = [], O = [], Y = y[0].type.replace("Multi", ""), ne = 0; ne < y.length; ne++) {
          var fe = y[ne];
          if (fe.type.replace("Multi", "") !== Y) return;
          fe.type.includes("Multi") ? fe.getCoordinates().forEach(function(qe) {
            E.push(qe);
          }) : E.push(fe.getCoordinates()), O.push(fe.toGeoJSON());
        }
        if (O.length > 1) {
          var _e = this.newFeature({ type: Ke.FEATURE, properties: O[0].properties, geometry: { type: "Multi" + Y, coordinates: E } });
          this.addFeature(_e), this.deleteFeature(this.getSelectedIds(), { silent: !0 }), this.setSelected([_e.id]), this.map.fire(kt.COMBINE_FEATURES, { createdFeatures: [_e.toGeoJSON()], deletedFeatures: O });
        }
        this.fireActionable();
      }
    }, Yi.onUncombineFeatures = function() {
      var y = this, E = this.getSelected();
      if (E.length !== 0) {
        for (var O = [], Y = [], ne = function(_e) {
          var qe = E[_e];
          y.isInstanceOf("MultiFeature", qe) && (qe.getFeatures().forEach(function(tt) {
            y.addFeature(tt), tt.properties = qe.properties, O.push(tt.toGeoJSON()), y.select([tt.id]);
          }), y.deleteFeature(qe.id, { silent: !0 }), Y.push(qe.toGeoJSON()));
        }, fe = 0; fe < E.length; fe++) ne(fe);
        O.length > 1 && this.map.fire(kt.UNCOMBINE_FEATURES, { createdFeatures: O, deletedFeatures: Y }), this.fireActionable();
      }
    };
    var Ks = Gn(St.VERTEX), uo = Gn(St.MIDPOINT), wr = { fireUpdate: function() {
      this.map.fire(kt.UPDATE, { action: Qt.CHANGE_COORDINATES, features: this.getSelected().map(function(y) {
        return y.toGeoJSON();
      }) });
    }, fireActionable: function(y) {
      this.setActionableState({ combineFeatures: !1, uncombineFeatures: !1, trash: y.selectedCoordPaths.length > 0 });
    }, startDragging: function(y, E) {
      this.map.dragPan.disable(), y.canDragMove = !0, y.dragMoveLocation = E.lngLat;
    }, stopDragging: function(y) {
      this.map.dragPan.enable(), y.dragMoving = !1, y.canDragMove = !1, y.dragMoveLocation = null;
    }, onVertex: function(y, E) {
      this.startDragging(y, E);
      var O = E.featureTarget.properties, Y = y.selectedCoordPaths.indexOf(O.coord_path);
      $n(E) || Y !== -1 ? $n(E) && Y === -1 && y.selectedCoordPaths.push(O.coord_path) : y.selectedCoordPaths = [O.coord_path];
      var ne = this.pathsToCoordinates(y.featureId, y.selectedCoordPaths);
      this.setSelectedCoordinates(ne);
    }, onMidpoint: function(y, E) {
      this.startDragging(y, E);
      var O = E.featureTarget.properties;
      y.feature.addCoordinate(O.coord_path, O.lng, O.lat), this.fireUpdate(), y.selectedCoordPaths = [O.coord_path];
    }, pathsToCoordinates: function(y, E) {
      return E.map(function(O) {
        return { feature_id: y, coord_path: O };
      });
    }, onFeature: function(y, E) {
      y.selectedCoordPaths.length === 0 ? this.startDragging(y, E) : this.stopDragging(y);
    }, dragFeature: function(y, E, O) {
      gn(this.getSelected(), O), y.dragMoveLocation = E.lngLat;
    }, dragVertex: function(y, E, O) {
      for (var Y = y.selectedCoordPaths.map(function(qe) {
        return y.feature.getCoordinate(qe);
      }), ne = rn(Y.map(function(qe) {
        return { type: Ke.FEATURE, properties: {}, geometry: { type: Ke.POINT, coordinates: qe } };
      }), O), fe = 0; fe < Y.length; fe++) {
        var _e = Y[fe];
        y.feature.updateCoordinate(y.selectedCoordPaths[fe], _e[0] + ne.lng, _e[1] + ne.lat);
      }
    }, clickNoTarget: function() {
      this.changeMode(mt.SIMPLE_SELECT);
    }, clickInactive: function() {
      this.changeMode(mt.SIMPLE_SELECT);
    }, clickActiveFeature: function(y) {
      y.selectedCoordPaths = [], this.clearSelectedCoordinates(), y.feature.changed();
    }, onSetup: function(y) {
      var E = y.featureId, O = this.getFeature(E);
      if (!O) throw new Error("You must provide a featureId to enter direct_select mode");
      if (O.type === Ke.POINT) throw new TypeError("direct_select mode doesn't handle point features");
      var Y = { featureId: E, feature: O, dragMoveLocation: y.startPos || null, dragMoving: !1, canDragMove: !1, selectedCoordPaths: y.coordPath ? [y.coordPath] : [] };
      return this.setSelectedCoordinates(this.pathsToCoordinates(E, Y.selectedCoordPaths)), this.setSelected(E), H.disable(this), this.setActionableState({ trash: !0 }), Y;
    }, onStop: function() {
      H.enable(this), this.clearSelectedCoordinates();
    }, toDisplayFeatures: function(y, E, O) {
      y.featureId === E.properties.id ? (E.properties.active = It.ACTIVE, O(E), R(E, { map: this.map, midpoints: !0, selectedPaths: y.selectedCoordPaths }).forEach(O)) : (E.properties.active = It.INACTIVE, O(E)), this.fireActionable(y);
    }, onTrash: function(y) {
      y.selectedCoordPaths.sort(function(E, O) {
        return O.localeCompare(E, "en", { numeric: !0 });
      }).forEach(function(E) {
        return y.feature.removeCoordinate(E);
      }), this.fireUpdate(), y.selectedCoordPaths = [], this.clearSelectedCoordinates(), this.fireActionable(y), y.feature.isValid() === !1 && (this.deleteFeature([y.featureId]), this.changeMode(mt.SIMPLE_SELECT, {}));
    }, onMouseMove: function(y, E) {
      var O = Cn(E), Y = Ks(E), ne = uo(E), fe = y.selectedCoordPaths.length === 0;
      return O && fe || Y && !fe ? this.updateUIClasses({ mouse: ut.MOVE }) : this.updateUIClasses({ mouse: ut.NONE }), (Y || O || ne) && y.dragMoving && this.fireUpdate(), this.stopDragging(y), !0;
    }, onMouseOut: function(y) {
      return y.dragMoving && this.fireUpdate(), !0;
    } };
    wr.onTouchStart = wr.onMouseDown = function(y, E) {
      return Ks(E) ? this.onVertex(y, E) : Cn(E) ? this.onFeature(y, E) : uo(E) ? this.onMidpoint(y, E) : void 0;
    }, wr.onDrag = function(y, E) {
      if (y.canDragMove === !0) {
        y.dragMoving = !0, E.originalEvent.stopPropagation();
        var O = { lng: E.lngLat.lng - y.dragMoveLocation.lng, lat: E.lngLat.lat - y.dragMoveLocation.lat };
        y.selectedCoordPaths.length > 0 ? this.dragVertex(y, E, O) : this.dragFeature(y, E, O), y.dragMoveLocation = E.lngLat;
      }
    }, wr.onClick = function(y, E) {
      return mn(E) ? this.clickNoTarget(y, E) : Cn(E) ? this.clickActiveFeature(y, E) : Br(E) ? this.clickInactive(y, E) : void this.stopDragging(y);
    }, wr.onTap = function(y, E) {
      return mn(E) ? this.clickNoTarget(y, E) : Cn(E) ? this.clickActiveFeature(y, E) : Br(E) ? this.clickInactive(y, E) : void 0;
    }, wr.onTouchEnd = wr.onMouseUp = function(y) {
      y.dragMoving && this.fireUpdate(), this.stopDragging(y);
    };
    var Fr = {};
    function Pe(y, E) {
      return !!y.lngLat && y.lngLat.lng === E[0] && y.lngLat.lat === E[1];
    }
    Fr.onSetup = function() {
      var y = this.newFeature({ type: Ke.FEATURE, properties: {}, geometry: { type: Ke.POINT, coordinates: [] } });
      return this.addFeature(y), this.clearSelectedFeatures(), this.updateUIClasses({ mouse: ut.ADD }), this.activateUIButton(lt.POINT), this.setActionableState({ trash: !0 }), { point: y };
    }, Fr.stopDrawingAndRemove = function(y) {
      this.deleteFeature([y.point.id], { silent: !0 }), this.changeMode(mt.SIMPLE_SELECT);
    }, Fr.onTap = Fr.onClick = function(y, E) {
      this.updateUIClasses({ mouse: ut.MOVE }), y.point.updateCoordinate("", E.lngLat.lng, E.lngLat.lat), this.map.fire(kt.CREATE, { features: [y.point.toGeoJSON()] }), this.changeMode(mt.SIMPLE_SELECT, { featureIds: [y.point.id] });
    }, Fr.onStop = function(y) {
      this.activateUIButton(), y.point.getCoordinate().length || this.deleteFeature([y.point.id], { silent: !0 });
    }, Fr.toDisplayFeatures = function(y, E, O) {
      var Y = E.properties.id === y.point.id;
      if (E.properties.active = Y ? It.ACTIVE : It.INACTIVE, !Y) return O(E);
    }, Fr.onTrash = Fr.stopDrawingAndRemove, Fr.onKeyUp = function(y, E) {
      if (lo(E) || An(E)) return this.stopDrawingAndRemove(y, E);
    };
    var Cr = { onSetup: function() {
      var y = this.newFeature({ type: Ke.FEATURE, properties: {}, geometry: { type: Ke.POLYGON, coordinates: [[]] } });
      return this.addFeature(y), this.clearSelectedFeatures(), H.disable(this), this.updateUIClasses({ mouse: ut.ADD }), this.activateUIButton(lt.POLYGON), this.setActionableState({ trash: !0 }), { polygon: y, currentVertexPosition: 0 };
    }, clickAnywhere: function(y, E) {
      if (y.currentVertexPosition > 0 && Pe(E, y.polygon.coordinates[0][y.currentVertexPosition - 1])) return this.changeMode(mt.SIMPLE_SELECT, { featureIds: [y.polygon.id] });
      this.updateUIClasses({ mouse: ut.ADD }), y.polygon.updateCoordinate("0." + y.currentVertexPosition, E.lngLat.lng, E.lngLat.lat), y.currentVertexPosition++, y.polygon.updateCoordinate("0." + y.currentVertexPosition, E.lngLat.lng, E.lngLat.lat);
    }, clickOnVertex: function(y) {
      return this.changeMode(mt.SIMPLE_SELECT, { featureIds: [y.polygon.id] });
    }, onMouseMove: function(y, E) {
      y.polygon.updateCoordinate("0." + y.currentVertexPosition, E.lngLat.lng, E.lngLat.lat), _n(E) && this.updateUIClasses({ mouse: ut.POINTER });
    } };
    Cr.onTap = Cr.onClick = function(y, E) {
      return _n(E) ? this.clickOnVertex(y, E) : this.clickAnywhere(y, E);
    }, Cr.onKeyUp = function(y, E) {
      lo(E) ? (this.deleteFeature([y.polygon.id], { silent: !0 }), this.changeMode(mt.SIMPLE_SELECT)) : An(E) && this.changeMode(mt.SIMPLE_SELECT, { featureIds: [y.polygon.id] });
    }, Cr.onStop = function(y) {
      this.updateUIClasses({ mouse: ut.NONE }), H.enable(this), this.activateUIButton(), this.getFeature(y.polygon.id) !== void 0 && (y.polygon.removeCoordinate("0." + y.currentVertexPosition), y.polygon.isValid() ? this.map.fire(kt.CREATE, { features: [y.polygon.toGeoJSON()] }) : (this.deleteFeature([y.polygon.id], { silent: !0 }), this.changeMode(mt.SIMPLE_SELECT, {}, { silent: !0 })));
    }, Cr.toDisplayFeatures = function(y, E, O) {
      var Y = E.properties.id === y.polygon.id;
      if (E.properties.active = Y ? It.ACTIVE : It.INACTIVE, !Y) return O(E);
      if (E.geometry.coordinates.length !== 0) {
        var ne = E.geometry.coordinates[0].length;
        if (!(ne < 3)) {
          if (E.properties.meta = St.FEATURE, O(Q(y.polygon.id, E.geometry.coordinates[0][0], "0.0", !1)), ne > 3) {
            var fe = E.geometry.coordinates[0].length - 3;
            O(Q(y.polygon.id, E.geometry.coordinates[0][fe], "0." + fe, !1));
          }
          if (ne <= 4) {
            var _e = [[E.geometry.coordinates[0][0][0], E.geometry.coordinates[0][0][1]], [E.geometry.coordinates[0][1][0], E.geometry.coordinates[0][1][1]]];
            if (O({ type: Ke.FEATURE, properties: E.properties, geometry: { coordinates: _e, type: Ke.LINE_STRING } }), ne === 3) return;
          }
          return O(E);
        }
      }
    }, Cr.onTrash = function(y) {
      this.deleteFeature([y.polygon.id], { silent: !0 }), this.changeMode(mt.SIMPLE_SELECT);
    };
    var Li = { onSetup: function(y) {
      var E, O, Y = (y = y || {}).featureId, ne = "forward";
      if (Y) {
        if (!(E = this.getFeature(Y))) throw new Error("Could not find a feature with the provided featureId");
        var fe = y.from;
        if (fe && fe.type === "Feature" && fe.geometry && fe.geometry.type === "Point" && (fe = fe.geometry), fe && fe.type === "Point" && fe.coordinates && fe.coordinates.length === 2 && (fe = fe.coordinates), !fe || !Array.isArray(fe)) throw new Error("Please use the `from` property to indicate which point to continue the line from");
        var _e = E.coordinates.length - 1;
        if (E.coordinates[_e][0] === fe[0] && E.coordinates[_e][1] === fe[1]) O = _e + 1, E.addCoordinate.apply(E, [O].concat(E.coordinates[_e]));
        else {
          if (E.coordinates[0][0] !== fe[0] || E.coordinates[0][1] !== fe[1]) throw new Error("`from` should match the point at either the start or the end of the provided LineString");
          ne = "backwards", O = 0, E.addCoordinate.apply(E, [O].concat(E.coordinates[0]));
        }
      } else E = this.newFeature({ type: Ke.FEATURE, properties: {}, geometry: { type: Ke.LINE_STRING, coordinates: [] } }), O = 0, this.addFeature(E);
      return this.clearSelectedFeatures(), H.disable(this), this.updateUIClasses({ mouse: ut.ADD }), this.activateUIButton(lt.LINE), this.setActionableState({ trash: !0 }), { line: E, currentVertexPosition: O, direction: ne };
    }, clickAnywhere: function(y, E) {
      if (y.currentVertexPosition > 0 && Pe(E, y.line.coordinates[y.currentVertexPosition - 1]) || y.direction === "backwards" && Pe(E, y.line.coordinates[y.currentVertexPosition + 1])) return this.changeMode(mt.SIMPLE_SELECT, { featureIds: [y.line.id] });
      this.updateUIClasses({ mouse: ut.ADD }), y.line.updateCoordinate(y.currentVertexPosition, E.lngLat.lng, E.lngLat.lat), y.direction === "forward" ? (y.currentVertexPosition++, y.line.updateCoordinate(y.currentVertexPosition, E.lngLat.lng, E.lngLat.lat)) : y.line.addCoordinate(0, E.lngLat.lng, E.lngLat.lat);
    }, clickOnVertex: function(y) {
      return this.changeMode(mt.SIMPLE_SELECT, { featureIds: [y.line.id] });
    }, onMouseMove: function(y, E) {
      y.line.updateCoordinate(y.currentVertexPosition, E.lngLat.lng, E.lngLat.lat), _n(E) && this.updateUIClasses({ mouse: ut.POINTER });
    } };
    Li.onTap = Li.onClick = function(y, E) {
      if (_n(E)) return this.clickOnVertex(y, E);
      this.clickAnywhere(y, E);
    }, Li.onKeyUp = function(y, E) {
      An(E) ? this.changeMode(mt.SIMPLE_SELECT, { featureIds: [y.line.id] }) : lo(E) && (this.deleteFeature([y.line.id], { silent: !0 }), this.changeMode(mt.SIMPLE_SELECT));
    }, Li.onStop = function(y) {
      H.enable(this), this.activateUIButton(), this.getFeature(y.line.id) !== void 0 && (y.line.removeCoordinate("" + y.currentVertexPosition), y.line.isValid() ? this.map.fire(kt.CREATE, { features: [y.line.toGeoJSON()] }) : (this.deleteFeature([y.line.id], { silent: !0 }), this.changeMode(mt.SIMPLE_SELECT, {}, { silent: !0 })));
    }, Li.onTrash = function(y) {
      this.deleteFeature([y.line.id], { silent: !0 }), this.changeMode(mt.SIMPLE_SELECT);
    }, Li.toDisplayFeatures = function(y, E, O) {
      var Y = E.properties.id === y.line.id;
      if (E.properties.active = Y ? It.ACTIVE : It.INACTIVE, !Y) return O(E);
      E.geometry.coordinates.length < 2 || (E.properties.meta = St.FEATURE, O(Q(y.line.id, E.geometry.coordinates[y.direction === "forward" ? E.geometry.coordinates.length - 2 : 1], "" + (y.direction === "forward" ? E.geometry.coordinates.length - 2 : 1), !1)), O(E));
    };
    var lr = { simple_select: Yi, direct_select: wr, draw_point: Fr, draw_polygon: Cr, draw_line_string: Li }, xl = { defaultMode: mt.SIMPLE_SELECT, keybindings: !0, touchEnabled: !0, clickBuffer: 2, touchBuffer: 25, boxSelect: !0, displayControlsDefault: !0, styles: Vn, modes: lr, controls: {}, userProperties: !1 }, Pn = { point: !0, line_string: !0, polygon: !0, trash: !0, combine_features: !0, uncombine_features: !0 }, Aa = { point: !1, line_string: !1, polygon: !1, trash: !1, combine_features: !1, uncombine_features: !1 };
    function Ia(y, E) {
      return y.map(function(O) {
        return O.source ? O : en(O, { id: O.id + "." + E, source: E === "hot" ? rt.HOT : rt.COLD });
      });
    }
    var ho = { exports: {} };
    (function(y, E) {
      var O = "__lodash_hash_undefined__", Y = 9007199254740991, ne = "[object Arguments]", fe = "[object Array]", _e = "[object Boolean]", qe = "[object Date]", tt = "[object Error]", dt = "[object Function]", ft = "[object Map]", nt = "[object Number]", zt = "[object Object]", Oi = "[object Promise]", Ot = "[object RegExp]", pi = "[object Set]", De = "[object String]", bt = "[object Symbol]", gi = "[object WeakMap]", yi = "[object ArrayBuffer]", xi = "[object DataView]", Js = /^\[object .+?Constructor\]$/, Ss = /^(?:0|[1-9]\d*)$/, Ft = {};
      Ft["[object Float32Array]"] = Ft["[object Float64Array]"] = Ft["[object Int8Array]"] = Ft["[object Int16Array]"] = Ft["[object Int32Array]"] = Ft["[object Uint8Array]"] = Ft["[object Uint8ClampedArray]"] = Ft["[object Uint16Array]"] = Ft["[object Uint32Array]"] = !0, Ft[ne] = Ft[fe] = Ft[yi] = Ft[_e] = Ft[xi] = Ft[qe] = Ft[tt] = Ft[dt] = Ft[ft] = Ft[nt] = Ft[zt] = Ft[Ot] = Ft[pi] = Ft[De] = Ft[gi] = !1;
      var rs = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis, Pa = typeof self == "object" && self && self.Object === Object && self, Ar = rs || Pa || Function("return this")(), yr = E && !E.nodeType && E, Ys = yr && y && !y.nodeType && y, Qs = Ys && Ys.exports === yr, xn = Qs && rs.process, Zn = function() {
        try {
          return xn && xn.binding && xn.binding("util");
        } catch {
        }
      }(), Ms = Zn && Zn.isTypedArray;
      function dc(ye, ze) {
        for (var ht = -1, Mt = ye == null ? 0 : ye.length; ++ht < Mt; ) if (ze(ye[ht], ht, ye)) return !0;
        return !1;
      }
      function La(ye) {
        var ze = -1, ht = Array(ye.size);
        return ye.forEach(function(Mt, Ni) {
          ht[++ze] = [Ni, Mt];
        }), ht;
      }
      function ns(ye) {
        var ze = -1, ht = Array(ye.size);
        return ye.forEach(function(Mt) {
          ht[++ze] = Mt;
        }), ht;
      }
      var vn, ea, po, qn = Array.prototype, Cs = Function.prototype, nn = Object.prototype, os = Ar["__core-js_shared__"], Do = Cs.toString, Ur = nn.hasOwnProperty, za = (vn = /[^.]+$/.exec(os && os.keys && os.keys.IE_PROTO || "")) ? "Symbol(src)_1." + vn : "", As = nn.toString, ka = RegExp("^" + Do.call(Ur).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), ta = Qs ? Ar.Buffer : void 0, Wn = Ar.Symbol, li = Ar.Uint8Array, vl = nn.propertyIsEnumerable, Da = qn.splice, fo = Wn ? Wn.toStringTag : void 0, ia = Object.getOwnPropertySymbols, bl = ta ? ta.isBuffer : void 0, Ra = (ea = Object.keys, po = Object, function(ye) {
        return ea(po(ye));
      }), mo = Oo(Ar, "DataView"), _o = Oo(Ar, "Map"), go = Oo(Ar, "Promise"), bn = Oo(Ar, "Set"), Xn = Oo(Ar, "WeakMap"), yo = Oo(Object, "create"), wl = Kn(mo), Is = Kn(_o), Oa = Kn(go), Ba = Kn(bn), ra = Kn(Xn), Ps = Wn ? Wn.prototype : void 0, Ls = Ps ? Ps.valueOf : void 0;
      function Kt(ye) {
        var ze = -1, ht = ye == null ? 0 : ye.length;
        for (this.clear(); ++ze < ht; ) {
          var Mt = ye[ze];
          this.set(Mt[0], Mt[1]);
        }
      }
      function Hr(ye) {
        var ze = -1, ht = ye == null ? 0 : ye.length;
        for (this.clear(); ++ze < ht; ) {
          var Mt = ye[ze];
          this.set(Mt[0], Mt[1]);
        }
      }
      function xo(ye) {
        var ze = -1, ht = ye == null ? 0 : ye.length;
        for (this.clear(); ++ze < ht; ) {
          var Mt = ye[ze];
          this.set(Mt[0], Mt[1]);
        }
      }
      function ss(ye) {
        var ze = -1, ht = ye == null ? 0 : ye.length;
        for (this.__data__ = new xo(); ++ze < ht; ) this.add(ye[ze]);
      }
      function Hn(ye) {
        var ze = this.__data__ = new Hr(ye);
        this.size = ze.size;
      }
      function Ro(ye, ze) {
        var ht = Kr(ye), Mt = !ht && Na(ye), Ni = !ht && !Mt && us(ye), ri = !ht && !Mt && !Ni && Sl(ye), Wi = ht || Mt || Ni || ri, Vi = Wi ? function(ir, Ir) {
          for (var Jn = -1, Pr = Array(ir); ++Jn < ir; ) Pr[Jn] = Ir(Jn);
          return Pr;
        }(ye.length, String) : [], sn = Vi.length;
        for (var Ki in ye) !Ur.call(ye, Ki) || Wi && (Ki == "length" || Ni && (Ki == "offset" || Ki == "parent") || ri && (Ki == "buffer" || Ki == "byteLength" || Ki == "byteOffset") || ls(Ki, sn)) || Vi.push(Ki);
        return Vi;
      }
      function as(ye, ze) {
        for (var ht = ye.length; ht--; ) if (cs(ye[ht][0], ze)) return ht;
        return -1;
      }
      function zs(ye) {
        return ye == null ? ye === void 0 ? "[object Undefined]" : "[object Null]" : fo && fo in Object(ye) ? function(ze) {
          var ht = Ur.call(ze, fo), Mt = ze[fo];
          try {
            ze[fo] = void 0;
            var Ni = !0;
          } catch {
          }
          var ri = As.call(ze);
          return Ni && (ht ? ze[fo] = Mt : delete ze[fo]), ri;
        }(ye) : function(ze) {
          return As.call(ze);
        }(ye);
      }
      function Tl(ye) {
        return Bo(ye) && zs(ye) == ne;
      }
      function El(ye, ze, ht, Mt, Ni) {
        return ye === ze || (ye == null || ze == null || !Bo(ye) && !Bo(ze) ? ye != ye && ze != ze : function(ri, Wi, Vi, sn, Ki, ir) {
          var Ir = Kr(ri), Jn = Kr(Wi), Pr = Ir ? fe : on(ri), Yn = Jn ? fe : on(Wi), hs = (Pr = Pr == ne ? zt : Pr) == zt, sa = (Yn = Yn == ne ? zt : Yn) == zt, Fo = Pr == Yn;
          if (Fo && us(ri)) {
            if (!us(Wi)) return !1;
            Ir = !0, hs = !1;
          }
          if (Fo && !hs) return ir || (ir = new Hn()), Ir || Sl(ri) ? na(ri, Wi, Vi, sn, Ki, ir) : function(ci, _i, Lr, an, aa, xr, Nr) {
            switch (Lr) {
              case xi:
                if (ci.byteLength != _i.byteLength || ci.byteOffset != _i.byteOffset) return !1;
                ci = ci.buffer, _i = _i.buffer;
              case yi:
                return !(ci.byteLength != _i.byteLength || !xr(new li(ci), new li(_i)));
              case _e:
              case qe:
              case nt:
                return cs(+ci, +_i);
              case tt:
                return ci.name == _i.name && ci.message == _i.message;
              case Ot:
              case De:
                return ci == _i + "";
              case ft:
                var wn = La;
              case pi:
                var bo = 1 & an;
                if (wn || (wn = ns), ci.size != _i.size && !bo) return !1;
                var ii = Nr.get(ci);
                if (ii) return ii == _i;
                an |= 2, Nr.set(ci, _i);
                var Ln = na(wn(ci), wn(_i), an, aa, xr, Nr);
                return Nr.delete(ci), Ln;
              case bt:
                if (Ls) return Ls.call(ci) == Ls.call(_i);
            }
            return !1;
          }(ri, Wi, Pr, Vi, sn, Ki, ir);
          if (!(1 & Vi)) {
            var vo = hs && Ur.call(ri, "__wrapped__"), Uo = sa && Ur.call(Wi, "__wrapped__");
            if (vo || Uo) {
              var Ml = vo ? ri.value() : ri, Cl = Uo ? Wi.value() : Wi;
              return ir || (ir = new Hn()), Ki(Ml, Cl, Vi, sn, ir);
            }
          }
          return Fo ? (ir || (ir = new Hn()), function(ci, _i, Lr, an, aa, xr) {
            var Nr = 1 & Lr, wn = ks(ci), bo = wn.length, ii = ks(_i).length;
            if (bo != ii && !Nr) return !1;
            for (var Ln = bo; Ln--; ) {
              var wo = wn[Ln];
              if (!(Nr ? wo in _i : Ur.call(_i, wo))) return !1;
            }
            var Os = xr.get(ci);
            if (Os && xr.get(_i)) return Os == _i;
            var Qn = !0;
            xr.set(ci, _i), xr.set(_i, ci);
            for (var la = Nr; ++Ln < bo; ) {
              var No = ci[wo = wn[Ln]], ln = _i[wo];
              if (an) var Ga = Nr ? an(ln, No, wo, _i, ci, xr) : an(No, ln, wo, ci, _i, xr);
              if (!(Ga === void 0 ? No === ln || aa(No, ln, Lr, an, xr) : Ga)) {
                Qn = !1;
                break;
              }
              la || (la = wo == "constructor");
            }
            if (Qn && !la) {
              var jo = ci.constructor, eo = _i.constructor;
              jo == eo || !("constructor" in ci) || !("constructor" in _i) || typeof jo == "function" && jo instanceof jo && typeof eo == "function" && eo instanceof eo || (Qn = !1);
            }
            return xr.delete(ci), xr.delete(_i), Qn;
          }(ri, Wi, Vi, sn, Ki, ir)) : !1;
        }(ye, ze, ht, Mt, El, Ni));
      }
      function Fa(ye) {
        return !(!ja(ye) || function(ze) {
          return !!za && za in ze;
        }(ye)) && (oa(ye) ? ka : Js).test(Kn(ye));
      }
      function Ua(ye) {
        if (ht = (ze = ye) && ze.constructor, Mt = typeof ht == "function" && ht.prototype || nn, ze !== Mt) return Ra(ye);
        var ze, ht, Mt, Ni = [];
        for (var ri in Object(ye)) Ur.call(ye, ri) && ri != "constructor" && Ni.push(ri);
        return Ni;
      }
      function na(ye, ze, ht, Mt, Ni, ri) {
        var Wi = 1 & ht, Vi = ye.length, sn = ze.length;
        if (Vi != sn && !(Wi && sn > Vi)) return !1;
        var Ki = ri.get(ye);
        if (Ki && ri.get(ze)) return Ki == ze;
        var ir = -1, Ir = !0, Jn = 2 & ht ? new ss() : void 0;
        for (ri.set(ye, ze), ri.set(ze, ye); ++ir < Vi; ) {
          var Pr = ye[ir], Yn = ze[ir];
          if (Mt) var hs = Wi ? Mt(Yn, Pr, ir, ze, ye, ri) : Mt(Pr, Yn, ir, ye, ze, ri);
          if (hs !== void 0) {
            if (hs) continue;
            Ir = !1;
            break;
          }
          if (Jn) {
            if (!dc(ze, function(sa, Fo) {
              if (vo = Fo, !Jn.has(vo) && (Pr === sa || Ni(Pr, sa, ht, Mt, ri))) return Jn.push(Fo);
              var vo;
            })) {
              Ir = !1;
              break;
            }
          } else if (Pr !== Yn && !Ni(Pr, Yn, ht, Mt, ri)) {
            Ir = !1;
            break;
          }
        }
        return ri.delete(ye), ri.delete(ze), Ir;
      }
      function ks(ye) {
        return function(ze, ht, Mt) {
          var Ni = ht(ze);
          return Kr(ze) ? Ni : function(ri, Wi) {
            for (var Vi = -1, sn = Wi.length, Ki = ri.length; ++Vi < sn; ) ri[Ki + Vi] = Wi[Vi];
            return ri;
          }(Ni, Mt(ze));
        }(ye, Va, pc);
      }
      function Ds(ye, ze) {
        var ht, Mt, Ni = ye.__data__;
        return ((Mt = typeof (ht = ze)) == "string" || Mt == "number" || Mt == "symbol" || Mt == "boolean" ? ht !== "__proto__" : ht === null) ? Ni[typeof ze == "string" ? "string" : "hash"] : Ni.map;
      }
      function Oo(ye, ze) {
        var ht = function(Mt, Ni) {
          return Mt == null ? void 0 : Mt[Ni];
        }(ye, ze);
        return Fa(ht) ? ht : void 0;
      }
      Kt.prototype.clear = function() {
        this.__data__ = yo ? yo(null) : {}, this.size = 0;
      }, Kt.prototype.delete = function(ye) {
        var ze = this.has(ye) && delete this.__data__[ye];
        return this.size -= ze ? 1 : 0, ze;
      }, Kt.prototype.get = function(ye) {
        var ze = this.__data__;
        if (yo) {
          var ht = ze[ye];
          return ht === O ? void 0 : ht;
        }
        return Ur.call(ze, ye) ? ze[ye] : void 0;
      }, Kt.prototype.has = function(ye) {
        var ze = this.__data__;
        return yo ? ze[ye] !== void 0 : Ur.call(ze, ye);
      }, Kt.prototype.set = function(ye, ze) {
        var ht = this.__data__;
        return this.size += this.has(ye) ? 0 : 1, ht[ye] = yo && ze === void 0 ? O : ze, this;
      }, Hr.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
      }, Hr.prototype.delete = function(ye) {
        var ze = this.__data__, ht = as(ze, ye);
        return !(ht < 0) && (ht == ze.length - 1 ? ze.pop() : Da.call(ze, ht, 1), --this.size, !0);
      }, Hr.prototype.get = function(ye) {
        var ze = this.__data__, ht = as(ze, ye);
        return ht < 0 ? void 0 : ze[ht][1];
      }, Hr.prototype.has = function(ye) {
        return as(this.__data__, ye) > -1;
      }, Hr.prototype.set = function(ye, ze) {
        var ht = this.__data__, Mt = as(ht, ye);
        return Mt < 0 ? (++this.size, ht.push([ye, ze])) : ht[Mt][1] = ze, this;
      }, xo.prototype.clear = function() {
        this.size = 0, this.__data__ = { hash: new Kt(), map: new (_o || Hr)(), string: new Kt() };
      }, xo.prototype.delete = function(ye) {
        var ze = Ds(this, ye).delete(ye);
        return this.size -= ze ? 1 : 0, ze;
      }, xo.prototype.get = function(ye) {
        return Ds(this, ye).get(ye);
      }, xo.prototype.has = function(ye) {
        return Ds(this, ye).has(ye);
      }, xo.prototype.set = function(ye, ze) {
        var ht = Ds(this, ye), Mt = ht.size;
        return ht.set(ye, ze), this.size += ht.size == Mt ? 0 : 1, this;
      }, ss.prototype.add = ss.prototype.push = function(ye) {
        return this.__data__.set(ye, O), this;
      }, ss.prototype.has = function(ye) {
        return this.__data__.has(ye);
      }, Hn.prototype.clear = function() {
        this.__data__ = new Hr(), this.size = 0;
      }, Hn.prototype.delete = function(ye) {
        var ze = this.__data__, ht = ze.delete(ye);
        return this.size = ze.size, ht;
      }, Hn.prototype.get = function(ye) {
        return this.__data__.get(ye);
      }, Hn.prototype.has = function(ye) {
        return this.__data__.has(ye);
      }, Hn.prototype.set = function(ye, ze) {
        var ht = this.__data__;
        if (ht instanceof Hr) {
          var Mt = ht.__data__;
          if (!_o || Mt.length < 199) return Mt.push([ye, ze]), this.size = ++ht.size, this;
          ht = this.__data__ = new xo(Mt);
        }
        return ht.set(ye, ze), this.size = ht.size, this;
      };
      var pc = ia ? function(ye) {
        return ye == null ? [] : (ye = Object(ye), function(ze, ht) {
          for (var Mt = -1, Ni = ze == null ? 0 : ze.length, ri = 0, Wi = []; ++Mt < Ni; ) {
            var Vi = ze[Mt];
            ht(Vi, Mt, ze) && (Wi[ri++] = Vi);
          }
          return Wi;
        }(ia(ye), function(ze) {
          return vl.call(ye, ze);
        }));
      } : function() {
        return [];
      }, on = zs;
      function ls(ye, ze) {
        return !!(ze = ze ?? Y) && (typeof ye == "number" || Ss.test(ye)) && ye > -1 && ye % 1 == 0 && ye < ze;
      }
      function Kn(ye) {
        if (ye != null) {
          try {
            return Do.call(ye);
          } catch {
          }
          try {
            return ye + "";
          } catch {
          }
        }
        return "";
      }
      function cs(ye, ze) {
        return ye === ze || ye != ye && ze != ze;
      }
      (mo && on(new mo(new ArrayBuffer(1))) != xi || _o && on(new _o()) != ft || go && on(go.resolve()) != Oi || bn && on(new bn()) != pi || Xn && on(new Xn()) != gi) && (on = function(ye) {
        var ze = zs(ye), ht = ze == zt ? ye.constructor : void 0, Mt = ht ? Kn(ht) : "";
        if (Mt) switch (Mt) {
          case wl:
            return xi;
          case Is:
            return ft;
          case Oa:
            return Oi;
          case Ba:
            return pi;
          case ra:
            return gi;
        }
        return ze;
      });
      var Na = Tl(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Tl : function(ye) {
        return Bo(ye) && Ur.call(ye, "callee") && !vl.call(ye, "callee");
      }, Kr = Array.isArray, us = bl || function() {
        return !1;
      };
      function oa(ye) {
        if (!ja(ye)) return !1;
        var ze = zs(ye);
        return ze == dt || ze == "[object GeneratorFunction]" || ze == "[object AsyncFunction]" || ze == "[object Proxy]";
      }
      function Rs(ye) {
        return typeof ye == "number" && ye > -1 && ye % 1 == 0 && ye <= Y;
      }
      function ja(ye) {
        var ze = typeof ye;
        return ye != null && (ze == "object" || ze == "function");
      }
      function Bo(ye) {
        return ye != null && typeof ye == "object";
      }
      var Sl = Ms ? /* @__PURE__ */ function(ye) {
        return function(ze) {
          return ye(ze);
        };
      }(Ms) : function(ye) {
        return Bo(ye) && Rs(ye.length) && !!Ft[zs(ye)];
      };
      function Va(ye) {
        return (ze = ye) != null && Rs(ze.length) && !oa(ze) ? Ro(ye) : Ua(ye);
        var ze;
      }
      y.exports = function(ye, ze) {
        return El(ye, ze);
      };
    })(ho, ho.exports);
    var st = V(ho.exports);
    function Jt(y, E) {
      return y.length === E.length && JSON.stringify(y.map(function(O) {
        return O;
      }).sort()) === JSON.stringify(E.map(function(O) {
        return O;
      }).sort());
    }
    var Ht = { Polygon: sr, LineString: Or, Point: Rr, MultiPolygon: tr, MultiLineString: tr, MultiPoint: tr }, Xr = Object.freeze({ __proto__: null, CommonSelectors: co, constrainFeatureMovement: rn, createMidPoint: D, createSupplementaryPoints: R, createVertex: Q, doubleClickZoom: H, euclideanDistance: ao, featuresAt: Zr, getFeatureAtAndSetCursors: br, isClick: Vt, isEventAtCoordinates: Pe, isTap: Sn, mapEventToBoundingBox: or, ModeHandler: B, moveFeatures: gn, sortFeatures: Dr, stringSetsAreEqual: Jt, StringSet: Pt, theme: Vn, toDenseArray: Nn }), yn = function(y, E) {
      var O = { options: y = function(ne) {
        ne === void 0 && (ne = {});
        var fe = en(ne);
        return ne.controls || (fe.controls = {}), ne.displayControlsDefault === !1 ? fe.controls = en(Aa, ne.controls) : fe.controls = en(Pn, ne.controls), (fe = en(xl, fe)).styles = Ia(fe.styles, "cold").concat(Ia(fe.styles, "hot")), fe;
      }(y) };
      E = function(ne, fe) {
        return fe.modes = mt, fe.getFeatureIdsAt = function(_e) {
          return Zr.click({ point: _e }, null, ne).map(function(qe) {
            return qe.properties.id;
          });
        }, fe.getSelectedIds = function() {
          return ne.store.getSelectedIds();
        }, fe.getSelected = function() {
          return { type: Ke.FEATURE_COLLECTION, features: ne.store.getSelectedIds().map(function(_e) {
            return ne.store.get(_e);
          }).map(function(_e) {
            return _e.toGeoJSON();
          }) };
        }, fe.getSelectedPoints = function() {
          return { type: Ke.FEATURE_COLLECTION, features: ne.store.getSelectedCoordinates().map(function(_e) {
            return { type: Ke.FEATURE, properties: {}, geometry: { type: Ke.POINT, coordinates: _e.coordinates } };
          }) };
        }, fe.set = function(_e) {
          if (_e.type === void 0 || _e.type !== Ke.FEATURE_COLLECTION || !Array.isArray(_e.features)) throw new Error("Invalid FeatureCollection");
          var qe = ne.store.createRenderBatch(), tt = ne.store.getAllIds().slice(), dt = fe.add(_e), ft = new Pt(dt);
          return (tt = tt.filter(function(nt) {
            return !ft.has(nt);
          })).length && fe.delete(tt), qe(), dt;
        }, fe.add = function(_e) {
          var qe = JSON.parse(JSON.stringify(xe(_e))).features.map(function(tt) {
            if (tt.id = tt.id || Mn(), tt.geometry === null) throw new Error("Invalid geometry: null");
            if (ne.store.get(tt.id) === void 0 || ne.store.get(tt.id).type !== tt.geometry.type) {
              var dt = Ht[tt.geometry.type];
              if (dt === void 0) throw new Error("Invalid geometry type: " + tt.geometry.type + ".");
              var ft = new dt(ne, tt);
              ne.store.add(ft);
            } else {
              var nt = ne.store.get(tt.id);
              nt.properties = tt.properties, st(nt.properties, tt.properties) || ne.store.featureChanged(nt.id), st(nt.getCoordinates(), tt.geometry.coordinates) || nt.incomingCoords(tt.geometry.coordinates);
            }
            return tt.id;
          });
          return ne.store.render(), qe;
        }, fe.get = function(_e) {
          var qe = ne.store.get(_e);
          if (qe) return qe.toGeoJSON();
        }, fe.getAll = function() {
          return { type: Ke.FEATURE_COLLECTION, features: ne.store.getAll().map(function(_e) {
            return _e.toGeoJSON();
          }) };
        }, fe.delete = function(_e) {
          return ne.store.delete(_e, { silent: !0 }), fe.getMode() !== mt.DIRECT_SELECT || ne.store.getSelectedIds().length ? ne.store.render() : ne.events.changeMode(mt.SIMPLE_SELECT, void 0, { silent: !0 }), fe;
        }, fe.deleteAll = function() {
          return ne.store.delete(ne.store.getAllIds(), { silent: !0 }), fe.getMode() === mt.DIRECT_SELECT ? ne.events.changeMode(mt.SIMPLE_SELECT, void 0, { silent: !0 }) : ne.store.render(), fe;
        }, fe.changeMode = function(_e, qe) {
          return qe === void 0 && (qe = {}), _e === mt.SIMPLE_SELECT && fe.getMode() === mt.SIMPLE_SELECT ? (Jt(qe.featureIds || [], ne.store.getSelectedIds()) || (ne.store.setSelected(qe.featureIds, { silent: !0 }), ne.store.render()), fe) : (_e === mt.DIRECT_SELECT && fe.getMode() === mt.DIRECT_SELECT && qe.featureId === ne.store.getSelectedIds()[0] || ne.events.changeMode(_e, qe, { silent: !0 }), fe);
        }, fe.getMode = function() {
          return ne.events.getMode();
        }, fe.trash = function() {
          return ne.events.trash({ silent: !0 }), fe;
        }, fe.combineFeatures = function() {
          return ne.events.combineFeatures({ silent: !0 }), fe;
        }, fe.uncombineFeatures = function() {
          return ne.events.uncombineFeatures({ silent: !0 }), fe;
        }, fe.setFeatureProperty = function(_e, qe, tt) {
          return ne.store.setFeatureProperty(_e, qe, tt), fe;
        }, fe;
      }(O, E), O.api = E;
      var Y = Ts(O);
      return E.onAdd = Y.onAdd, E.onRemove = Y.onRemove, E.types = lt, E.options = y, E;
    };
    function Gt(y) {
      yn(y, this);
    }
    return Gt.modes = lr, Gt.constants = ui, Gt.lib = Xr, Gt;
  });
})(P_);
var Rv = P_.exports;
const Ov = /* @__PURE__ */ b_(Rv);
function L_(I, k, B) {
  if (I !== null)
    for (var V, J, ee, he, s, re, Be, Qe = 0, Ie = 0, rt, ut = I.type, lt = ut === "FeatureCollection", Ke = ut === "Feature", mt = lt ? I.features.length : 1, kt = 0; kt < mt; kt++) {
      Be = lt ? I.features[kt].geometry : Ke ? I.geometry : I, rt = Be ? Be.type === "GeometryCollection" : !1, s = rt ? Be.geometries.length : 1;
      for (var Qt = 0; Qt < s; Qt++) {
        var St = 0, It = 0;
        if (he = rt ? Be.geometries[Qt] : Be, he !== null) {
          re = he.coordinates;
          var ni = he.type;
          switch (Qe = 0, ni) {
            case null:
              break;
            case "Point":
              if (k(
                re,
                Ie,
                kt,
                St,
                It
              ) === !1)
                return !1;
              Ie++, St++;
              break;
            case "LineString":
            case "MultiPoint":
              for (V = 0; V < re.length; V++) {
                if (k(
                  re[V],
                  Ie,
                  kt,
                  St,
                  It
                ) === !1)
                  return !1;
                Ie++, ni === "MultiPoint" && St++;
              }
              ni === "LineString" && St++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (V = 0; V < re.length; V++) {
                for (J = 0; J < re[V].length - Qe; J++) {
                  if (k(
                    re[V][J],
                    Ie,
                    kt,
                    St,
                    It
                  ) === !1)
                    return !1;
                  Ie++;
                }
                ni === "MultiLineString" && St++, ni === "Polygon" && It++;
              }
              ni === "Polygon" && St++;
              break;
            case "MultiPolygon":
              for (V = 0; V < re.length; V++) {
                for (It = 0, J = 0; J < re[V].length; J++) {
                  for (ee = 0; ee < re[V][J].length - Qe; ee++) {
                    if (k(
                      re[V][J][ee],
                      Ie,
                      kt,
                      St,
                      It
                    ) === !1)
                      return !1;
                    Ie++;
                  }
                  It++;
                }
                St++;
              }
              break;
            case "GeometryCollection":
              for (V = 0; V < he.geometries.length; V++)
                if (L_(he.geometries[V], k) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function sc(I) {
  var k = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return L_(I, function(B) {
    k[0] > B[0] && (k[0] = B[0]), k[1] > B[1] && (k[1] = B[1]), k[2] < B[0] && (k[2] = B[0]), k[3] < B[1] && (k[3] = B[1]);
  }), k;
}
sc.default = sc;
function z_(I) {
  if (!I)
    throw new Error("coord is required");
  if (!Array.isArray(I)) {
    if (I.type === "Feature" && I.geometry !== null && I.geometry.type === "Point")
      return I.geometry.coordinates;
    if (I.type === "Point")
      return I.coordinates;
  }
  if (Array.isArray(I) && I.length >= 2 && !Array.isArray(I[0]) && !Array.isArray(I[1]))
    return I;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function Bv(I) {
  if (Array.isArray(I))
    return I;
  if (I.type === "Feature") {
    if (I.geometry !== null)
      return I.geometry.coordinates;
  } else if (I.coordinates)
    return I.coordinates;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function yh(I) {
  return I.type === "Feature" ? I.geometry : I;
}
function Ch(I, k, B) {
  if (B === void 0 && (B = {}), !I)
    throw new Error("point is required");
  if (!k)
    throw new Error("polygon is required");
  var V = z_(I), J = yh(k), ee = J.type, he = k.bbox, s = J.coordinates;
  if (he && Fv(V, he) === !1)
    return !1;
  ee === "Polygon" && (s = [s]);
  for (var re = !1, Be = 0; Be < s.length && !re; Be++)
    if (Km(V, s[Be][0], B.ignoreBoundary)) {
      for (var Qe = !1, Ie = 1; Ie < s[Be].length && !Qe; )
        Km(V, s[Be][Ie], !B.ignoreBoundary) && (Qe = !0), Ie++;
      Qe || (re = !0);
    }
  return re;
}
function Km(I, k, B) {
  var V = !1;
  k[0][0] === k[k.length - 1][0] && k[0][1] === k[k.length - 1][1] && (k = k.slice(0, k.length - 1));
  for (var J = 0, ee = k.length - 1; J < k.length; ee = J++) {
    var he = k[J][0], s = k[J][1], re = k[ee][0], Be = k[ee][1], Qe = I[1] * (he - re) + s * (re - I[0]) + Be * (I[0] - he) === 0 && (he - I[0]) * (re - I[0]) <= 0 && (s - I[1]) * (Be - I[1]) <= 0;
    if (Qe)
      return !B;
    var Ie = s > I[1] != Be > I[1] && I[0] < (re - he) * (I[1] - s) / (Be - s) + he;
    Ie && (V = !V);
  }
  return V;
}
function Fv(I, k) {
  return k[0] <= I[0] && k[1] <= I[1] && k[2] >= I[0] && k[3] >= I[1];
}
function pu(I, k, B) {
  B === void 0 && (B = {});
  for (var V = z_(I), J = Bv(k), ee = 0; ee < J.length - 1; ee++) {
    var he = !1;
    if (B.ignoreEndVertices && (ee === 0 && (he = "start"), ee === J.length - 2 && (he = "end"), ee === 0 && ee + 1 === J.length - 1 && (he = "both")), Uv(J[ee], J[ee + 1], V, he, typeof B.epsilon > "u" ? null : B.epsilon))
      return !0;
  }
  return !1;
}
function Uv(I, k, B, V, J) {
  var ee = B[0], he = B[1], s = I[0], re = I[1], Be = k[0], Qe = k[1], Ie = B[0] - s, rt = B[1] - re, ut = Be - s, lt = Qe - re, Ke = Ie * lt - rt * ut;
  if (J !== null) {
    if (Math.abs(Ke) > J)
      return !1;
  } else if (Ke !== 0)
    return !1;
  if (V) {
    if (V === "start")
      return Math.abs(ut) >= Math.abs(lt) ? ut > 0 ? s < ee && ee <= Be : Be <= ee && ee < s : lt > 0 ? re < he && he <= Qe : Qe <= he && he < re;
    if (V === "end")
      return Math.abs(ut) >= Math.abs(lt) ? ut > 0 ? s <= ee && ee < Be : Be < ee && ee <= s : lt > 0 ? re <= he && he < Qe : Qe < he && he <= re;
    if (V === "both")
      return Math.abs(ut) >= Math.abs(lt) ? ut > 0 ? s < ee && ee < Be : Be < ee && ee < s : lt > 0 ? re < he && he < Qe : Qe < he && he < re;
  } else return Math.abs(ut) >= Math.abs(lt) ? ut > 0 ? s <= ee && ee <= Be : Be <= ee && ee <= s : lt > 0 ? re <= he && he <= Qe : Qe <= he && he <= re;
  return !1;
}
function Nv(I, k) {
  var B = yh(I), V = yh(k), J = B.type, ee = V.type, he = B.coordinates, s = V.coordinates;
  switch (J) {
    case "Point":
      switch (ee) {
        case "Point":
          return cp(he, s);
        default:
          throw new Error("feature2 " + ee + " geometry not supported");
      }
    case "MultiPoint":
      switch (ee) {
        case "Point":
          return jv(B, V);
        case "MultiPoint":
          return Vv(B, V);
        default:
          throw new Error("feature2 " + ee + " geometry not supported");
      }
    case "LineString":
      switch (ee) {
        case "Point":
          return pu(V, B, { ignoreEndVertices: !0 });
        case "LineString":
          return Zv(B, V);
        case "MultiPoint":
          return Gv(B, V);
        default:
          throw new Error("feature2 " + ee + " geometry not supported");
      }
    case "Polygon":
      switch (ee) {
        case "Point":
          return Ch(V, B, { ignoreBoundary: !0 });
        case "LineString":
          return qv(B, V);
        case "Polygon":
          return Wv(B, V);
        case "MultiPoint":
          return $v(B, V);
        default:
          throw new Error("feature2 " + ee + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + J + " geometry not supported");
  }
}
function jv(I, k) {
  var B, V = !1;
  for (B = 0; B < I.coordinates.length; B++)
    if (cp(I.coordinates[B], k.coordinates)) {
      V = !0;
      break;
    }
  return V;
}
function Vv(I, k) {
  for (var B = 0, V = k.coordinates; B < V.length; B++) {
    for (var J = V[B], ee = !1, he = 0, s = I.coordinates; he < s.length; he++) {
      var re = s[he];
      if (cp(J, re)) {
        ee = !0;
        break;
      }
    }
    if (!ee)
      return !1;
  }
  return !0;
}
function Gv(I, k) {
  for (var B = !1, V = 0, J = k.coordinates; V < J.length; V++) {
    var ee = J[V];
    if (pu(ee, I, { ignoreEndVertices: !0 }) && (B = !0), !pu(ee, I))
      return !1;
  }
  return !!B;
}
function $v(I, k) {
  for (var B = 0, V = k.coordinates; B < V.length; B++) {
    var J = V[B];
    if (!Ch(J, I, { ignoreBoundary: !0 }))
      return !1;
  }
  return !0;
}
function Zv(I, k) {
  for (var B = !1, V = 0, J = k.coordinates; V < J.length; V++) {
    var ee = J[V];
    if (pu({ type: "Point", coordinates: ee }, I, {
      ignoreEndVertices: !0
    }) && (B = !0), !pu({ type: "Point", coordinates: ee }, I, {
      ignoreEndVertices: !1
    }))
      return !1;
  }
  return B;
}
function qv(I, k) {
  var B = !1, V = 0, J = sc(I), ee = sc(k);
  if (!k_(J, ee))
    return !1;
  for (V; V < k.coordinates.length - 1; V++) {
    var he = Xv(k.coordinates[V], k.coordinates[V + 1]);
    if (Ch({ type: "Point", coordinates: he }, I, {
      ignoreBoundary: !0
    })) {
      B = !0;
      break;
    }
  }
  return B;
}
function Wv(I, k) {
  if (I.type === "Feature" && I.geometry === null || k.type === "Feature" && k.geometry === null)
    return !1;
  var B = sc(I), V = sc(k);
  if (!k_(B, V))
    return !1;
  for (var J = yh(k).coordinates, ee = 0, he = J; ee < he.length; ee++)
    for (var s = he[ee], re = 0, Be = s; re < Be.length; re++) {
      var Qe = Be[re];
      if (!Ch(Qe, I))
        return !1;
    }
  return !0;
}
function k_(I, k) {
  return !(I[0] > k[0] || I[2] < k[2] || I[1] > k[1] || I[3] < k[3]);
}
function cp(I, k) {
  return I[0] === k[0] && I[1] === k[1];
}
function Xv(I, k) {
  return [(I[0] + k[0]) / 2, (I[1] + k[1]) / 2];
}
var D_ = { exports: {} };
(function(I, k) {
  (function(B, V) {
    I.exports = V();
  })(v_, function() {
    var B, V, J;
    function ee(s, re) {
      if (!B)
        B = re;
      else if (!V)
        V = re;
      else {
        var Be = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + B + ")(sharedChunk); (" + V + ")(sharedChunk); self.onerror = null;", Qe = {};
        B(Qe), J = re(Qe), typeof window < "u" && window && window.URL && window.URL.createObjectURL && (J.workerUrl = window.URL.createObjectURL(new Blob([Be], { type: "text/javascript" })));
      }
    }
    ee(["exports"], function(s) {
      var re = typeof self < "u" ? self : {}, Be = "2.15.0";
      let Qe;
      const Ie = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        if (Qe == null) {
          const t = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          try {
            Qe = process.env.API_URL_REGEX != null ? new RegExp(process.env.API_URL_REGEX) : t;
          } catch {
            Qe = t;
          }
        }
        return Qe;
      }, get API_TILEJSON_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
      }, get API_SPRITE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
      }, get API_FONTS_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
      }, get API_STYLE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
      }, get API_CDN_URL_REGEX() {
        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
      }, get EVENTS_URL() {
        if (!Ie.API_URL) return null;
        try {
          const t = new URL(Ie.API_URL);
          return t.hostname === "api.mapbox.cn" ? "https://events.mapbox.cn/events/v2" : t.hostname === "api.mapbox.com" ? "https://events.mapbox.com/events/v2" : null;
        } catch {
          return null;
        }
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, rt = { supported: !1, testSupport: function(t) {
        !Ke && lt && (mt ? kt(t) : ut = t);
      } };
      let ut, lt, Ke = !1, mt = !1;
      function kt(t) {
        const e = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, e);
        try {
          if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, lt), t.isContextLost()) return;
          rt.supported = !0;
        } catch {
        }
        t.deleteTexture(e), Ke = !0;
      }
      re.document && (lt = re.document.createElement("img"), lt.onload = function() {
        ut && kt(ut), ut = null, mt = !0;
      }, lt.onerror = function() {
        Ke = !0, ut = null;
      }, lt.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const Qt = "01";
      function St(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
      }
      var It = ni;
      function ni(t, e, i, n) {
        this.cx = 3 * t, this.bx = 3 * (i - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = i, this.p2y = n;
      }
      ni.prototype = { sampleCurveX: function(t) {
        return ((this.ax * t + this.bx) * t + this.cx) * t;
      }, sampleCurveY: function(t) {
        return ((this.ay * t + this.by) * t + this.cy) * t;
      }, sampleCurveDerivativeX: function(t) {
        return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
      }, solveCurveX: function(t, e) {
        if (e === void 0 && (e = 1e-6), t < 0) return 0;
        if (t > 1) return 1;
        for (var i = t, n = 0; n < 8; n++) {
          var a = this.sampleCurveX(i) - t;
          if (Math.abs(a) < e) return i;
          var c = this.sampleCurveDerivativeX(i);
          if (Math.abs(c) < 1e-6) break;
          i -= a / c;
        }
        var h = 0, p = 1;
        for (i = t, n = 0; n < 20 && (a = this.sampleCurveX(i), !(Math.abs(a - t) < e)); n++) t > a ? h = i : p = i, i = 0.5 * (p - h) + h;
        return i;
      }, solve: function(t, e) {
        return this.sampleCurveY(this.solveCurveX(t, e));
      } };
      var Qr = St(It), ui = $i;
      function $i(t, e) {
        this.x = t, this.y = e;
      }
      $i.prototype = { clone: function() {
        return new $i(this.x, this.y);
      }, add: function(t) {
        return this.clone()._add(t);
      }, sub: function(t) {
        return this.clone()._sub(t);
      }, multByPoint: function(t) {
        return this.clone()._multByPoint(t);
      }, divByPoint: function(t) {
        return this.clone()._divByPoint(t);
      }, mult: function(t) {
        return this.clone()._mult(t);
      }, div: function(t) {
        return this.clone()._div(t);
      }, rotate: function(t) {
        return this.clone()._rotate(t);
      }, rotateAround: function(t, e) {
        return this.clone()._rotateAround(t, e);
      }, matMult: function(t) {
        return this.clone()._matMult(t);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t) {
        return this.x === t.x && this.y === t.y;
      }, dist: function(t) {
        return Math.sqrt(this.distSqr(t));
      }, distSqr: function(t) {
        var e = t.x - this.x, i = t.y - this.y;
        return e * e + i * i;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t) {
        return Math.atan2(this.y - t.y, this.x - t.x);
      }, angleWith: function(t) {
        return this.angleWithSep(t.x, t.y);
      }, angleWithSep: function(t, e) {
        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);
      }, _matMult: function(t) {
        var e = t[2] * this.x + t[3] * this.y;
        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;
      }, _add: function(t) {
        return this.x += t.x, this.y += t.y, this;
      }, _sub: function(t) {
        return this.x -= t.x, this.y -= t.y, this;
      }, _mult: function(t) {
        return this.x *= t, this.y *= t, this;
      }, _div: function(t) {
        return this.x /= t, this.y /= t, this;
      }, _multByPoint: function(t) {
        return this.x *= t.x, this.y *= t.y, this;
      }, _divByPoint: function(t) {
        return this.x /= t.x, this.y /= t.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t = this.y;
        return this.y = this.x, this.x = -t, this;
      }, _rotate: function(t) {
        var e = Math.cos(t), i = Math.sin(t), n = i * this.x + e * this.y;
        return this.x = e * this.x - i * this.y, this.y = n, this;
      }, _rotateAround: function(t, e) {
        var i = Math.cos(t), n = Math.sin(t), a = e.y + n * (this.x - e.x) + i * (this.y - e.y);
        return this.x = e.x + i * (this.x - e.x) - n * (this.y - e.y), this.y = a, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, $i.convert = function(t) {
        return t instanceof $i ? t : Array.isArray(t) ? new $i(t[0], t[1]) : t;
      };
      var et = St(ui);
      const Dr = Math.PI / 180, or = 180 / Math.PI;
      function Pt(t) {
        return t * Dr;
      }
      function Fi(t) {
        return t * or;
      }
      const Zr = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function Fn(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        const e = t * t, i = e * t;
        return 4 * (t < 0.5 ? i : 3 * (t - e) + i - 0.75);
      }
      function br(t, e, i, n) {
        const a = new Qr(t, e, i, n);
        return function(c) {
          return a.solve(c);
        };
      }
      const ao = br(0.25, 0.1, 0.25, 1);
      function Vt(t, e, i) {
        return Math.min(i, Math.max(e, t));
      }
      function Sn(t, e, i) {
        return (i = Vt((i - t) / (e - t), 0, 1)) * i * (3 - 2 * i);
      }
      function Zi(t, e, i) {
        const n = i - e, a = ((t - e) % n + n) % n + e;
        return a === e ? i : a;
      }
      function er(t, e, i) {
        if (!t.length) return i(null, []);
        let n = t.length;
        const a = new Array(t.length);
        let c = null;
        t.forEach((h, p) => {
          e(h, (m, _) => {
            m && (c = m), a[p] = _, --n == 0 && i(c, a);
          });
        });
      }
      function Mn(t) {
        const e = [];
        for (const i in t) e.push(t[i]);
        return e;
      }
      function si(t, ...e) {
        for (const i of e) for (const n in i) t[n] = i[n];
        return t;
      }
      let Rr = 1;
      function Or() {
        return Rr++;
      }
      function sr() {
        return function t(e) {
          return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);
        }();
      }
      function Un(t) {
        return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      }
      function Io(t) {
        return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);
      }
      function tr(t, e) {
        t.forEach((i) => {
          e[i] && (e[i] = e[i].bind(e));
        });
      }
      function Wt(t, e) {
        return t.indexOf(e, t.length - e.length) !== -1;
      }
      function ei(t, e, i) {
        const n = {};
        for (const a in t) n[a] = e.call(this, t[a], a, t);
        return n;
      }
      function Yo(t, e, i) {
        const n = {};
        for (const a in t) e.call(i || this, t[a], a, t) && (n[a] = t[a]);
        return n;
      }
      function qr(t) {
        return Array.isArray(t) ? t.map(qr) : typeof t == "object" && t ? ei(t, qr) : t;
      }
      const Nn = {};
      function Ui(t) {
        Nn[t] || (typeof console < "u" && console.warn(t), Nn[t] = !0);
      }
      function oi(t, e, i) {
        return (i.y - t.y) * (e.x - t.x) > (e.y - t.y) * (i.x - t.x);
      }
      function ws(t) {
        let e = 0;
        for (let i, n, a = 0, c = t.length, h = c - 1; a < c; h = a++) i = t[a], n = t[h], e += (n.x - i.x) * (i.y + n.y);
        return e;
      }
      function jn() {
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
      }
      function Wr(t) {
        const e = {};
        if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (i, n, a, c) => {
          const h = a || c;
          return e[n] = !h || h.toLowerCase(), "";
        }), e["max-age"]) {
          const i = parseInt(e["max-age"], 10);
          isNaN(i) ? delete e["max-age"] : e["max-age"] = i;
        }
        return e;
      }
      let en = null;
      function Qo(t) {
        if (en == null) {
          const e = t.navigator ? t.navigator.userAgent : null;
          en = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
        }
        return en;
      }
      function Ts(t) {
        try {
          const e = re[t];
          return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
        } catch {
          return !1;
        }
      }
      function Vn(t, e) {
        return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];
      }
      const Gn = "mapbox-tiles";
      let Es = 500, Cn = 50, Br, mn;
      function Po() {
        try {
          return re.caches;
        } catch {
        }
      }
      function _n() {
        Po() && !Br && (Br = re.caches.open(Gn));
      }
      function $n(t) {
        const e = t.indexOf("?");
        if (e < 0) return t;
        const i = function(a) {
          const c = a.indexOf("?");
          return c > 0 ? a.slice(c + 1).split("&") : [];
        }(t), n = i.filter((a) => {
          const c = a.split("=");
          return c[0] === "language" || c[0] === "worldview";
        });
        return n.length ? `${t.slice(0, e)}?${n.join("&")}` : t.slice(0, e);
      }
      let lo = 1 / 0;
      const An = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      typeof Object.freeze == "function" && Object.freeze(An);
      class co extends Error {
        constructor(e, i, n) {
          i === 401 && ve(n) && (e += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e), this.status = i, this.url = n;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const Lo = jn() ? () => self.worker && self.worker.referrer : () => (re.location.protocol === "blob:" ? re.parent : re).location.href, tn = function(t, e) {
        if (!(/^file:/.test(i = t.url) || /^file:/.test(Lo()) && !/^\w+:/.test(i))) {
          if (re.fetch && re.Request && re.AbortController && re.Request.prototype.hasOwnProperty("signal")) return function(n, a) {
            const c = new re.AbortController(), h = new re.Request(n.url, { method: n.method || "GET", body: n.body, credentials: n.credentials, headers: n.headers, referrer: Lo(), referrerPolicy: n.referrerPolicy, signal: c.signal });
            let p = !1, m = !1;
            const _ = (v = h.url).indexOf("sku=") > 0 && ve(v);
            var v;
            n.type === "json" && h.headers.set("Accept", "application/json");
            const w = (C, A, z) => {
              if (m) return;
              if (C && C.message !== "SecurityError" && Ui(C.toString()), A && z) return T(A);
              const U = Date.now();
              re.fetch(h).then((q) => {
                if (q.ok) {
                  const ie = _ ? q.clone() : null;
                  return T(q, ie, U);
                }
                return a(new co(q.statusText, q.status, n.url));
              }).catch((q) => {
                q.name !== "AbortError" && a(new Error(`${q.message} ${n.url}`));
              });
            }, T = (C, A, z) => {
              (n.type === "arrayBuffer" ? C.arrayBuffer() : n.type === "json" ? C.json() : C.text()).then((U) => {
                m || (A && z && function(q, ie, W) {
                  if (_n(), !Br) return;
                  const te = { status: ie.status, statusText: ie.statusText, headers: new re.Headers() };
                  ie.headers.forEach((Se, we) => te.headers.set(we, Se));
                  const ae = Wr(ie.headers.get("Cache-Control") || "");
                  if (ae["no-store"]) return;
                  ae["max-age"] && te.headers.set("Expires", new Date(W + 1e3 * ae["max-age"]).toUTCString());
                  const oe = te.headers.get("Expires");
                  oe && (new Date(oe).getTime() - W < 42e4 || function(Se, we) {
                    if (mn === void 0) try {
                      new Response(new ReadableStream()), mn = !0;
                    } catch {
                      mn = !1;
                    }
                    mn ? we(Se.body) : Se.blob().then(we);
                  }(ie, (Se) => {
                    const we = new re.Response(Se, te);
                    _n(), Br && Br.then((ke) => ke.put($n(q.url), we)).catch((ke) => Ui(ke.message));
                  }));
                }(h, A, z), p = !0, a(null, U, C.headers.get("Cache-Control"), C.headers.get("Expires")));
              }).catch((U) => {
                m || a(new Error(U.message));
              });
            };
            return _ ? function(C, A) {
              if (_n(), !Br) return A(null);
              const z = $n(C.url);
              Br.then((U) => {
                U.match(z).then((q) => {
                  const ie = function(W) {
                    if (!W) return !1;
                    const te = new Date(W.headers.get("Expires") || 0), ae = Wr(W.headers.get("Cache-Control") || "");
                    return te > Date.now() && !ae["no-cache"];
                  }(q);
                  U.delete(z), ie && U.put(z, q.clone()), A(null, q, ie);
                }).catch(A);
              }).catch(A);
            }(h, w) : w(null, null), { cancel: () => {
              m = !0, p || c.abort();
            } };
          }(t, e);
          if (jn() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, e, void 0, !0);
        }
        var i;
        return function(n, a) {
          const c = new re.XMLHttpRequest();
          c.open(n.method || "GET", n.url, !0), n.type === "arrayBuffer" && (c.responseType = "arraybuffer");
          for (const h in n.headers) c.setRequestHeader(h, n.headers[h]);
          return n.type === "json" && (c.responseType = "text", c.setRequestHeader("Accept", "application/json")), c.withCredentials = n.credentials === "include", c.onerror = () => {
            a(new Error(c.statusText));
          }, c.onload = () => {
            if ((c.status >= 200 && c.status < 300 || c.status === 0) && c.response !== null) {
              let h = c.response;
              if (n.type === "json") try {
                h = JSON.parse(c.response);
              } catch (p) {
                return a(p);
              }
              a(null, h, c.getResponseHeader("Cache-Control"), c.getResponseHeader("Expires"));
            } else a(new co(c.statusText, c.status, n.url));
          }, c.send(n.body), { cancel: () => c.abort() };
        }(t, e);
      }, es = function(t, e) {
        return tn(si(t, { type: "arrayBuffer" }), e);
      };
      function ts(t) {
        const e = re.document.createElement("a");
        return e.href = t, e.protocol === re.document.location.protocol && e.host === re.document.location.host;
      }
      const Q = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let D, R;
      D = [], R = 0;
      const H = function(t, e) {
        if (rt.supported && (t.headers || (t.headers = {}), t.headers.accept = "image/webp,*/*"), R >= Ie.MAX_PARALLEL_IMAGE_REQUESTS) {
          const c = { requestParameters: t, callback: e, cancelled: !1, cancel() {
            this.cancelled = !0;
          } };
          return D.push(c), c;
        }
        R++;
        let i = !1;
        const n = () => {
          if (!i) for (i = !0, R--; D.length && R < Ie.MAX_PARALLEL_IMAGE_REQUESTS; ) {
            const c = D.shift(), { requestParameters: h, callback: p, cancelled: m } = c;
            m || (c.cancel = H(h, p).cancel);
          }
        }, a = es(t, (c, h, p, m) => {
          n(), c ? e(c) : h && (re.createImageBitmap ? function(_, v) {
            const w = new re.Blob([new Uint8Array(_)], { type: "image/png" });
            re.createImageBitmap(w).then((T) => {
              v(null, T);
            }).catch((T) => {
              v(new Error(`Could not load image because of ${T.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(h, (_, v) => e(_, v, p, m)) : function(_, v) {
            const w = new re.Image(), T = re.URL;
            w.onload = () => {
              v(null, w), T.revokeObjectURL(w.src), w.onload = null, re.requestAnimationFrame(() => {
                w.src = Q;
              });
            }, w.onerror = () => v(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const C = new re.Blob([new Uint8Array(_)], { type: "image/png" });
            w.src = _.byteLength ? T.createObjectURL(C) : Q;
          }(h, (_, v) => e(_, v, p, m)));
        });
        return { cancel: () => {
          a.cancel(), n();
        } };
      }, se = "NO_ACCESS_TOKEN";
      function de(t) {
        return t.indexOf("mapbox:") === 0;
      }
      function ve(t) {
        return Ie.API_URL_REGEX.test(t);
      }
      function xe(t) {
        return Ie.API_CDN_URL_REGEX.test(t);
      }
      function pe(t) {
        return Ie.API_STYLE_REGEX.test(t) && !Me(t);
      }
      function Me(t) {
        return Ie.API_SPRITE_REGEX.test(t);
      }
      const Xe = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function it(t) {
        const e = t.match(Xe);
        if (!e) throw new Error("Unable to parse URL object");
        return { protocol: e[1], authority: e[2], path: e[3] || "/", params: e[4] ? e[4].split("&") : [] };
      }
      function Ze(t) {
        const e = t.params.length ? `?${t.params.join("&")}` : "";
        return `${t.protocol}://${t.authority}${t.path}${e}`;
      }
      const Bt = "mapbox.eventData";
      function Lt(t) {
        if (!t) return null;
        const e = t.split(".");
        if (!e || e.length !== 3) return null;
        try {
          return JSON.parse(decodeURIComponent(re.atob(e[1]).split("").map((i) => "%" + ("00" + i.charCodeAt(0).toString(16)).slice(-2)).join("")));
        } catch {
          return null;
        }
      }
      class Rt {
        constructor(e) {
          this.type = e, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(e) {
          const i = Lt(Ie.ACCESS_TOKEN);
          let n = "";
          return n = i && i.u ? re.btoa(encodeURIComponent(i.u).replace(/%([0-9A-F]{2})/g, (a, c) => String.fromCharCode(+("0x" + c)))) : Ie.ACCESS_TOKEN || "", e ? `${Bt}.${e}:${n}` : `${Bt}:${n}`;
        }
        fetchEventData() {
          const e = Ts("localStorage"), i = this.getStorageKey(), n = this.getStorageKey("uuid");
          if (e) try {
            const a = re.localStorage.getItem(i);
            a && (this.eventData = JSON.parse(a));
            const c = re.localStorage.getItem(n);
            c && (this.anonId = c);
          } catch {
            Ui("Unable to read from LocalStorage");
          }
        }
        saveEventData() {
          const e = Ts("localStorage"), i = this.getStorageKey(), n = this.getStorageKey("uuid");
          if (e) try {
            re.localStorage.setItem(n, this.anonId), Object.keys(this.eventData).length >= 1 && re.localStorage.setItem(i, JSON.stringify(this.eventData));
          } catch {
            Ui("Unable to write to LocalStorage");
          }
        }
        processRequests(e) {
        }
        postEvent(e, i, n, a) {
          if (!Ie.EVENTS_URL) return;
          const c = it(Ie.EVENTS_URL);
          c.params.push(`access_token=${a || Ie.ACCESS_TOKEN || ""}`);
          const h = { event: this.type, created: new Date(e).toISOString() }, p = i ? si(h, i) : h, m = { url: Ze(c), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([p]) };
          this.pendingRequest = function(_, v) {
            return tn(si(_, { method: "POST" }), v);
          }(m, (_) => {
            this.pendingRequest = null, n(_), this.saveEventData(), this.processRequests(a);
          });
        }
        queueRequest(e, i) {
          this.queue.push(e), this.processRequests(i);
        }
      }
      const qt = new class extends Rt {
        constructor(t) {
          super("appUserTurnstile"), this._customAccessToken = t;
        }
        postTurnstileEvent(t, e) {
          Ie.EVENTS_URL && Ie.ACCESS_TOKEN && Array.isArray(t) && t.some((i) => de(i) || ve(i)) && this.queueRequest(Date.now(), e);
        }
        processRequests(t) {
          if (this.pendingRequest || this.queue.length === 0) return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const e = Lt(Ie.ACCESS_TOKEN), i = e ? e.u : Ie.ACCESS_TOKEN;
          let n = i !== this.eventData.tokenU;
          Io(this.anonId) || (this.anonId = sr(), n = !0);
          const a = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const c = new Date(this.eventData.lastSuccess), h = new Date(a), p = (a - this.eventData.lastSuccess) / 864e5;
            n = n || p >= 1 || p < -1 || c.getDate() !== h.getDate();
          } else n = !0;
          n ? this.postEvent(a, { sdkIdentifier: "mapbox-gl-js", sdkVersion: Be, skuId: Qt, "enabled.telemetry": !1, userId: this.anonId }, (c) => {
            c || (this.eventData.lastSuccess = a, this.eventData.tokenU = i);
          }, t) : this.processRequests();
        }
      }(), Xt = qt.postTurnstileEvent.bind(qt), bi = new class extends Rt {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(t, e, i, n) {
          this.skuToken = e, this.errorCb = n, Ie.EVENTS_URL && (i || Ie.ACCESS_TOKEN ? this.queueRequest({ id: t, timestamp: Date.now() }, i) : this.errorCb(new Error(se)));
        }
        processRequests(t) {
          if (this.pendingRequest || this.queue.length === 0) return;
          const { id: e, timestamp: i } = this.queue.shift();
          e && this.success[e] || (this.anonId || this.fetchEventData(), Io(this.anonId) || (this.anonId = sr()), this.postEvent(i, { sdkIdentifier: "mapbox-gl-js", sdkVersion: Be, skuId: Qt, skuToken: this.skuToken, userId: this.anonId }, (n) => {
            n ? this.errorCb(n) : e && (this.success[e] = !0);
          }, t));
        }
      }(), Hi = bi.postMapLoadEvent.bind(bi), ar = new class extends Rt {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(t, e) {
          Ie.EVENTS_URL && (t || Ie.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e }, t);
        }
        processRequests(t) {
          if (this.pendingRequest || this.queue.length === 0) return;
          const { timestamp: e, performanceData: i } = this.queue.shift(), n = function(a) {
            const c = re.performance.getEntriesByType("resource"), h = re.performance.getEntriesByType("mark"), p = function(T) {
              const C = {};
              if (T) {
                for (const A in T) if (A !== "other") for (const z of T[A]) {
                  const U = `${A}ResolveRangeMin`, q = `${A}ResolveRangeMax`, ie = `${A}RequestCount`, W = `${A}RequestCachedCount`;
                  C[U] = Math.min(C[U] || 1 / 0, z.startTime), C[q] = Math.max(C[q] || -1 / 0, z.responseEnd);
                  const te = (ae) => {
                    C[ae] === void 0 && (C[ae] = 0), ++C[ae];
                  };
                  z.transferSize !== void 0 && z.transferSize === 0 && te(W), te(ie);
                }
              }
              return C;
            }(function(T, C) {
              const A = {};
              if (T) for (const z of T) {
                const U = C(z);
                A[U] === void 0 && (A[U] = []), A[U].push(z);
              }
              return A;
            }(c, yl)), m = re.devicePixelRatio, _ = re.navigator.connection || re.navigator.mozConnection || re.navigator.webkitConnection, v = { counters: [], metadata: [], attributes: [] }, w = (T, C, A) => {
              A != null && T.push({ name: C, value: A.toString() });
            };
            for (const T in p) w(v.counters, T, p[T]);
            if (a.interactionRange[0] !== 1 / 0 && a.interactionRange[1] !== -1 / 0 && (w(v.counters, "interactionRangeMin", a.interactionRange[0]), w(v.counters, "interactionRangeMax", a.interactionRange[1])), h) for (const T of Object.keys(is)) {
              const C = is[T], A = h.find((z) => z.name === C);
              A && w(v.counters, C, A.startTime);
            }
            return w(v.counters, "visibilityHidden", a.visibilityHidden), w(v.attributes, "style", function(T) {
              if (T) for (const C of T) {
                const A = C.name.split("?")[0];
                if (pe(A)) {
                  const z = A.split("/").slice(-2);
                  if (z.length === 2) return `mapbox://styles/${z[0]}/${z[1]}`;
                }
              }
            }(c)), w(v.attributes, "terrainEnabled", a.terrainEnabled ? "true" : "false"), w(v.attributes, "fogEnabled", a.fogEnabled ? "true" : "false"), w(v.attributes, "projection", a.projection), w(v.attributes, "zoom", a.zoom), w(v.metadata, "devicePixelRatio", m), w(v.metadata, "connectionEffectiveType", _ ? _.effectiveType : void 0), w(v.metadata, "navigatorUserAgent", re.navigator.userAgent), w(v.metadata, "screenWidth", re.screen.width), w(v.metadata, "screenHeight", re.screen.height), w(v.metadata, "windowWidth", re.innerWidth), w(v.metadata, "windowHeight", re.innerHeight), w(v.metadata, "mapWidth", a.width / m), w(v.metadata, "mapHeight", a.height / m), w(v.metadata, "webglRenderer", a.renderer), w(v.metadata, "webglVendor", a.vendor), w(v.metadata, "sdkVersion", Be), w(v.metadata, "sdkIdentifier", "mapbox-gl-js"), v;
          }(i);
          for (const a of n.metadata) ;
          for (const a of n.counters) ;
          for (const a of n.attributes) ;
          this.postEvent(e, n, () => {
          }, t);
        }
      }(), qi = ar.postPerformanceEvent.bind(ar), In = new class extends Rt {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(t, e, i, n) {
          if (!Ie.API_URL || !Ie.SESSION_PATH) return;
          const a = it(Ie.API_URL + Ie.SESSION_PATH);
          a.params.push(`sku=${e || ""}`), a.params.push(`access_token=${n || Ie.ACCESS_TOKEN || ""}`);
          const c = { url: Ze(a), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = function(h, p) {
            return tn(si(h, { method: "GET" }), p);
          }(c, (h) => {
            this.pendingRequest = null, i(h), this.saveEventData(), this.processRequests(n);
          });
        }
        getSessionAPI(t, e, i, n) {
          this.skuToken = e, this.errorCb = n, Ie.SESSION_PATH && Ie.API_URL && (i || Ie.ACCESS_TOKEN ? this.queueRequest({ id: t, timestamp: Date.now() }, i) : this.errorCb(new Error(se)));
        }
        processRequests(t) {
          if (this.pendingRequest || this.queue.length === 0) return;
          const { id: e, timestamp: i } = this.queue.shift();
          e && this.success[e] || this.getSession(i, this.skuToken, (n) => {
            n ? this.errorCb(n) : e && (this.success[e] = !0);
          }, t);
        }
      }(), gr = In.getSessionAPI.bind(In), wi = /* @__PURE__ */ new Set(), is = { create: "create", load: "load", fullLoad: "fullLoad" }, hc = { mark(t) {
        re.performance.mark(t);
      }, measure(t, e, i) {
        re.performance.measure(t, e, i);
      } };
      function yl(t) {
        const e = t.name.split("?")[0];
        return xe(e) && e.includes("mapbox-gl.js") ? "javascript" : xe(e) && e.includes("mapbox-gl.css") ? "css" : function(i) {
          return Ie.API_FONTS_REGEX.test(i);
        }(e) ? "fontRange" : Me(e) ? "sprite" : pe(e) ? "style" : function(i) {
          return Ie.API_TILEJSON_REGEX.test(i);
        }(e) ? "tilejson" : "other";
      }
      const ai = re.performance;
      function Ma(t) {
        const e = t ? t.url.toString() : void 0;
        return ai.getEntriesByName(e);
      }
      let zo, Ca, ko, rn;
      const gn = { now: () => ko !== void 0 ? ko : re.performance.now(), setNow(t) {
        ko = t;
      }, restoreNow() {
        ko = void 0;
      }, frame(t) {
        const e = re.requestAnimationFrame(t);
        return { cancel: () => re.cancelAnimationFrame(e) };
      }, getImageData(t, e = 0) {
        const { width: i, height: n } = t;
        rn || (rn = re.document.createElement("canvas"));
        const a = rn.getContext("2d", { willReadFrequently: !0 });
        if (!a) throw new Error("failed to create canvas 2d context");
        return (i > rn.width || n > rn.height) && (rn.width = i, rn.height = n), a.clearRect(-e, -e, i + 2 * e, n + 2 * e), a.drawImage(t, 0, 0, i, n), a.getImageData(-e, -e, i + 2 * e, n + 2 * e);
      }, resolveURL: (t) => (zo || (zo = re.document.createElement("a")), zo.href = t, zo.href), get devicePixelRatio() {
        return re.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!re.matchMedia && (Ca == null && (Ca = re.matchMedia("(prefers-reduced-motion: reduce)")), Ca.matches);
      } };
      function Yi(t, e, i) {
        i[t] && i[t].indexOf(e) !== -1 || (i[t] = i[t] || [], i[t].push(e));
      }
      function Ks(t, e, i) {
        if (i && i[t]) {
          const n = i[t].indexOf(e);
          n !== -1 && i[t].splice(n, 1);
        }
      }
      class uo {
        constructor(e, i = {}) {
          si(this, i), this.type = e;
        }
      }
      class wr extends uo {
        constructor(e, i = {}) {
          super("error", si({ error: e }, i));
        }
      }
      class Fr {
        on(e, i) {
          return this._listeners = this._listeners || {}, Yi(e, i, this._listeners), this;
        }
        off(e, i) {
          return Ks(e, i, this._listeners), Ks(e, i, this._oneTimeListeners), this;
        }
        once(e, i) {
          return i ? (this._oneTimeListeners = this._oneTimeListeners || {}, Yi(e, i, this._oneTimeListeners), this) : new Promise((n) => this.once(e, n));
        }
        fire(e, i) {
          typeof e == "string" && (e = new uo(e, i || {}));
          const n = e.type;
          if (this.listens(n)) {
            e.target = this;
            const a = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
            for (const p of a) p.call(this, e);
            const c = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
            for (const p of c) Ks(n, p, this._oneTimeListeners), p.call(this, e);
            const h = this._eventedParent;
            h && (si(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), h.fire(e));
          } else e instanceof wr && console.error(e.error);
          return this;
        }
        listens(e) {
          return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e));
        }
        setEventedParent(e, i) {
          return this._eventedParent = e, this._eventedParentData = i, this;
        }
      }
      var Pe = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"requires":["fill-extrusion-edge-radius"],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
      function Cr(t, ...e) {
        for (const i of e) for (const n in i) t[n] = i[n];
        return t;
      }
      function Li(t) {
        return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;
      }
      function lr(t) {
        if (Array.isArray(t)) return t.map(lr);
        if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {
          const e = {};
          for (const i in t) e[i] = lr(t[i]);
          return e;
        }
        return Li(t);
      }
      class xl extends Error {
        constructor(e, i) {
          super(i), this.message = i, this.key = e;
        }
      }
      var Pn = xl;
      class Aa {
        constructor(e, i = []) {
          this.parent = e, this.bindings = {};
          for (const [n, a] of i) this.bindings[n] = a;
        }
        concat(e) {
          return new Aa(this, e);
        }
        get(e) {
          if (this.bindings[e]) return this.bindings[e];
          if (this.parent) return this.parent.get(e);
          throw new Error(`${e} not found in scope.`);
        }
        has(e) {
          return !!this.bindings[e] || !!this.parent && this.parent.has(e);
        }
      }
      var Ia = Aa;
      const ho = { kind: "null" }, st = { kind: "number" }, Jt = { kind: "string" }, Ht = { kind: "boolean" }, Xr = { kind: "color" }, yn = { kind: "object" }, Gt = { kind: "value" }, y = { kind: "collator" }, E = { kind: "formatted" }, O = { kind: "resolvedImage" };
      function Y(t, e) {
        return { kind: "array", itemType: t, N: e };
      }
      function ne(t) {
        if (t.kind === "array") {
          const e = ne(t.itemType);
          return typeof t.N == "number" ? `array<${e}, ${t.N}>` : t.itemType.kind === "value" ? "array" : `array<${e}>`;
        }
        return t.kind;
      }
      const fe = [ho, st, Jt, Ht, Xr, E, yn, Y(Gt), O];
      function _e(t, e) {
        if (e.kind === "error") return null;
        if (t.kind === "array") {
          if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !_e(t.itemType, e.itemType)) && (typeof t.N != "number" || t.N === e.N)) return null;
        } else {
          if (t.kind === e.kind) return null;
          if (t.kind === "value") {
            for (const i of fe) if (!_e(i, e)) return null;
          }
        }
        return `Expected ${ne(t)} but found ${ne(e)} instead.`;
      }
      function qe(t, e) {
        return e.some((i) => i.kind === t.kind);
      }
      function tt(t, e) {
        return e.some((i) => i === "null" ? t === null : i === "array" ? Array.isArray(t) : i === "object" ? t && !Array.isArray(t) && typeof t == "object" : i === typeof t);
      }
      var dt, ft = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
      function nt(t) {
        return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;
      }
      function zt(t) {
        return nt(t[t.length - 1] === "%" ? parseFloat(t) / 100 * 255 : parseInt(t));
      }
      function Oi(t) {
        return (e = t[t.length - 1] === "%" ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;
        var e;
      }
      function Ot(t, e, i) {
        return i < 0 ? i += 1 : i > 1 && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t;
      }
      try {
        dt = {}.parseCSSColor = function(t) {
          var e, i = t.replace(/ /g, "").toLowerCase();
          if (i in ft) return ft[i].slice();
          if (i[0] === "#") return i.length === 4 ? (e = parseInt(i.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : i.length === 7 && (e = parseInt(i.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;
          var n = i.indexOf("("), a = i.indexOf(")");
          if (n !== -1 && a + 1 === i.length) {
            var c = i.substr(0, n), h = i.substr(n + 1, a - (n + 1)).split(","), p = 1;
            switch (c) {
              case "rgba":
                if (h.length !== 4) return null;
                p = Oi(h.pop());
              case "rgb":
                return h.length !== 3 ? null : [zt(h[0]), zt(h[1]), zt(h[2]), p];
              case "hsla":
                if (h.length !== 4) return null;
                p = Oi(h.pop());
              case "hsl":
                if (h.length !== 3) return null;
                var m = (parseFloat(h[0]) % 360 + 360) % 360 / 360, _ = Oi(h[1]), v = Oi(h[2]), w = v <= 0.5 ? v * (_ + 1) : v + _ - v * _, T = 2 * v - w;
                return [nt(255 * Ot(T, w, m + 1 / 3)), nt(255 * Ot(T, w, m)), nt(255 * Ot(T, w, m - 1 / 3)), p];
              default:
                return null;
            }
          }
          return null;
        };
      } catch {
      }
      class pi {
        constructor(e, i, n, a = 1) {
          this.r = e, this.g = i, this.b = n, this.a = a;
        }
        static parse(e) {
          if (!e) return;
          if (e instanceof pi) return e;
          if (typeof e != "string") return;
          const i = dt(e);
          return i ? new pi(i[0] / 255 * i[3], i[1] / 255 * i[3], i[2] / 255 * i[3], i[3]) : void 0;
        }
        toString() {
          const [e, i, n, a] = this.toArray();
          return `rgba(${Math.round(e)},${Math.round(i)},${Math.round(n)},${a})`;
        }
        toArray() {
          const { r: e, g: i, b: n, a } = this;
          return a === 0 ? [0, 0, 0, 0] : [255 * e / a, 255 * i / a, 255 * n / a, a];
        }
        toArray01() {
          const { r: e, g: i, b: n, a } = this;
          return a === 0 ? [0, 0, 0, 0] : [e / a, i / a, n / a, a];
        }
        toArray01PremultipliedAlpha() {
          const { r: e, g: i, b: n, a } = this;
          return [e, i, n, a];
        }
      }
      pi.black = new pi(0, 0, 0, 1), pi.white = new pi(1, 1, 1, 1), pi.transparent = new pi(0, 0, 0, 0), pi.red = new pi(1, 0, 0, 1), pi.blue = new pi(0, 0, 1, 1);
      var De = pi;
      class bt {
        constructor(e, i, n) {
          this.sensitivity = e ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(e, i) {
          return this.collator.compare(e, i);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class gi {
        constructor(e, i, n, a, c) {
          this.text = e.normalize ? e.normalize() : e, this.image = i, this.scale = n, this.fontStack = a, this.textColor = c;
        }
      }
      class yi {
        constructor(e) {
          this.sections = e;
        }
        static fromString(e) {
          return new yi([new gi(e, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
        }
        static factory(e) {
          return e instanceof yi ? e : yi.fromString(e);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
        }
        serialize() {
          const e = ["format"];
          for (const i of this.sections) {
            if (i.image) {
              e.push(["image", i.image.name]);
              continue;
            }
            e.push(i.text);
            const n = {};
            i.fontStack && (n["text-font"] = ["literal", i.fontStack.split(",")]), i.scale && (n["font-scale"] = i.scale), i.textColor && (n["text-color"] = ["rgba"].concat(i.textColor.toArray())), e.push(n);
          }
          return e;
        }
      }
      class xi {
        constructor(e) {
          this.name = e.name, this.available = e.available;
        }
        toString() {
          return this.name;
        }
        static fromString(e) {
          return e ? new xi({ name: e, available: !1 }) : null;
        }
        serialize() {
          return ["image", this.name];
        }
      }
      function Js(t, e, i, n) {
        return typeof t == "number" && t >= 0 && t <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof i == "number" && i >= 0 && i <= 255 ? n === void 0 || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, i, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [t, e, i, n] : [t, e, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Ss(t) {
        if (t === null || typeof t == "string" || typeof t == "boolean" || typeof t == "number" || t instanceof De || t instanceof bt || t instanceof yi || t instanceof xi) return !0;
        if (Array.isArray(t)) {
          for (const e of t) if (!Ss(e)) return !1;
          return !0;
        }
        if (typeof t == "object") {
          for (const e in t) if (!Ss(t[e])) return !1;
          return !0;
        }
        return !1;
      }
      function Ft(t) {
        if (t === null) return ho;
        if (typeof t == "string") return Jt;
        if (typeof t == "boolean") return Ht;
        if (typeof t == "number") return st;
        if (t instanceof De) return Xr;
        if (t instanceof bt) return y;
        if (t instanceof yi) return E;
        if (t instanceof xi) return O;
        if (Array.isArray(t)) {
          const e = t.length;
          let i;
          for (const n of t) {
            const a = Ft(n);
            if (i) {
              if (i === a) continue;
              i = Gt;
              break;
            }
            i = a;
          }
          return Y(i || Gt, e);
        }
        return yn;
      }
      function rs(t) {
        const e = typeof t;
        return t === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(t) : t instanceof De || t instanceof yi || t instanceof xi ? t.toString() : JSON.stringify(t);
      }
      class Pa {
        constructor(e, i) {
          this.type = e, this.value = i;
        }
        static parse(e, i) {
          if (e.length !== 2) return i.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (!Ss(e[1])) return i.error("invalid value");
          const n = e[1];
          let a = Ft(n);
          const c = i.expectedType;
          return a.kind !== "array" || a.N !== 0 || !c || c.kind !== "array" || typeof c.N == "number" && c.N !== 0 || (a = c), new Pa(a, n);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof De ? ["rgba"].concat(this.value.toArray()) : this.value instanceof yi ? this.value.serialize() : this.value;
        }
      }
      var Ar = Pa, yr = class {
        constructor(t) {
          this.name = "ExpressionEvaluationError", this.message = t;
        }
        toJSON() {
          return this.message;
        }
      };
      const Ys = { string: Jt, number: st, boolean: Ht, object: yn };
      class Qs {
        constructor(e, i) {
          this.type = e, this.args = i;
        }
        static parse(e, i) {
          if (e.length < 2) return i.error("Expected at least one argument.");
          let n, a = 1;
          const c = e[0];
          if (c === "array") {
            let p, m;
            if (e.length > 2) {
              const _ = e[1];
              if (typeof _ != "string" || !(_ in Ys) || _ === "object") return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
              p = Ys[_], a++;
            } else p = Gt;
            if (e.length > 3) {
              if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return i.error('The length argument to "array" must be a positive integer literal', 2);
              m = e[2], a++;
            }
            n = Y(p, m);
          } else n = Ys[c];
          const h = [];
          for (; a < e.length; a++) {
            const p = i.parse(e[a], a, Gt);
            if (!p) return null;
            h.push(p);
          }
          return new Qs(n, h);
        }
        evaluate(e) {
          for (let i = 0; i < this.args.length; i++) {
            const n = this.args[i].evaluate(e);
            if (!_e(this.type, Ft(n))) return n;
            if (i === this.args.length - 1) throw new yr(`Expected value to be of type ${ne(this.type)}, but found ${ne(Ft(n))} instead.`);
          }
          return null;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
        serialize() {
          const e = this.type, i = [e.kind];
          if (e.kind === "array") {
            const n = e.itemType;
            if (n.kind === "string" || n.kind === "number" || n.kind === "boolean") {
              i.push(n.kind);
              const a = e.N;
              (typeof a == "number" || this.args.length > 1) && i.push(a);
            }
          }
          return i.concat(this.args.map((n) => n.serialize()));
        }
      }
      var xn = Qs;
      class Zn {
        constructor(e) {
          this.type = E, this.sections = e;
        }
        static parse(e, i) {
          if (e.length < 2) return i.error("Expected at least one argument.");
          const n = e[1];
          if (!Array.isArray(n) && typeof n == "object") return i.error("First argument must be an image or text section.");
          const a = [];
          let c = !1;
          for (let h = 1; h <= e.length - 1; ++h) {
            const p = e[h];
            if (c && typeof p == "object" && !Array.isArray(p)) {
              c = !1;
              let m = null;
              if (p["font-scale"] && (m = i.parse(p["font-scale"], 1, st), !m)) return null;
              let _ = null;
              if (p["text-font"] && (_ = i.parse(p["text-font"], 1, Y(Jt)), !_)) return null;
              let v = null;
              if (p["text-color"] && (v = i.parse(p["text-color"], 1, Xr), !v)) return null;
              const w = a[a.length - 1];
              w.scale = m, w.font = _, w.textColor = v;
            } else {
              const m = i.parse(e[h], 1, Gt);
              if (!m) return null;
              const _ = m.type.kind;
              if (_ !== "string" && _ !== "value" && _ !== "null" && _ !== "resolvedImage") return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              c = !0, a.push({ content: m, scale: null, font: null, textColor: null });
            }
          }
          return new Zn(a);
        }
        evaluate(e) {
          return new yi(this.sections.map((i) => {
            const n = i.content.evaluate(e);
            return Ft(n) === O ? new gi("", n, null, null, null) : new gi(rs(n), null, i.scale ? i.scale.evaluate(e) : null, i.font ? i.font.evaluate(e).join(",") : null, i.textColor ? i.textColor.evaluate(e) : null);
          }));
        }
        eachChild(e) {
          for (const i of this.sections) e(i.content), i.scale && e(i.scale), i.font && e(i.font), i.textColor && e(i.textColor);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = ["format"];
          for (const i of this.sections) {
            e.push(i.content.serialize());
            const n = {};
            i.scale && (n["font-scale"] = i.scale.serialize()), i.font && (n["text-font"] = i.font.serialize()), i.textColor && (n["text-color"] = i.textColor.serialize()), e.push(n);
          }
          return e;
        }
      }
      class Ms {
        constructor(e) {
          this.type = O, this.input = e;
        }
        static parse(e, i) {
          if (e.length !== 2) return i.error("Expected two arguments.");
          const n = i.parse(e[1], 1, Jt);
          return n ? new Ms(n) : i.error("No image name provided.");
        }
        evaluate(e) {
          const i = this.input.evaluate(e), n = xi.fromString(i);
          return n && e.availableImages && (n.available = e.availableImages.indexOf(i) > -1), n;
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return ["image", this.input.serialize()];
        }
      }
      const dc = { "to-boolean": Ht, "to-color": Xr, "to-number": st, "to-string": Jt };
      class La {
        constructor(e, i) {
          this.type = e, this.args = i;
        }
        static parse(e, i) {
          if (e.length < 2) return i.error("Expected at least one argument.");
          const n = e[0];
          if ((n === "to-boolean" || n === "to-string") && e.length !== 2) return i.error("Expected one argument.");
          const a = dc[n], c = [];
          for (let h = 1; h < e.length; h++) {
            const p = i.parse(e[h], h, Gt);
            if (!p) return null;
            c.push(p);
          }
          return new La(a, c);
        }
        evaluate(e) {
          if (this.type.kind === "boolean") return !!this.args[0].evaluate(e);
          if (this.type.kind === "color") {
            let i, n;
            for (const a of this.args) {
              if (i = a.evaluate(e), n = null, i instanceof De) return i;
              if (typeof i == "string") {
                const c = e.parseColor(i);
                if (c) return c;
              } else if (Array.isArray(i) && (n = i.length < 3 || i.length > 4 ? `Invalid rbga value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : Js(i[0], i[1], i[2], i[3]), !n)) return new De(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
            }
            throw new yr(n || `Could not parse color from value '${typeof i == "string" ? i : String(JSON.stringify(i))}'`);
          }
          if (this.type.kind === "number") {
            let i = null;
            for (const n of this.args) {
              if (i = n.evaluate(e), i === null) return 0;
              const a = Number(i);
              if (!isNaN(a)) return a;
            }
            throw new yr(`Could not convert ${JSON.stringify(i)} to number.`);
          }
          return this.type.kind === "formatted" ? yi.fromString(rs(this.args[0].evaluate(e))) : this.type.kind === "resolvedImage" ? xi.fromString(rs(this.args[0].evaluate(e))) : rs(this.args[0].evaluate(e));
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
        serialize() {
          if (this.type.kind === "formatted") return new Zn([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if (this.type.kind === "resolvedImage") return new Ms(this.args[0]).serialize();
          const e = [`to-${this.type.kind}`];
          return this.eachChild((i) => {
            e.push(i.serialize());
          }), e;
        }
      }
      var ns = La;
      const vn = ["Unknown", "Point", "LineString", "Polygon"];
      var ea = class {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
        }
        id() {
          return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? vn[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const t = this.featureDistanceData.center, e = this.featureDistanceData.scale, { x: i, y: n } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (i * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);
          }
          return 0;
        }
        parseColor(t) {
          let e = this._parseColorCache[t];
          return e || (e = this._parseColorCache[t] = De.parse(t)), e;
        }
      };
      class po {
        constructor(e, i, n, a) {
          this.name = e, this.type = i, this._evaluate = n, this.args = a;
        }
        evaluate(e) {
          return this._evaluate(e, this.args);
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return [this.name].concat(this.args.map((e) => e.serialize()));
        }
        static parse(e, i) {
          const n = e[0], a = po.definitions[n];
          if (!a) return i.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const c = Array.isArray(a) ? a[0] : a.type, h = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, p = h.filter(([_]) => !Array.isArray(_) || _.length === e.length - 1);
          let m = null;
          for (const [_, v] of p) {
            m = new Oa(i.registry, i.path, null, i.scope);
            const w = [];
            let T = !1;
            for (let C = 1; C < e.length; C++) {
              const A = e[C], z = Array.isArray(_) ? _[C - 1] : _.type, U = m.parse(A, 1 + w.length, z);
              if (!U) {
                T = !0;
                break;
              }
              w.push(U);
            }
            if (!T) if (Array.isArray(_) && _.length !== w.length) m.error(`Expected ${_.length} arguments, but found ${w.length} instead.`);
            else {
              for (let C = 0; C < w.length; C++) {
                const A = Array.isArray(_) ? _[C] : _.type, z = w[C];
                m.concat(C + 1).checkSubtype(A, z.type);
              }
              if (m.errors.length === 0) return new po(n, c, v, w);
            }
          }
          if (p.length === 1) i.errors.push(...m.errors);
          else {
            const _ = (p.length ? p : h).map(([w]) => {
              return T = w, Array.isArray(T) ? `(${T.map(ne).join(", ")})` : `(${ne(T.type)}...)`;
              var T;
            }).join(" | "), v = [];
            for (let w = 1; w < e.length; w++) {
              const T = i.parse(e[w], 1 + v.length);
              if (!T) return null;
              v.push(ne(T.type));
            }
            i.error(`Expected arguments of type ${_}, but found (${v.join(", ")}) instead.`);
          }
          return null;
        }
        static register(e, i) {
          po.definitions = i;
          for (const n in i) e[n] = po;
        }
      }
      var qn = po;
      class Cs {
        constructor(e, i, n) {
          this.type = y, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = i;
        }
        static parse(e, i) {
          if (e.length !== 2) return i.error("Expected one argument.");
          const n = e[1];
          if (typeof n != "object" || Array.isArray(n)) return i.error("Collator options argument must be an object.");
          const a = i.parse(n["case-sensitive"] !== void 0 && n["case-sensitive"], 1, Ht);
          if (!a) return null;
          const c = i.parse(n["diacritic-sensitive"] !== void 0 && n["diacritic-sensitive"], 1, Ht);
          if (!c) return null;
          let h = null;
          return n.locale && (h = i.parse(n.locale, 1, Jt), !h) ? null : new Cs(a, c, h);
        }
        evaluate(e) {
          return new bt(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
        }
        eachChild(e) {
          e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = {};
          return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ["collator", e];
        }
      }
      const nn = 8192;
      function os(t, e) {
        t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);
      }
      function Do(t, e) {
        return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);
      }
      function Ur(t, e) {
        const i = (180 + t[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360, a = Math.pow(2, e.z);
        return [Math.round(i * a * nn), Math.round(n * a * nn)];
      }
      function za(t, e, i) {
        const n = t[0] - e[0], a = t[1] - e[1], c = t[0] - i[0], h = t[1] - i[1];
        return n * h - c * a == 0 && n * c <= 0 && a * h <= 0;
      }
      function As(t, e) {
        let i = !1;
        for (let h = 0, p = e.length; h < p; h++) {
          const m = e[h];
          for (let _ = 0, v = m.length; _ < v - 1; _++) {
            if (za(t, m[_], m[_ + 1])) return !1;
            (a = m[_])[1] > (n = t)[1] != (c = m[_ + 1])[1] > n[1] && n[0] < (c[0] - a[0]) * (n[1] - a[1]) / (c[1] - a[1]) + a[0] && (i = !i);
          }
        }
        var n, a, c;
        return i;
      }
      function ka(t, e) {
        for (let i = 0; i < e.length; i++) if (As(t, e[i])) return !0;
        return !1;
      }
      function ta(t, e, i, n) {
        const a = n[0] - i[0], c = n[1] - i[1], h = (t[0] - i[0]) * c - a * (t[1] - i[1]), p = (e[0] - i[0]) * c - a * (e[1] - i[1]);
        return h > 0 && p < 0 || h < 0 && p > 0;
      }
      function Wn(t, e, i) {
        for (const _ of i) for (let v = 0; v < _.length - 1; ++v) if ((p = [(h = _[v + 1])[0] - (c = _[v])[0], h[1] - c[1]])[0] * (m = [(a = e)[0] - (n = t)[0], a[1] - n[1]])[1] - p[1] * m[0] != 0 && ta(n, a, c, h) && ta(c, h, n, a)) return !0;
        var n, a, c, h, p, m;
        return !1;
      }
      function li(t, e) {
        for (let i = 0; i < t.length; ++i) if (!As(t[i], e)) return !1;
        for (let i = 0; i < t.length - 1; ++i) if (Wn(t[i], t[i + 1], e)) return !1;
        return !0;
      }
      function vl(t, e) {
        for (let i = 0; i < e.length; i++) if (li(t, e[i])) return !0;
        return !1;
      }
      function Da(t, e, i) {
        const n = [];
        for (let a = 0; a < t.length; a++) {
          const c = [];
          for (let h = 0; h < t[a].length; h++) {
            const p = Ur(t[a][h], i);
            os(e, p), c.push(p);
          }
          n.push(c);
        }
        return n;
      }
      function fo(t, e, i) {
        const n = [];
        for (let a = 0; a < t.length; a++) {
          const c = Da(t[a], e, i);
          n.push(c);
        }
        return n;
      }
      function ia(t, e, i, n) {
        if (t[0] < i[0] || t[0] > i[2]) {
          const a = 0.5 * n;
          let c = t[0] - i[0] > a ? -n : i[0] - t[0] > a ? n : 0;
          c === 0 && (c = t[0] - i[2] > a ? -n : i[2] - t[0] > a ? n : 0), t[0] += c;
        }
        os(e, t);
      }
      function bl(t, e, i, n) {
        const a = Math.pow(2, n.z) * nn, c = [n.x * nn, n.y * nn], h = [];
        if (!t) return h;
        for (const p of t) for (const m of p) {
          const _ = [m.x + c[0], m.y + c[1]];
          ia(_, e, i, a), h.push(_);
        }
        return h;
      }
      function Ra(t, e, i, n) {
        const a = Math.pow(2, n.z) * nn, c = [n.x * nn, n.y * nn], h = [];
        if (!t) return h;
        for (const m of t) {
          const _ = [];
          for (const v of m) {
            const w = [v.x + c[0], v.y + c[1]];
            os(e, w), _.push(w);
          }
          h.push(_);
        }
        if (e[2] - e[0] <= a / 2) {
          (p = e)[0] = p[1] = 1 / 0, p[2] = p[3] = -1 / 0;
          for (const m of h) for (const _ of m) ia(_, e, i, a);
        }
        var p;
        return h;
      }
      class mo {
        constructor(e, i) {
          this.type = Ht, this.geojson = e, this.geometries = i;
        }
        static parse(e, i) {
          if (e.length !== 2) return i.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (Ss(e[1])) {
            const n = e[1];
            if (n.type === "FeatureCollection") for (let a = 0; a < n.features.length; ++a) {
              const c = n.features[a].geometry.type;
              if (c === "Polygon" || c === "MultiPolygon") return new mo(n, n.features[a].geometry);
            }
            else if (n.type === "Feature") {
              const a = n.geometry.type;
              if (a === "Polygon" || a === "MultiPolygon") return new mo(n, n.geometry);
            } else if (n.type === "Polygon" || n.type === "MultiPolygon") return new mo(n, n);
          }
          return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point") return function(i, n) {
              const a = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c = [1 / 0, 1 / 0, -1 / 0, -1 / 0], h = i.canonicalID();
              if (!h) return !1;
              if (n.type === "Polygon") {
                const p = Da(n.coordinates, c, h), m = bl(i.geometry(), a, c, h);
                if (!Do(a, c)) return !1;
                for (const _ of m) if (!As(_, p)) return !1;
              }
              if (n.type === "MultiPolygon") {
                const p = fo(n.coordinates, c, h), m = bl(i.geometry(), a, c, h);
                if (!Do(a, c)) return !1;
                for (const _ of m) if (!ka(_, p)) return !1;
              }
              return !0;
            }(e, this.geometries);
            if (e.geometryType() === "LineString") return function(i, n) {
              const a = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c = [1 / 0, 1 / 0, -1 / 0, -1 / 0], h = i.canonicalID();
              if (!h) return !1;
              if (n.type === "Polygon") {
                const p = Da(n.coordinates, c, h), m = Ra(i.geometry(), a, c, h);
                if (!Do(a, c)) return !1;
                for (const _ of m) if (!li(_, p)) return !1;
              }
              if (n.type === "MultiPolygon") {
                const p = fo(n.coordinates, c, h), m = Ra(i.geometry(), a, c, h);
                if (!Do(a, c)) return !1;
                for (const _ of m) if (!vl(_, p)) return !1;
              }
              return !0;
            }(e, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      var _o = mo;
      function go(t) {
        if (t instanceof qn && (t.name === "get" && t.args.length === 1 || t.name === "feature-state" || t.name === "has" && t.args.length === 1 || t.name === "properties" || t.name === "geometry-type" || t.name === "id" || /^filter-/.test(t.name)) || t instanceof _o) return !1;
        let e = !0;
        return t.eachChild((i) => {
          e && !go(i) && (e = !1);
        }), e;
      }
      function bn(t) {
        if (t instanceof qn && t.name === "feature-state") return !1;
        let e = !0;
        return t.eachChild((i) => {
          e && !bn(i) && (e = !1);
        }), e;
      }
      function Xn(t, e) {
        if (t instanceof qn && e.indexOf(t.name) >= 0) return !1;
        let i = !0;
        return t.eachChild((n) => {
          i && !Xn(n, e) && (i = !1);
        }), i;
      }
      class yo {
        constructor(e, i) {
          this.type = i.type, this.name = e, this.boundExpression = i;
        }
        static parse(e, i) {
          if (e.length !== 2 || typeof e[1] != "string") return i.error("'var' expression requires exactly one string literal argument.");
          const n = e[1];
          return i.scope.has(n) ? new yo(n, i.scope.get(n)) : i.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e) {
          return this.boundExpression.evaluate(e);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      var wl = yo;
      class Is {
        constructor(e, i = [], n, a = new Ia(), c = []) {
          this.registry = e, this.path = i, this.key = i.map((h) => `[${h}]`).join(""), this.scope = a, this.errors = c, this.expectedType = n;
        }
        parse(e, i, n, a, c = {}) {
          return i ? this.concat(i, n, a)._parse(e, c) : this._parse(e, c);
        }
        _parse(e, i) {
          function n(a, c, h) {
            return h === "assert" ? new xn(c, [a]) : h === "coerce" ? new ns(c, [a]) : a;
          }
          if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
            if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const a = e[0];
            if (typeof a != "string") return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const c = this.registry[a];
            if (c) {
              let h = c.parse(e, this);
              if (!h) return null;
              if (this.expectedType) {
                const p = this.expectedType, m = h.type;
                if (p.kind !== "string" && p.kind !== "number" && p.kind !== "boolean" && p.kind !== "object" && p.kind !== "array" || m.kind !== "value") if (p.kind !== "color" && p.kind !== "formatted" && p.kind !== "resolvedImage" || m.kind !== "value" && m.kind !== "string") {
                  if (this.checkSubtype(p, m)) return null;
                } else h = n(h, p, i.typeAnnotation || "coerce");
                else h = n(h, p, i.typeAnnotation || "assert");
              }
              if (!(h instanceof Ar) && h.type.kind !== "resolvedImage" && Ba(h)) {
                const p = new ea();
                try {
                  h = new Ar(h.type, h.evaluate(p));
                } catch (m) {
                  return this.error(m.message), null;
                }
              }
              return h;
            }
            return this.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
        }
        concat(e, i, n) {
          const a = typeof e == "number" ? this.path.concat(e) : this.path, c = n ? this.scope.concat(n) : this.scope;
          return new Is(this.registry, a, i || null, c, this.errors);
        }
        error(e, ...i) {
          const n = `${this.key}${i.map((a) => `[${a}]`).join("")}`;
          this.errors.push(new Pn(n, e));
        }
        checkSubtype(e, i) {
          const n = _e(e, i);
          return n && this.error(n), n;
        }
      }
      var Oa = Is;
      function Ba(t) {
        if (t instanceof wl) return Ba(t.boundExpression);
        if (t instanceof qn && t.name === "error" || t instanceof Cs || t instanceof _o) return !1;
        const e = t instanceof ns || t instanceof xn;
        let i = !0;
        return t.eachChild((n) => {
          i = e ? i && Ba(n) : i && n instanceof Ar;
        }), !!i && go(t) && Xn(t, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
      }
      function ra(t, e) {
        const i = t.length - 1;
        let n, a, c = 0, h = i, p = 0;
        for (; c <= h; ) if (p = Math.floor((c + h) / 2), n = t[p], a = t[p + 1], n <= e) {
          if (p === i || e < a) return p;
          c = p + 1;
        } else {
          if (!(n > e)) throw new yr("Input is not a number.");
          h = p - 1;
        }
        return 0;
      }
      class Ps {
        constructor(e, i, n) {
          this.type = e, this.input = i, this.labels = [], this.outputs = [];
          for (const [a, c] of n) this.labels.push(a), this.outputs.push(c);
        }
        static parse(e, i) {
          if (e.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
          const n = i.parse(e[1], 1, st);
          if (!n) return null;
          const a = [];
          let c = null;
          i.expectedType && i.expectedType.kind !== "value" && (c = i.expectedType);
          for (let h = 1; h < e.length; h += 2) {
            const p = h === 1 ? -1 / 0 : e[h], m = e[h + 1], _ = h, v = h + 1;
            if (typeof p != "number") return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', _);
            if (a.length && a[a.length - 1][0] >= p) return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', _);
            const w = i.parse(m, v, c);
            if (!w) return null;
            c = c || w.type, a.push([p, w]);
          }
          return new Ps(c, n, a);
        }
        evaluate(e) {
          const i = this.labels, n = this.outputs;
          if (i.length === 1) return n[0].evaluate(e);
          const a = this.input.evaluate(e);
          if (a <= i[0]) return n[0].evaluate(e);
          const c = i.length;
          return a >= i[c - 1] ? n[c - 1].evaluate(e) : n[ra(i, a)].evaluate(e);
        }
        eachChild(e) {
          e(this.input);
          for (const i of this.outputs) e(i);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
        serialize() {
          const e = ["step", this.input.serialize()];
          for (let i = 0; i < this.labels.length; i++) i > 0 && e.push(this.labels[i]), e.push(this.outputs[i].serialize());
          return e;
        }
      }
      var Ls = Ps;
      function Kt(t, e, i) {
        return t * (1 - i) + e * i;
      }
      var Hr = Object.freeze({ __proto__: null, array: function(t, e, i) {
        return t.map((n, a) => Kt(n, e[a], i));
      }, color: function(t, e, i) {
        return new De(Kt(t.r, e.r, i), Kt(t.g, e.g, i), Kt(t.b, e.b, i), Kt(t.a, e.a, i));
      }, number: Kt });
      const xo = 0.95047, ss = 1.08883, Hn = 4 / 29, Ro = 6 / 29, as = 3 * Ro * Ro, zs = Ro * Ro * Ro, Tl = Math.PI / 180, El = 180 / Math.PI;
      function Fa(t) {
        return t > zs ? Math.pow(t, 1 / 3) : t / as + Hn;
      }
      function Ua(t) {
        return t > Ro ? t * t * t : as * (t - Hn);
      }
      function na(t) {
        return 255 * (t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055);
      }
      function ks(t) {
        return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
      }
      function Ds(t) {
        const e = ks(t.r), i = ks(t.g), n = ks(t.b), a = Fa((0.4124564 * e + 0.3575761 * i + 0.1804375 * n) / xo), c = Fa((0.2126729 * e + 0.7151522 * i + 0.072175 * n) / 1);
        return { l: 116 * c - 16, a: 500 * (a - c), b: 200 * (c - Fa((0.0193339 * e + 0.119192 * i + 0.9503041 * n) / ss)), alpha: t.a };
      }
      function Oo(t) {
        let e = (t.l + 16) / 116, i = isNaN(t.a) ? e : e + t.a / 500, n = isNaN(t.b) ? e : e - t.b / 200;
        return e = 1 * Ua(e), i = xo * Ua(i), n = ss * Ua(n), new De(na(3.2404542 * i - 1.5371385 * e - 0.4985314 * n), na(-0.969266 * i + 1.8760108 * e + 0.041556 * n), na(0.0556434 * i - 0.2040259 * e + 1.0572252 * n), t.alpha);
      }
      function pc(t, e, i) {
        const n = e - t;
        return t + i * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
      }
      const on = { forward: Ds, reverse: Oo, interpolate: function(t, e, i) {
        return { l: Kt(t.l, e.l, i), a: Kt(t.a, e.a, i), b: Kt(t.b, e.b, i), alpha: Kt(t.alpha, e.alpha, i) };
      } }, ls = { forward: function(t) {
        const { l: e, a: i, b: n } = Ds(t), a = Math.atan2(n, i) * El;
        return { h: a < 0 ? a + 360 : a, c: Math.sqrt(i * i + n * n), l: e, alpha: t.a };
      }, reverse: function(t) {
        const e = t.h * Tl, i = t.c;
        return Oo({ l: t.l, a: Math.cos(e) * i, b: Math.sin(e) * i, alpha: t.alpha });
      }, interpolate: function(t, e, i) {
        return { h: pc(t.h, e.h, i), c: Kt(t.c, e.c, i), l: Kt(t.l, e.l, i), alpha: Kt(t.alpha, e.alpha, i) };
      } };
      var Kn = Object.freeze({ __proto__: null, hcl: ls, lab: on });
      class cs {
        constructor(e, i, n, a, c) {
          this.type = e, this.operator = i, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];
          for (const [h, p] of c) this.labels.push(h), this.outputs.push(p);
        }
        static interpolationFactor(e, i, n, a) {
          let c = 0;
          if (e.name === "exponential") c = Na(i, e.base, n, a);
          else if (e.name === "linear") c = Na(i, 1, n, a);
          else if (e.name === "cubic-bezier") {
            const h = e.controlPoints;
            c = new Qr(h[0], h[1], h[2], h[3]).solve(Na(i, 1, n, a));
          }
          return c;
        }
        static parse(e, i) {
          let [n, a, c, ...h] = e;
          if (!Array.isArray(a) || a.length === 0) return i.error("Expected an interpolation type expression.", 1);
          if (a[0] === "linear") a = { name: "linear" };
          else if (a[0] === "exponential") {
            const _ = a[1];
            if (typeof _ != "number") return i.error("Exponential interpolation requires a numeric base.", 1, 1);
            a = { name: "exponential", base: _ };
          } else {
            if (a[0] !== "cubic-bezier") return i.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);
            {
              const _ = a.slice(1);
              if (_.length !== 4 || _.some((v) => typeof v != "number" || v < 0 || v > 1)) return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              a = { name: "cubic-bezier", controlPoints: _ };
            }
          }
          if (e.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
          if (c = i.parse(c, 2, st), !c) return null;
          const p = [];
          let m = null;
          n === "interpolate-hcl" || n === "interpolate-lab" ? m = Xr : i.expectedType && i.expectedType.kind !== "value" && (m = i.expectedType);
          for (let _ = 0; _ < h.length; _ += 2) {
            const v = h[_], w = h[_ + 1], T = _ + 3, C = _ + 4;
            if (typeof v != "number") return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', T);
            if (p.length && p[p.length - 1][0] >= v) return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', T);
            const A = i.parse(w, C, m);
            if (!A) return null;
            m = m || A.type, p.push([v, A]);
          }
          return m.kind === "number" || m.kind === "color" || m.kind === "array" && m.itemType.kind === "number" && typeof m.N == "number" ? new cs(m, n, a, c, p) : i.error(`Type ${ne(m)} is not interpolatable.`);
        }
        evaluate(e) {
          const i = this.labels, n = this.outputs;
          if (i.length === 1) return n[0].evaluate(e);
          const a = this.input.evaluate(e);
          if (a <= i[0]) return n[0].evaluate(e);
          const c = i.length;
          if (a >= i[c - 1]) return n[c - 1].evaluate(e);
          const h = ra(i, a), p = cs.interpolationFactor(this.interpolation, a, i[h], i[h + 1]), m = n[h].evaluate(e), _ = n[h + 1].evaluate(e);
          return this.operator === "interpolate" ? Hr[this.type.kind.toLowerCase()](m, _, p) : this.operator === "interpolate-hcl" ? ls.reverse(ls.interpolate(ls.forward(m), ls.forward(_), p)) : on.reverse(on.interpolate(on.forward(m), on.forward(_), p));
        }
        eachChild(e) {
          e(this.input);
          for (const i of this.outputs) e(i);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
        serialize() {
          let e;
          e = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const i = [this.operator, e, this.input.serialize()];
          for (let n = 0; n < this.labels.length; n++) i.push(this.labels[n], this.outputs[n].serialize());
          return i;
        }
      }
      function Na(t, e, i, n) {
        const a = n - i, c = t - i;
        return a === 0 ? 0 : e === 1 ? c / a : (Math.pow(e, c) - 1) / (Math.pow(e, a) - 1);
      }
      var Kr = cs;
      class us {
        constructor(e, i) {
          this.type = e, this.args = i;
        }
        static parse(e, i) {
          if (e.length < 2) return i.error("Expectected at least one argument.");
          let n = null;
          const a = i.expectedType;
          a && a.kind !== "value" && (n = a);
          const c = [];
          for (const p of e.slice(1)) {
            const m = i.parse(p, 1 + c.length, n, void 0, { typeAnnotation: "omit" });
            if (!m) return null;
            n = n || m.type, c.push(m);
          }
          const h = a && c.some((p) => _e(a, p.type));
          return new us(h ? Gt : n, c);
        }
        evaluate(e) {
          let i, n = null, a = 0;
          for (const c of this.args) {
            if (a++, n = c.evaluate(e), n && n instanceof xi && !n.available && (i || (i = n), n = null, a === this.args.length)) return i;
            if (n !== null) break;
          }
          return n;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
        serialize() {
          const e = ["coalesce"];
          return this.eachChild((i) => {
            e.push(i.serialize());
          }), e;
        }
      }
      var oa = us;
      class Rs {
        constructor(e, i) {
          this.type = i.type, this.bindings = [].concat(e), this.result = i;
        }
        evaluate(e) {
          return this.result.evaluate(e);
        }
        eachChild(e) {
          for (const i of this.bindings) e(i[1]);
          e(this.result);
        }
        static parse(e, i) {
          if (e.length < 4) return i.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
          const n = [];
          for (let c = 1; c < e.length - 1; c += 2) {
            const h = e[c];
            if (typeof h != "string") return i.error(`Expected string, but found ${typeof h} instead.`, c);
            if (/[^a-zA-Z0-9_]/.test(h)) return i.error("Variable names must contain only alphanumeric characters or '_'.", c);
            const p = i.parse(e[c + 1], c + 1);
            if (!p) return null;
            n.push([h, p]);
          }
          const a = i.parse(e[e.length - 1], e.length - 1, i.expectedType, n);
          return a ? new Rs(n, a) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const e = ["let"];
          for (const [i, n] of this.bindings) e.push(i, n.serialize());
          return e.push(this.result.serialize()), e;
        }
      }
      var ja = Rs;
      class Bo {
        constructor(e, i, n) {
          this.type = e, this.index = i, this.input = n;
        }
        static parse(e, i) {
          if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const n = i.parse(e[1], 1, st), a = i.parse(e[2], 2, Y(i.expectedType || Gt));
          return n && a ? new Bo(a.type.itemType, n, a) : null;
        }
        evaluate(e) {
          const i = this.index.evaluate(e), n = this.input.evaluate(e);
          if (i < 0) throw new yr(`Array index out of bounds: ${i} < 0.`);
          if (i >= n.length) throw new yr(`Array index out of bounds: ${i} > ${n.length - 1}.`);
          if (i !== Math.floor(i)) throw new yr(`Array index must be an integer, but found ${i} instead.`);
          return n[i];
        }
        eachChild(e) {
          e(this.index), e(this.input);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      var Sl = Bo;
      class Va {
        constructor(e, i) {
          this.type = Ht, this.needle = e, this.haystack = i;
        }
        static parse(e, i) {
          if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const n = i.parse(e[1], 1, Gt), a = i.parse(e[2], 2, Gt);
          return n && a ? qe(n.type, [Ht, Jt, st, ho, Gt]) ? new Va(n, a) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne(n.type)} instead`) : null;
        }
        evaluate(e) {
          const i = this.needle.evaluate(e), n = this.haystack.evaluate(e);
          if (n == null) return !1;
          if (!tt(i, ["boolean", "string", "number", "null"])) throw new yr(`Expected first argument to be of type boolean, string, number or null, but found ${ne(Ft(i))} instead.`);
          if (!tt(n, ["string", "array"])) throw new yr(`Expected second argument to be of type array or string, but found ${ne(Ft(n))} instead.`);
          return n.indexOf(i) >= 0;
        }
        eachChild(e) {
          e(this.needle), e(this.haystack);
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var ye = Va;
      class ze {
        constructor(e, i, n) {
          this.type = st, this.needle = e, this.haystack = i, this.fromIndex = n;
        }
        static parse(e, i) {
          if (e.length <= 2 || e.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const n = i.parse(e[1], 1, Gt), a = i.parse(e[2], 2, Gt);
          if (!n || !a) return null;
          if (!qe(n.type, [Ht, Jt, st, ho, Gt])) return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne(n.type)} instead`);
          if (e.length === 4) {
            const c = i.parse(e[3], 3, st);
            return c ? new ze(n, a, c) : null;
          }
          return new ze(n, a);
        }
        evaluate(e) {
          const i = this.needle.evaluate(e), n = this.haystack.evaluate(e);
          if (!tt(i, ["boolean", "string", "number", "null"])) throw new yr(`Expected first argument to be of type boolean, string, number or null, but found ${ne(Ft(i))} instead.`);
          if (!tt(n, ["string", "array"])) throw new yr(`Expected second argument to be of type array or string, but found ${ne(Ft(n))} instead.`);
          if (this.fromIndex) {
            const a = this.fromIndex.evaluate(e);
            return n.indexOf(i, a);
          }
          return n.indexOf(i);
        }
        eachChild(e) {
          e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          if (this.fromIndex != null && this.fromIndex !== void 0) {
            const e = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), e];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var ht = ze;
      class Mt {
        constructor(e, i, n, a, c, h) {
          this.inputType = e, this.type = i, this.input = n, this.cases = a, this.outputs = c, this.otherwise = h;
        }
        static parse(e, i) {
          if (e.length < 5) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 1) return i.error("Expected an even number of arguments.");
          let n, a;
          i.expectedType && i.expectedType.kind !== "value" && (a = i.expectedType);
          const c = {}, h = [];
          for (let _ = 2; _ < e.length - 1; _ += 2) {
            let v = e[_];
            const w = e[_ + 1];
            Array.isArray(v) || (v = [v]);
            const T = i.concat(_);
            if (v.length === 0) return T.error("Expected at least one branch label.");
            for (const A of v) {
              if (typeof A != "number" && typeof A != "string") return T.error("Branch labels must be numbers or strings.");
              if (typeof A == "number" && Math.abs(A) > Number.MAX_SAFE_INTEGER) return T.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof A == "number" && Math.floor(A) !== A) return T.error("Numeric branch labels must be integer values.");
              if (n) {
                if (T.checkSubtype(n, Ft(A))) return null;
              } else n = Ft(A);
              if (c[String(A)] !== void 0) return T.error("Branch labels must be unique.");
              c[String(A)] = h.length;
            }
            const C = i.parse(w, _, a);
            if (!C) return null;
            a = a || C.type, h.push(C);
          }
          const p = i.parse(e[1], 1, Gt);
          if (!p) return null;
          const m = i.parse(e[e.length - 1], e.length - 1, a);
          return m ? p.type.kind !== "value" && i.concat(1).checkSubtype(n, p.type) ? null : new Mt(n, a, p, c, h, m) : null;
        }
        evaluate(e) {
          const i = this.input.evaluate(e);
          return (Ft(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(e);
        }
        eachChild(e) {
          e(this.input), this.outputs.forEach(e), e(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e = ["match", this.input.serialize()], i = Object.keys(this.cases).sort(), n = [], a = {};
          for (const h of i) {
            const p = a[this.cases[h]];
            p === void 0 ? (a[this.cases[h]] = n.length, n.push([this.cases[h], [h]])) : n[p][1].push(h);
          }
          const c = (h) => this.inputType.kind === "number" ? Number(h) : h;
          for (const [h, p] of n) e.push(p.length === 1 ? c(p[0]) : p.map(c)), e.push(this.outputs[h].serialize());
          return e.push(this.otherwise.serialize()), e;
        }
      }
      var Ni = Mt;
      class ri {
        constructor(e, i, n) {
          this.type = e, this.branches = i, this.otherwise = n;
        }
        static parse(e, i) {
          if (e.length < 4) return i.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 0) return i.error("Expected an odd number of arguments.");
          let n;
          i.expectedType && i.expectedType.kind !== "value" && (n = i.expectedType);
          const a = [];
          for (let h = 1; h < e.length - 1; h += 2) {
            const p = i.parse(e[h], h, Ht);
            if (!p) return null;
            const m = i.parse(e[h + 1], h + 1, n);
            if (!m) return null;
            a.push([p, m]), n = n || m.type;
          }
          const c = i.parse(e[e.length - 1], e.length - 1, n);
          return c ? new ri(n, a, c) : null;
        }
        evaluate(e) {
          for (const [i, n] of this.branches) if (i.evaluate(e)) return n.evaluate(e);
          return this.otherwise.evaluate(e);
        }
        eachChild(e) {
          for (const [i, n] of this.branches) e(i), e(n);
          e(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([e, i]) => i.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e = ["case"];
          return this.eachChild((i) => {
            e.push(i.serialize());
          }), e;
        }
      }
      var Wi = ri;
      class Vi {
        constructor(e, i, n, a) {
          this.type = e, this.input = i, this.beginIndex = n, this.endIndex = a;
        }
        static parse(e, i) {
          if (e.length <= 2 || e.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const n = i.parse(e[1], 1, Gt), a = i.parse(e[2], 2, st);
          if (!n || !a) return null;
          if (!qe(n.type, [Y(Gt), Jt, Gt])) return i.error(`Expected first argument to be of type array or string, but found ${ne(n.type)} instead`);
          if (e.length === 4) {
            const c = i.parse(e[3], 3, st);
            return c ? new Vi(n.type, n, a, c) : null;
          }
          return new Vi(n.type, n, a);
        }
        evaluate(e) {
          const i = this.input.evaluate(e), n = this.beginIndex.evaluate(e);
          if (!tt(i, ["string", "array"])) throw new yr(`Expected first argument to be of type array or string, but found ${ne(Ft(i))} instead.`);
          if (this.endIndex) {
            const a = this.endIndex.evaluate(e);
            return i.slice(n, a);
          }
          return i.slice(n);
        }
        eachChild(e) {
          e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          if (this.endIndex != null && this.endIndex !== void 0) {
            const e = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), e];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      var sn = Vi;
      function Ki(t, e) {
        return t === "==" || t === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
      }
      function ir(t, e, i, n) {
        return n.compare(e, i) === 0;
      }
      function Ir(t, e, i) {
        const n = t !== "==" && t !== "!=";
        return class R_ {
          constructor(c, h, p) {
            this.type = Ht, this.lhs = c, this.rhs = h, this.collator = p, this.hasUntypedArgument = c.type.kind === "value" || h.type.kind === "value";
          }
          static parse(c, h) {
            if (c.length !== 3 && c.length !== 4) return h.error("Expected two or three arguments.");
            const p = c[0];
            let m = h.parse(c[1], 1, Gt);
            if (!m) return null;
            if (!Ki(p, m.type)) return h.concat(1).error(`"${p}" comparisons are not supported for type '${ne(m.type)}'.`);
            let _ = h.parse(c[2], 2, Gt);
            if (!_) return null;
            if (!Ki(p, _.type)) return h.concat(2).error(`"${p}" comparisons are not supported for type '${ne(_.type)}'.`);
            if (m.type.kind !== _.type.kind && m.type.kind !== "value" && _.type.kind !== "value") return h.error(`Cannot compare types '${ne(m.type)}' and '${ne(_.type)}'.`);
            n && (m.type.kind === "value" && _.type.kind !== "value" ? m = new xn(_.type, [m]) : m.type.kind !== "value" && _.type.kind === "value" && (_ = new xn(m.type, [_])));
            let v = null;
            if (c.length === 4) {
              if (m.type.kind !== "string" && _.type.kind !== "string" && m.type.kind !== "value" && _.type.kind !== "value") return h.error("Cannot use collator to compare non-string types.");
              if (v = h.parse(c[3], 3, y), !v) return null;
            }
            return new R_(m, _, v);
          }
          evaluate(c) {
            const h = this.lhs.evaluate(c), p = this.rhs.evaluate(c);
            if (n && this.hasUntypedArgument) {
              const m = Ft(h), _ = Ft(p);
              if (m.kind !== _.kind || m.kind !== "string" && m.kind !== "number") throw new yr(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${m.kind}, ${_.kind}) instead.`);
            }
            if (this.collator && !n && this.hasUntypedArgument) {
              const m = Ft(h), _ = Ft(p);
              if (m.kind !== "string" || _.kind !== "string") return e(c, h, p);
            }
            return this.collator ? i(c, h, p, this.collator.evaluate(c)) : e(c, h, p);
          }
          eachChild(c) {
            c(this.lhs), c(this.rhs), this.collator && c(this.collator);
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            const c = [t];
            return this.eachChild((h) => {
              c.push(h.serialize());
            }), c;
          }
        };
      }
      const Jn = Ir("==", function(t, e, i) {
        return e === i;
      }, ir), Pr = Ir("!=", function(t, e, i) {
        return e !== i;
      }, function(t, e, i, n) {
        return !ir(0, e, i, n);
      }), Yn = Ir("<", function(t, e, i) {
        return e < i;
      }, function(t, e, i, n) {
        return n.compare(e, i) < 0;
      }), hs = Ir(">", function(t, e, i) {
        return e > i;
      }, function(t, e, i, n) {
        return n.compare(e, i) > 0;
      }), sa = Ir("<=", function(t, e, i) {
        return e <= i;
      }, function(t, e, i, n) {
        return n.compare(e, i) <= 0;
      }), Fo = Ir(">=", function(t, e, i) {
        return e >= i;
      }, function(t, e, i, n) {
        return n.compare(e, i) >= 0;
      });
      class vo {
        constructor(e, i, n, a, c, h) {
          this.type = Jt, this.number = e, this.locale = i, this.currency = n, this.unit = a, this.minFractionDigits = c, this.maxFractionDigits = h;
        }
        static parse(e, i) {
          if (e.length !== 3) return i.error("Expected two arguments.");
          const n = i.parse(e[1], 1, st);
          if (!n) return null;
          const a = e[2];
          if (typeof a != "object" || Array.isArray(a)) return i.error("NumberFormat options argument must be an object.");
          let c = null;
          if (a.locale && (c = i.parse(a.locale, 1, Jt), !c)) return null;
          let h = null;
          if (a.currency && (h = i.parse(a.currency, 1, Jt), !h)) return null;
          let p = null;
          if (a.unit && (p = i.parse(a.unit, 1, Jt), !p)) return null;
          let m = null;
          if (a["min-fraction-digits"] && (m = i.parse(a["min-fraction-digits"], 1, st), !m)) return null;
          let _ = null;
          return a["max-fraction-digits"] && (_ = i.parse(a["max-fraction-digits"], 1, st), !_) ? null : new vo(n, c, h, p, m, _);
        }
        evaluate(e) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, unit: this.unit ? this.unit.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
        }
        eachChild(e) {
          e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.unit && e(this.unit), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = {};
          return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.unit && (e.unit = this.unit.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e];
        }
      }
      class Uo {
        constructor(e) {
          this.type = st, this.input = e;
        }
        static parse(e, i) {
          if (e.length !== 2) return i.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
          const n = i.parse(e[1], 1);
          return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? i.error(`Expected argument of type string or array, but found ${ne(n.type)} instead.`) : new Uo(n) : null;
        }
        evaluate(e) {
          const i = this.input.evaluate(e);
          if (typeof i == "string" || Array.isArray(i)) return i.length;
          throw new yr(`Expected value to be of type string or array, but found ${ne(Ft(i))} instead.`);
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = ["length"];
          return this.eachChild((i) => {
            e.push(i.serialize());
          }), e;
        }
      }
      const Ml = { "==": Jn, "!=": Pr, ">": hs, "<": Yn, ">=": Fo, "<=": sa, array: xn, at: Sl, boolean: xn, case: Wi, coalesce: oa, collator: Cs, format: Zn, image: Ms, in: ye, "index-of": ht, interpolate: Kr, "interpolate-hcl": Kr, "interpolate-lab": Kr, length: Uo, let: ja, literal: Ar, match: Ni, number: xn, "number-format": vo, object: xn, slice: sn, step: Ls, string: xn, "to-boolean": ns, "to-color": ns, "to-number": ns, "to-string": ns, var: wl, within: _o };
      function Cl(t, [e, i, n, a]) {
        e = e.evaluate(t), i = i.evaluate(t), n = n.evaluate(t);
        const c = a ? a.evaluate(t) : 1, h = Js(e, i, n, c);
        if (h) throw new yr(h);
        return new De(e / 255 * c, i / 255 * c, n / 255 * c, c);
      }
      function ci(t, e) {
        return t in e;
      }
      function _i(t, e) {
        const i = e[t];
        return i === void 0 ? null : i;
      }
      function Lr(t) {
        return { type: t };
      }
      qn.register(Ml, { error: [{ kind: "error" }, [Jt], (t, [e]) => {
        throw new yr(e.evaluate(t));
      }], typeof: [Jt, [Gt], (t, [e]) => ne(Ft(e.evaluate(t)))], "to-rgba": [Y(st, 4), [Xr], (t, [e]) => e.evaluate(t).toArray()], rgb: [Xr, [st, st, st], Cl], rgba: [Xr, [st, st, st, st], Cl], has: { type: Ht, overloads: [[[Jt], (t, [e]) => ci(e.evaluate(t), t.properties())], [[Jt, yn], (t, [e, i]) => ci(e.evaluate(t), i.evaluate(t))]] }, get: { type: Gt, overloads: [[[Jt], (t, [e]) => _i(e.evaluate(t), t.properties())], [[Jt, yn], (t, [e, i]) => _i(e.evaluate(t), i.evaluate(t))]] }, "feature-state": [Gt, [Jt], (t, [e]) => _i(e.evaluate(t), t.featureState || {})], properties: [yn, [], (t) => t.properties()], "geometry-type": [Jt, [], (t) => t.geometryType()], id: [Gt, [], (t) => t.id()], zoom: [st, [], (t) => t.globals.zoom], pitch: [st, [], (t) => t.globals.pitch || 0], "distance-from-center": [st, [], (t) => t.distanceFromCenter()], "heatmap-density": [st, [], (t) => t.globals.heatmapDensity || 0], "line-progress": [st, [], (t) => t.globals.lineProgress || 0], "sky-radial-progress": [st, [], (t) => t.globals.skyRadialProgress || 0], accumulated: [Gt, [], (t) => t.globals.accumulated === void 0 ? null : t.globals.accumulated], "+": [st, Lr(st), (t, e) => {
        let i = 0;
        for (const n of e) i += n.evaluate(t);
        return i;
      }], "*": [st, Lr(st), (t, e) => {
        let i = 1;
        for (const n of e) i *= n.evaluate(t);
        return i;
      }], "-": { type: st, overloads: [[[st, st], (t, [e, i]) => e.evaluate(t) - i.evaluate(t)], [[st], (t, [e]) => -e.evaluate(t)]] }, "/": [st, [st, st], (t, [e, i]) => e.evaluate(t) / i.evaluate(t)], "%": [st, [st, st], (t, [e, i]) => e.evaluate(t) % i.evaluate(t)], ln2: [st, [], () => Math.LN2], pi: [st, [], () => Math.PI], e: [st, [], () => Math.E], "^": [st, [st, st], (t, [e, i]) => Math.pow(e.evaluate(t), i.evaluate(t))], sqrt: [st, [st], (t, [e]) => Math.sqrt(e.evaluate(t))], log10: [st, [st], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10], ln: [st, [st], (t, [e]) => Math.log(e.evaluate(t))], log2: [st, [st], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2], sin: [st, [st], (t, [e]) => Math.sin(e.evaluate(t))], cos: [st, [st], (t, [e]) => Math.cos(e.evaluate(t))], tan: [st, [st], (t, [e]) => Math.tan(e.evaluate(t))], asin: [st, [st], (t, [e]) => Math.asin(e.evaluate(t))], acos: [st, [st], (t, [e]) => Math.acos(e.evaluate(t))], atan: [st, [st], (t, [e]) => Math.atan(e.evaluate(t))], min: [st, Lr(st), (t, e) => Math.min(...e.map((i) => i.evaluate(t)))], max: [st, Lr(st), (t, e) => Math.max(...e.map((i) => i.evaluate(t)))], abs: [st, [st], (t, [e]) => Math.abs(e.evaluate(t))], round: [st, [st], (t, [e]) => {
        const i = e.evaluate(t);
        return i < 0 ? -Math.round(-i) : Math.round(i);
      }], floor: [st, [st], (t, [e]) => Math.floor(e.evaluate(t))], ceil: [st, [st], (t, [e]) => Math.ceil(e.evaluate(t))], "filter-==": [Ht, [Jt, Gt], (t, [e, i]) => t.properties()[e.value] === i.value], "filter-id-==": [Ht, [Gt], (t, [e]) => t.id() === e.value], "filter-type-==": [Ht, [Jt], (t, [e]) => t.geometryType() === e.value], "filter-<": [Ht, [Jt, Gt], (t, [e, i]) => {
        const n = t.properties()[e.value], a = i.value;
        return typeof n == typeof a && n < a;
      }], "filter-id-<": [Ht, [Gt], (t, [e]) => {
        const i = t.id(), n = e.value;
        return typeof i == typeof n && i < n;
      }], "filter->": [Ht, [Jt, Gt], (t, [e, i]) => {
        const n = t.properties()[e.value], a = i.value;
        return typeof n == typeof a && n > a;
      }], "filter-id->": [Ht, [Gt], (t, [e]) => {
        const i = t.id(), n = e.value;
        return typeof i == typeof n && i > n;
      }], "filter-<=": [Ht, [Jt, Gt], (t, [e, i]) => {
        const n = t.properties()[e.value], a = i.value;
        return typeof n == typeof a && n <= a;
      }], "filter-id-<=": [Ht, [Gt], (t, [e]) => {
        const i = t.id(), n = e.value;
        return typeof i == typeof n && i <= n;
      }], "filter->=": [Ht, [Jt, Gt], (t, [e, i]) => {
        const n = t.properties()[e.value], a = i.value;
        return typeof n == typeof a && n >= a;
      }], "filter-id->=": [Ht, [Gt], (t, [e]) => {
        const i = t.id(), n = e.value;
        return typeof i == typeof n && i >= n;
      }], "filter-has": [Ht, [Gt], (t, [e]) => e.value in t.properties()], "filter-has-id": [Ht, [], (t) => t.id() !== null && t.id() !== void 0], "filter-type-in": [Ht, [Y(Jt)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0], "filter-id-in": [Ht, [Y(Gt)], (t, [e]) => e.value.indexOf(t.id()) >= 0], "filter-in-small": [Ht, [Jt, Y(Gt)], (t, [e, i]) => i.value.indexOf(t.properties()[e.value]) >= 0], "filter-in-large": [Ht, [Jt, Y(Gt)], (t, [e, i]) => function(n, a, c, h) {
        for (; c <= h; ) {
          const p = c + h >> 1;
          if (a[p] === n) return !0;
          a[p] > n ? h = p - 1 : c = p + 1;
        }
        return !1;
      }(t.properties()[e.value], i.value, 0, i.value.length - 1)], all: { type: Ht, overloads: [[[Ht, Ht], (t, [e, i]) => e.evaluate(t) && i.evaluate(t)], [Lr(Ht), (t, e) => {
        for (const i of e) if (!i.evaluate(t)) return !1;
        return !0;
      }]] }, any: { type: Ht, overloads: [[[Ht, Ht], (t, [e, i]) => e.evaluate(t) || i.evaluate(t)], [Lr(Ht), (t, e) => {
        for (const i of e) if (i.evaluate(t)) return !0;
        return !1;
      }]] }, "!": [Ht, [Ht], (t, [e]) => !e.evaluate(t)], "is-supported-script": [Ht, [Jt], (t, [e]) => {
        const i = t.globals && t.globals.isSupportedScript;
        return !i || i(e.evaluate(t));
      }], upcase: [Jt, [Jt], (t, [e]) => e.evaluate(t).toUpperCase()], downcase: [Jt, [Jt], (t, [e]) => e.evaluate(t).toLowerCase()], concat: [Jt, Lr(Gt), (t, e) => e.map((i) => rs(i.evaluate(t))).join("")], "resolved-locale": [Jt, [y], (t, [e]) => e.evaluate(t).resolvedLocale()] });
      var an = Ml;
      function aa(t) {
        return { result: "success", value: t };
      }
      function xr(t) {
        return { result: "error", value: t };
      }
      function Nr(t) {
        return t["property-type"] === "data-driven";
      }
      function wn(t) {
        return !!t.expression && t.expression.parameters.indexOf("zoom") > -1;
      }
      function bo(t) {
        return !!t.expression && t.expression.interpolated;
      }
      function ii(t) {
        return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : t === null ? "null" : typeof t;
      }
      function Ln(t) {
        return typeof t == "object" && t !== null && !Array.isArray(t);
      }
      function wo(t) {
        return t;
      }
      function Os(t, e) {
        const i = e.type === "color", n = t.stops && typeof t.stops[0][0] == "object", a = n || !(n || t.property !== void 0), c = t.type || (bo(e) ? "exponential" : "interval");
        if (i && ((t = Cr({}, t)).stops && (t.stops = t.stops.map((_) => [_[0], De.parse(_[1])])), t.default = De.parse(t.default ? t.default : e.default)), t.colorSpace && t.colorSpace !== "rgb" && !Kn[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`);
        let h, p, m;
        if (c === "exponential") h = ln;
        else if (c === "interval") h = No;
        else if (c === "categorical") {
          h = la, p = /* @__PURE__ */ Object.create(null);
          for (const _ of t.stops) p[_[0]] = _[1];
          m = typeof t.stops[0][0];
        } else {
          if (c !== "identity") throw new Error(`Unknown function type "${c}"`);
          h = Ga;
        }
        if (n) {
          const _ = {}, v = [];
          for (let C = 0; C < t.stops.length; C++) {
            const A = t.stops[C], z = A[0].zoom;
            _[z] === void 0 && (_[z] = { zoom: z, type: t.type, property: t.property, default: t.default, stops: [] }, v.push(z)), _[z].stops.push([A[0].value, A[1]]);
          }
          const w = [];
          for (const C of v) w.push([_[C].zoom, Os(_[C], e)]);
          const T = { name: "linear" };
          return { kind: "composite", interpolationType: T, interpolationFactor: Kr.interpolationFactor.bind(void 0, T), zoomStops: w.map((C) => C[0]), evaluate: ({ zoom: C }, A) => ln({ stops: w, base: t.base }, e, C).evaluate(C, A) };
        }
        if (a) {
          const _ = c === "exponential" ? { name: "exponential", base: t.base !== void 0 ? t.base : 1 } : null;
          return { kind: "camera", interpolationType: _, interpolationFactor: Kr.interpolationFactor.bind(void 0, _), zoomStops: t.stops.map((v) => v[0]), evaluate: ({ zoom: v }) => h(t, e, v, p, m) };
        }
        return { kind: "source", evaluate(_, v) {
          const w = v && v.properties ? v.properties[t.property] : void 0;
          return w === void 0 ? Qn(t.default, e.default) : h(t, e, w, p, m);
        } };
      }
      function Qn(t, e, i) {
        return t !== void 0 ? t : e !== void 0 ? e : i !== void 0 ? i : void 0;
      }
      function la(t, e, i, n, a) {
        return Qn(typeof i === a ? n[i] : void 0, t.default, e.default);
      }
      function No(t, e, i) {
        if (ii(i) !== "number") return Qn(t.default, e.default);
        const n = t.stops.length;
        if (n === 1 || i <= t.stops[0][0]) return t.stops[0][1];
        if (i >= t.stops[n - 1][0]) return t.stops[n - 1][1];
        const a = ra(t.stops.map((c) => c[0]), i);
        return t.stops[a][1];
      }
      function ln(t, e, i) {
        const n = t.base !== void 0 ? t.base : 1;
        if (ii(i) !== "number") return Qn(t.default, e.default);
        const a = t.stops.length;
        if (a === 1 || i <= t.stops[0][0]) return t.stops[0][1];
        if (i >= t.stops[a - 1][0]) return t.stops[a - 1][1];
        const c = ra(t.stops.map((v) => v[0]), i), h = function(v, w, T, C) {
          const A = C - T, z = v - T;
          return A === 0 ? 0 : w === 1 ? z / A : (Math.pow(w, z) - 1) / (Math.pow(w, A) - 1);
        }(i, n, t.stops[c][0], t.stops[c + 1][0]), p = t.stops[c][1], m = t.stops[c + 1][1];
        let _ = Hr[e.type] || wo;
        if (t.colorSpace && t.colorSpace !== "rgb") {
          const v = Kn[t.colorSpace];
          _ = (w, T) => v.reverse(v.interpolate(v.forward(w), v.forward(T), h));
        }
        return typeof p.evaluate == "function" ? { evaluate(...v) {
          const w = p.evaluate.apply(void 0, v), T = m.evaluate.apply(void 0, v);
          if (w !== void 0 && T !== void 0) return _(w, T, h);
        } } : _(p, m, h);
      }
      function Ga(t, e, i) {
        return e.type === "color" ? i = De.parse(i) : e.type === "formatted" ? i = yi.fromString(i.toString()) : e.type === "resolvedImage" ? i = xi.fromString(i.toString()) : ii(i) === e.type || e.type === "enum" && e.values[i] || (i = void 0), Qn(i, t.default, e.default);
      }
      class jo {
        constructor(e, i) {
          this.expression = e, this._warningHistory = {}, this._evaluator = new ea(), this._defaultValue = i ? function(n) {
            return n.type === "color" && (Ln(n.default) || Array.isArray(n.default)) ? new De(0, 0, 0, 0) : n.type === "color" ? De.parse(n.default) || null : n.default === void 0 ? null : n.default;
          }(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null;
        }
        evaluateWithoutErrorHandling(e, i, n, a, c, h, p, m) {
          return this._evaluator.globals = e, this._evaluator.feature = i, this._evaluator.featureState = n, this._evaluator.canonical = a || null, this._evaluator.availableImages = c || null, this._evaluator.formattedSection = h, this._evaluator.featureTileCoord = p || null, this._evaluator.featureDistanceData = m || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(e, i, n, a, c, h, p, m) {
          this._evaluator.globals = e, this._evaluator.feature = i || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a || null, this._evaluator.availableImages = c || null, this._evaluator.formattedSection = h || null, this._evaluator.featureTileCoord = p || null, this._evaluator.featureDistanceData = m || null;
          try {
            const _ = this.expression.evaluate(this._evaluator);
            if (_ == null || typeof _ == "number" && _ != _) return this._defaultValue;
            if (this._enumValues && !(_ in this._enumValues)) throw new yr(`Expected value to be one of ${Object.keys(this._enumValues).map((v) => JSON.stringify(v)).join(", ")}, but found ${JSON.stringify(_)} instead.`);
            return _;
          } catch (_) {
            return this._warningHistory[_.message] || (this._warningHistory[_.message] = !0, typeof console < "u" && console.warn(_.message)), this._defaultValue;
          }
        }
      }
      function eo(t) {
        return Array.isArray(t) && t.length > 0 && typeof t[0] == "string" && t[0] in an;
      }
      function ca(t, e) {
        const i = new Oa(an, [], e ? function(a) {
          const c = { color: Xr, string: Jt, number: st, enum: Jt, boolean: Ht, formatted: E, resolvedImage: O };
          return a.type === "array" ? Y(c[a.value] || Gt, a.length) : c[a.type];
        }(e) : void 0), n = i.parse(t, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return n ? aa(new jo(n, e)) : xr(i.errors);
      }
      class fc {
        constructor(e, i) {
          this.kind = e, this._styleExpression = i, this.isStateDependent = e !== "constant" && !bn(i.expression);
        }
        evaluateWithoutErrorHandling(e, i, n, a, c, h) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, i, n, a, c, h);
        }
        evaluate(e, i, n, a, c, h) {
          return this._styleExpression.evaluate(e, i, n, a, c, h);
        }
      }
      class $a {
        constructor(e, i, n, a) {
          this.kind = e, this.zoomStops = n, this._styleExpression = i, this.isStateDependent = e !== "camera" && !bn(i.expression), this.interpolationType = a;
        }
        evaluateWithoutErrorHandling(e, i, n, a, c, h) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, i, n, a, c, h);
        }
        evaluate(e, i, n, a, c, h) {
          return this._styleExpression.evaluate(e, i, n, a, c, h);
        }
        interpolationFactor(e, i, n) {
          return this.interpolationType ? Kr.interpolationFactor(this.interpolationType, e, i, n) : 0;
        }
      }
      function Za(t, e) {
        if ((t = ca(t, e)).result === "error") return t;
        const i = t.value.expression, n = go(i);
        if (!n && !Nr(e)) return xr([new Pn("", "data expressions not supported")]);
        const a = Xn(i, ["zoom", "pitch", "distance-from-center"]);
        if (!a && !wn(e)) return xr([new Pn("", "zoom expressions not supported")]);
        const c = Il(i);
        return c || a ? c instanceof Pn ? xr([c]) : c instanceof Kr && !bo(e) ? xr([new Pn("", '"interpolate" expressions cannot be used with this property')]) : aa(c ? new $a(n ? "camera" : "composite", t.value, c.labels, c instanceof Kr ? c.interpolation : void 0) : new fc(n ? "constant" : "source", t.value)) : xr([new Pn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class Al {
        constructor(e, i) {
          this._parameters = e, this._specification = i, Cr(this, Os(this._parameters, this._specification));
        }
        static deserialize(e) {
          return new Al(e._parameters, e._specification);
        }
        static serialize(e) {
          return { _parameters: e._parameters, _specification: e._specification };
        }
      }
      function Il(t) {
        let e = null;
        if (t instanceof ja) e = Il(t.result);
        else if (t instanceof oa) {
          for (const i of t.args) if (e = Il(i), e) break;
        } else (t instanceof Ls || t instanceof Kr) && t.input instanceof qn && t.input.name === "zoom" && (e = t);
        return e instanceof Pn || t.eachChild((i) => {
          const n = Il(i);
          n instanceof Pn ? e = n : !e && n ? e = new Pn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && n && e !== n && (e = new Pn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e;
      }
      class pt {
        constructor(e, i, n, a) {
          this.message = (e ? `${e}: ` : "") + n, a && (this.identifier = a), i != null && i.__line__ && (this.line = i.__line__);
        }
      }
      function to(t) {
        const e = t.key, i = t.value, n = t.valueSpec || {}, a = t.objectElementValidators || {}, c = t.style, h = t.styleSpec;
        let p = [];
        const m = ii(i);
        if (m !== "object") return [new pt(e, i, `object expected, ${m} found`)];
        for (const _ in i) {
          const v = _.split(".")[0];
          let w;
          a[v] ? w = a[v] : n[v] ? w = jr : a["*"] ? w = a["*"] : n["*"] && (w = jr), w ? p = p.concat(w({ key: (e && `${e}.`) + _, value: i[_], valueSpec: n[v] || n["*"], style: c, styleSpec: h, object: i, objectKey: _ }, i)) : p.push(new pt(e, i[_], `unknown property "${_}"`));
        }
        for (const _ in n) a[_] || n[_].required && n[_].default === void 0 && i[_] === void 0 && p.push(new pt(e, i, `missing required property "${_}"`));
        return p;
      }
      function _u(t) {
        const e = t.value, i = t.valueSpec, n = t.style, a = t.styleSpec, c = t.key, h = t.arrayElementValidator || jr;
        if (ii(e) !== "array") return [new pt(c, e, `array expected, ${ii(e)} found`)];
        if (i.length && e.length !== i.length) return [new pt(c, e, `array length ${i.length} expected, length ${e.length} found`)];
        if (i["min-length"] && e.length < i["min-length"]) return [new pt(c, e, `array length at least ${i["min-length"]} expected, length ${e.length} found`)];
        let p = { type: i.value, values: i.values, minimum: i.minimum, maximum: i.maximum, function: void 0 };
        a.$version < 7 && (p.function = i.function), ii(i.value) === "object" && (p = i.value);
        let m = [];
        for (let _ = 0; _ < e.length; _++) m = m.concat(h({ array: e, arrayIndex: _, value: e[_], valueSpec: p, style: n, styleSpec: a, key: `${c}[${_}]` }));
        return m;
      }
      function qa(t) {
        const e = t.key, i = t.value, n = t.valueSpec;
        let a = ii(i);
        if (a === "number" && i != i && (a = "NaN"), a !== "number") return [new pt(e, i, `number expected, ${a} found`)];
        if ("minimum" in n) {
          let c = n.minimum;
          if (ii(n.minimum) === "array" && (c = n.minimum[t.arrayIndex]), i < c) return [new pt(e, i, `${i} is less than the minimum value ${c}`)];
        }
        if ("maximum" in n) {
          let c = n.maximum;
          if (ii(n.maximum) === "array" && (c = n.maximum[t.arrayIndex]), i > c) return [new pt(e, i, `${i} is greater than the maximum value ${c}`)];
        }
        return [];
      }
      function Wa(t) {
        const e = t.valueSpec, i = Li(t.value.type);
        let n, a, c, h = {};
        const p = i !== "categorical" && t.value.property === void 0, m = !p, _ = ii(t.value.stops) === "array" && ii(t.value.stops[0]) === "array" && ii(t.value.stops[0][0]) === "object", v = to({ key: t.key, value: t.value, valueSpec: t.styleSpec.function, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { stops: function(C) {
          if (i === "identity") return [new pt(C.key, C.value, 'identity function may not have a "stops" property')];
          let A = [];
          const z = C.value;
          return A = A.concat(_u({ key: C.key, value: z, valueSpec: C.valueSpec, style: C.style, styleSpec: C.styleSpec, arrayElementValidator: w })), ii(z) === "array" && z.length === 0 && A.push(new pt(C.key, z, "array must have at least one stop")), A;
        }, default: function(C) {
          return jr({ key: C.key, value: C.value, valueSpec: e, style: C.style, styleSpec: C.styleSpec });
        } } });
        return i === "identity" && p && v.push(new pt(t.key, t.value, 'missing required property "property"')), i === "identity" || t.value.stops || v.push(new pt(t.key, t.value, 'missing required property "stops"')), i === "exponential" && t.valueSpec.expression && !bo(t.valueSpec) && v.push(new pt(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (m && !Nr(t.valueSpec) ? v.push(new pt(t.key, t.value, "property functions not supported")) : p && !wn(t.valueSpec) && v.push(new pt(t.key, t.value, "zoom functions not supported"))), i !== "categorical" && !_ || t.value.property !== void 0 || v.push(new pt(t.key, t.value, '"property" property is required')), v;
        function w(C) {
          let A = [];
          const z = C.value, U = C.key;
          if (ii(z) !== "array") return [new pt(U, z, `array expected, ${ii(z)} found`)];
          if (z.length !== 2) return [new pt(U, z, `array length 2 expected, length ${z.length} found`)];
          if (_) {
            if (ii(z[0]) !== "object") return [new pt(U, z, `object expected, ${ii(z[0])} found`)];
            if (z[0].zoom === void 0) return [new pt(U, z, "object stop key must have zoom")];
            if (z[0].value === void 0) return [new pt(U, z, "object stop key must have value")];
            const q = Li(z[0].zoom);
            if (typeof q != "number") return [new pt(U, z[0].zoom, "stop zoom values must be numbers")];
            if (c && c > q) return [new pt(U, z[0].zoom, "stop zoom values must appear in ascending order")];
            q !== c && (c = q, a = void 0, h = {}), A = A.concat(to({ key: `${U}[0]`, value: z[0], valueSpec: { zoom: {} }, style: C.style, styleSpec: C.styleSpec, objectElementValidators: { zoom: qa, value: T } }));
          } else A = A.concat(T({ key: `${U}[0]`, value: z[0], valueSpec: {}, style: C.style, styleSpec: C.styleSpec }, z));
          return eo(lr(z[1])) ? A.concat([new pt(`${U}[1]`, z[1], "expressions are not allowed in function stops.")]) : A.concat(jr({ key: `${U}[1]`, value: z[1], valueSpec: e, style: C.style, styleSpec: C.styleSpec }));
        }
        function T(C, A) {
          const z = ii(C.value), U = Li(C.value), q = C.value !== null ? C.value : A;
          if (n) {
            if (z !== n) return [new pt(C.key, q, `${z} stop domain type must match previous stop domain type ${n}`)];
          } else n = z;
          if (z !== "number" && z !== "string" && z !== "boolean" && typeof U != "number" && typeof U != "string" && typeof U != "boolean") return [new pt(C.key, q, "stop domain value must be a number, string, or boolean")];
          if (z !== "number" && i !== "categorical") {
            let ie = `number expected, ${z} found`;
            return Nr(e) && i === void 0 && (ie += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new pt(C.key, q, ie)];
          }
          return i !== "categorical" || z !== "number" || typeof U == "number" && isFinite(U) && Math.floor(U) === U ? i !== "categorical" && z === "number" && typeof U == "number" && typeof a == "number" && a !== void 0 && U < a ? [new pt(C.key, q, "stop domain values must appear in ascending order")] : (a = U, i === "categorical" && U in h ? [new pt(C.key, q, "stop domain values must be unique")] : (h[U] = !0, [])) : [new pt(C.key, q, `integer expected, found ${String(U)}`)];
        }
      }
      function Tr(t) {
        const e = (t.expressionContext === "property" ? Za : ca)(lr(t.value), t.valueSpec);
        if (e.result === "error") return e.value.map((n) => new pt(`${t.key}${n.key}`, t.value, n.message));
        const i = e.value.expression || e.value._styleExpression.expression;
        if (t.expressionContext === "property" && t.propertyKey === "text-font" && !i.outputDefined()) return [new pt(t.key, t.value, `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (t.expressionContext === "property" && t.propertyType === "layout" && !bn(i)) return [new pt(t.key, t.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (t.expressionContext === "filter") return Xa(i, t);
        if (t.expressionContext && t.expressionContext.indexOf("cluster") === 0) {
          if (!Xn(i, ["zoom", "feature-state"])) return [new pt(t.key, t.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (t.expressionContext === "cluster-initial" && !go(i)) return [new pt(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Xa(t, e) {
        const i = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (e.valueSpec && e.valueSpec.expression) for (const a of e.valueSpec.expression.parameters) i.delete(a);
        if (i.size === 0) return [];
        const n = [];
        return t instanceof qn && i.has(t.name) ? [new pt(e.key, e.value, `["${t.name}"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)] : (t.eachChild((a) => {
          n.push(...Xa(a, e));
        }), n);
      }
      function Pl(t) {
        const e = t.key, i = t.value, n = t.valueSpec, a = [];
        return Array.isArray(n.values) ? n.values.indexOf(Li(i)) === -1 && a.push(new pt(e, i, `expected one of [${n.values.join(", ")}], ${JSON.stringify(i)} found`)) : Object.keys(n.values).indexOf(Li(i)) === -1 && a.push(new pt(e, i, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(i)} found`)), a;
      }
      function mc(t) {
        if (t === !0 || t === !1) return !0;
        if (!Array.isArray(t) || t.length === 0) return !1;
        switch (t[0]) {
          case "has":
            return t.length >= 2 && t[1] !== "$id" && t[1] !== "$type";
          case "in":
            return t.length >= 3 && (typeof t[1] != "string" || Array.isArray(t[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return t.length !== 3 || Array.isArray(t[1]) || Array.isArray(t[2]);
          case "any":
          case "all":
            for (const e of t.slice(1)) if (!mc(e) && typeof e != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      function Ll(t, e = "fill") {
        if (t == null) return { filter: () => !0, needGeometry: !1, needFeature: !1 };
        mc(t) || (t = ha(t));
        const i = t;
        let n = !0;
        try {
          n = function(_) {
            if (!ua(_)) return _;
            let v = lr(_);
            return zl(v), v = gu(v), v;
          }(i);
        } catch {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(i, null, 2)}
        `);
        }
        const a = Pe[`filter_${e}`], c = ca(n, a);
        let h = null;
        if (c.result === "error") throw new Error(c.value.map((_) => `${_.key}: ${_.message}`).join(", "));
        h = (_, v, w) => c.value.evaluate(_, v, {}, w);
        let p = null, m = null;
        if (n !== i) {
          const _ = ca(i, a);
          if (_.result === "error") throw new Error(_.value.map((v) => `${v.key}: ${v.message}`).join(", "));
          p = (v, w, T, C, A) => _.value.evaluate(v, w, {}, T, void 0, void 0, C, A), m = !go(_.value.expression);
        }
        return { filter: h, dynamicFilter: p || void 0, needGeometry: yu(n), needFeature: !!m };
      }
      function gu(t) {
        if (!Array.isArray(t)) return t;
        const e = function(i) {
          if (_c.has(i[0])) {
            for (let n = 1; n < i.length; n++) if (ua(i[n])) return !0;
          }
          return i;
        }(t);
        return e === !0 ? e : e.map((i) => gu(i));
      }
      function zl(t) {
        let e = !1;
        const i = [];
        if (t[0] === "case") {
          for (let n = 1; n < t.length - 1; n += 2) e = e || ua(t[n]), i.push(t[n + 1]);
          i.push(t[t.length - 1]);
        } else if (t[0] === "match") {
          e = e || ua(t[1]);
          for (let n = 2; n < t.length - 1; n += 2) i.push(t[n + 1]);
          i.push(t[t.length - 1]);
        } else if (t[0] === "step") {
          e = e || ua(t[1]);
          for (let n = 1; n < t.length - 1; n += 2) i.push(t[n + 1]);
        }
        e && (t.length = 0, t.push("any", ...i));
        for (let n = 1; n < t.length; n++) zl(t[n]);
      }
      function ua(t) {
        if (!Array.isArray(t)) return !1;
        if ((e = t[0]) === "pitch" || e === "distance-from-center") return !0;
        var e;
        for (let i = 1; i < t.length; i++) if (ua(t[i])) return !0;
        return !1;
      }
      const _c = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function Ah(t, e) {
        return t < e ? -1 : t > e ? 1 : 0;
      }
      function yu(t) {
        if (!Array.isArray(t)) return !1;
        if (t[0] === "within") return !0;
        for (let e = 1; e < t.length; e++) if (yu(t[e])) return !0;
        return !1;
      }
      function ha(t) {
        if (!t) return !0;
        const e = t[0];
        return t.length <= 1 ? e !== "any" : e === "==" ? gc(t[1], t[2], "==") : e === "!=" ? kl(gc(t[1], t[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? gc(t[1], t[2], e) : e === "any" ? (i = t.slice(1), ["any"].concat(i.map(ha))) : e === "all" ? ["all"].concat(t.slice(1).map(ha)) : e === "none" ? ["all"].concat(t.slice(1).map(ha).map(kl)) : e === "in" ? yc(t[1], t.slice(2)) : e === "!in" ? kl(yc(t[1], t.slice(2))) : e === "has" ? xc(t[1]) : e === "!has" ? kl(xc(t[1])) : e !== "within" || t;
        var i;
      }
      function gc(t, e, i) {
        switch (t) {
          case "$type":
            return [`filter-type-${i}`, e];
          case "$id":
            return [`filter-id-${i}`, e];
          default:
            return [`filter-${i}`, t, e];
        }
      }
      function yc(t, e) {
        if (e.length === 0) return !1;
        switch (t) {
          case "$type":
            return ["filter-type-in", ["literal", e]];
          case "$id":
            return ["filter-id-in", ["literal", e]];
          default:
            return e.length > 200 && !e.some((i) => typeof i != typeof e[0]) ? ["filter-in-large", t, ["literal", e.sort(Ah)]] : ["filter-in-small", t, ["literal", e]];
        }
      }
      function xc(t) {
        switch (t) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t];
        }
      }
      function kl(t) {
        return ["!", t];
      }
      function Ha(t) {
        return mc(lr(t.value)) ? Tr(Cr({}, t, { expressionContext: "filter", valueSpec: t.styleSpec[`filter_${t.layerType || "fill"}`] })) : Ka(t);
      }
      function Ka(t) {
        const e = t.value, i = t.key;
        if (ii(e) !== "array") return [new pt(i, e, `array expected, ${ii(e)} found`)];
        const n = t.styleSpec;
        let a, c = [];
        if (e.length < 1) return [new pt(i, e, "filter array must have at least 1 element")];
        switch (c = c.concat(Pl({ key: `${i}[0]`, value: e[0], valueSpec: n.filter_operator, style: t.style, styleSpec: t.styleSpec })), Li(e[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e.length >= 2 && Li(e[1]) === "$type" && c.push(new pt(i, e, `"$type" cannot be use with operator "${e[0]}"`));
          case "==":
          case "!=":
            e.length !== 3 && c.push(new pt(i, e, `filter array for operator "${e[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e.length >= 2 && (a = ii(e[1]), a !== "string" && c.push(new pt(`${i}[1]`, e[1], `string expected, ${a} found`)));
            for (let h = 2; h < e.length; h++) a = ii(e[h]), Li(e[1]) === "$type" ? c = c.concat(Pl({ key: `${i}[${h}]`, value: e[h], valueSpec: n.geometry_type, style: t.style, styleSpec: t.styleSpec })) : a !== "string" && a !== "number" && a !== "boolean" && c.push(new pt(`${i}[${h}]`, e[h], `string, number, or boolean expected, ${a} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let h = 1; h < e.length; h++) c = c.concat(Ka({ key: `${i}[${h}]`, value: e[h], style: t.style, styleSpec: t.styleSpec }));
            break;
          case "has":
          case "!has":
            a = ii(e[1]), e.length !== 2 ? c.push(new pt(i, e, `filter array for "${e[0]}" operator must have 2 elements`)) : a !== "string" && c.push(new pt(`${i}[1]`, e[1], `string expected, ${a} found`));
            break;
          case "within":
            a = ii(e[1]), e.length !== 2 ? c.push(new pt(i, e, `filter array for "${e[0]}" operator must have 2 elements`)) : a !== "object" && c.push(new pt(`${i}[1]`, e[1], `object expected, ${a} found`));
        }
        return c;
      }
      function vc(t, e) {
        const i = t.key, n = t.style, a = t.styleSpec, c = t.value, h = t.objectKey, p = a[`${e}_${t.layerType}`];
        if (!p) return [];
        const m = h.match(/^(.*)-transition$/);
        if (e === "paint" && m && p[m[1]] && p[m[1]].transition) return jr({ key: i, value: c, valueSpec: a.transition, style: n, styleSpec: a });
        const _ = t.valueSpec || p[h];
        if (!_) return [new pt(i, c, `unknown property "${h}"`)];
        let v;
        if (ii(c) === "string" && Nr(_) && !_.tokens && (v = /^{([^}]+)}$/.exec(c))) {
          const T = `\`{ "type": "identity", "property": ${v ? JSON.stringify(v[1]) : '"_"'} }\``;
          return [new pt(i, c, `"${h}" does not support interpolation syntax
Use an identity property function instead: ${T}.`)];
        }
        const w = [];
        return t.layerType === "symbol" && (h === "text-field" && n && !n.glyphs && w.push(new pt(i, c, 'use of "text-field" requires a style "glyphs" property')), h === "text-font" && Ln(lr(c)) && Li(c.type) === "identity" && w.push(new pt(i, c, '"text-font" does not support identity functions'))), w.concat(jr({ key: t.key, value: c, valueSpec: _, style: n, styleSpec: a, expressionContext: "property", propertyType: e, propertyKey: h }));
      }
      function xu(t) {
        return vc(t, "paint");
      }
      function bc(t) {
        return vc(t, "layout");
      }
      function vu(t) {
        let e = [];
        const i = t.value, n = t.key, a = t.style, c = t.styleSpec;
        i.type || i.ref || e.push(new pt(n, i, 'either "type" or "ref" is required'));
        let h = Li(i.type);
        const p = Li(i.ref);
        if (i.id) {
          const m = Li(i.id);
          for (let _ = 0; _ < t.arrayIndex; _++) {
            const v = a.layers[_];
            Li(v.id) === m && e.push(new pt(n, i.id, `duplicate layer id "${i.id}", previously used at line ${v.id.__line__}`));
          }
        }
        if ("ref" in i) {
          let m;
          ["type", "source", "source-layer", "filter", "layout"].forEach((_) => {
            _ in i && e.push(new pt(n, i[_], `"${_}" is prohibited for ref layers`));
          }), a.layers.forEach((_) => {
            Li(_.id) === p && (m = _);
          }), m ? m.ref ? e.push(new pt(n, i.ref, "ref cannot reference another ref layer")) : h = Li(m.type) : typeof p == "string" && e.push(new pt(n, i.ref, `ref layer "${p}" not found`));
        } else if (h !== "background" && h !== "sky") if (i.source) {
          const m = a.sources && a.sources[i.source], _ = m && Li(m.type);
          m ? _ === "vector" && h === "raster" ? e.push(new pt(n, i.source, `layer "${i.id}" requires a raster source`)) : _ === "raster" && h !== "raster" ? e.push(new pt(n, i.source, `layer "${i.id}" requires a vector source`)) : _ !== "vector" || i["source-layer"] ? _ === "raster-dem" && h !== "hillshade" ? e.push(new pt(n, i.source, "raster-dem source can only be used with layer type 'hillshade'.")) : h !== "line" || !i.paint || !i.paint["line-gradient"] && !i.paint["line-trim-offset"] || _ === "geojson" && m.lineMetrics || e.push(new pt(n, i, `layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new pt(n, i, `layer "${i.id}" must specify a "source-layer"`)) : e.push(new pt(n, i.source, `source "${i.source}" not found`));
        } else e.push(new pt(n, i, 'missing required property "source"'));
        return e = e.concat(to({ key: n, value: i, valueSpec: c.layer, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": () => [], type: () => jr({ key: `${n}.type`, value: i.type, valueSpec: c.layer.type, style: t.style, styleSpec: t.styleSpec, object: i, objectKey: "type" }), filter: (m) => Ha(Cr({ layerType: h }, m)), layout: (m) => to({ layer: i, key: m.key, value: m.value, valueSpec: {}, style: m.style, styleSpec: m.styleSpec, objectElementValidators: { "*": (_) => bc(Cr({ layerType: h }, _)) } }), paint: (m) => to({ layer: i, key: m.key, value: m.value, valueSpec: {}, style: m.style, styleSpec: m.styleSpec, objectElementValidators: { "*": (_) => xu(Cr({ layerType: h }, _)) } }) } })), e;
      }
      function ds(t) {
        const e = t.value, i = t.key, n = ii(e);
        return n !== "string" ? [new pt(i, e, `string expected, ${n} found`)] : [];
      }
      const bu = { promoteId: function({ key: t, value: e }) {
        if (ii(e) === "string") return ds({ key: t, value: e });
        {
          const i = [];
          for (const n in e) i.push(...ds({ key: `${t}.${n}`, value: e[n] }));
          return i;
        }
      } };
      function wu(t) {
        const e = t.value, i = t.key, n = t.styleSpec, a = t.style;
        if (!e.type) return [new pt(i, e, '"type" is required')];
        const c = Li(e.type);
        let h;
        switch (c) {
          case "vector":
          case "raster":
          case "raster-dem":
            return h = to({ key: i, value: e, valueSpec: n[`source_${c.replace("-", "_")}`], style: t.style, styleSpec: n, objectElementValidators: bu }), h;
          case "geojson":
            if (h = to({ key: i, value: e, valueSpec: n.source_geojson, style: a, styleSpec: n, objectElementValidators: bu }), e.cluster) for (const p in e.clusterProperties) {
              const [m, _] = e.clusterProperties[p], v = typeof m == "string" ? [m, ["accumulated"], ["get", p]] : m;
              h.push(...Tr({ key: `${i}.${p}.map`, value: _, expressionContext: "cluster-map" })), h.push(...Tr({ key: `${i}.${p}.reduce`, value: v, expressionContext: "cluster-reduce" }));
            }
            return h;
          case "video":
            return to({ key: i, value: e, valueSpec: n.source_video, style: a, styleSpec: n });
          case "image":
            return to({ key: i, value: e, valueSpec: n.source_image, style: a, styleSpec: n });
          case "canvas":
            return [new pt(i, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Pl({ key: `${i}.type`, value: e.type, valueSpec: { values: Ih(n) }, style: a, styleSpec: n });
        }
      }
      function Ih(t) {
        return t.source.reduce((e, i) => {
          const n = t[i];
          return n.type.type === "enum" && (e = e.concat(Object.keys(n.type.values))), e;
        }, []);
      }
      function Tu(t) {
        const e = t.value, i = t.styleSpec, n = i.light, a = t.style;
        let c = [];
        const h = ii(e);
        if (e === void 0) return c;
        if (h !== "object") return c = c.concat([new pt("light", e, `object expected, ${h} found`)]), c;
        for (const p in e) {
          const m = p.match(/^(.*)-transition$/);
          c = c.concat(m && n[m[1]] && n[m[1]].transition ? jr({ key: p, value: e[p], valueSpec: i.transition, style: a, styleSpec: i }) : n[p] ? jr({ key: p, value: e[p], valueSpec: n[p], style: a, styleSpec: i }) : [new pt(p, e[p], `unknown property "${p}"`)]);
        }
        return c;
      }
      function wc(t) {
        const e = t.value, i = t.key, n = t.style, a = t.styleSpec, c = a.terrain;
        let h = [];
        const p = ii(e);
        if (e === void 0) return h;
        if (p !== "object") return h = h.concat([new pt("terrain", e, `object expected, ${p} found`)]), h;
        for (const m in e) {
          const _ = m.match(/^(.*)-transition$/);
          h = h.concat(_ && c[_[1]] && c[_[1]].transition ? jr({ key: m, value: e[m], valueSpec: a.transition, style: n, styleSpec: a }) : c[m] ? jr({ key: m, value: e[m], valueSpec: c[m], style: n, styleSpec: a }) : [new pt(m, e[m], `unknown property "${m}"`)]);
        }
        if (e.source) {
          const m = n.sources && n.sources[e.source], _ = m && Li(m.type);
          m ? _ !== "raster-dem" && h.push(new pt(i, e.source, `terrain cannot be used with a source of type ${String(_)}, it only be used with a "raster-dem" source type`)) : h.push(new pt(i, e.source, `source "${e.source}" not found`));
        } else h.push(new pt(i, e, 'terrain is missing required property "source"'));
        return h;
      }
      function Eu(t) {
        const e = t.value, i = t.style, n = t.styleSpec, a = n.fog;
        let c = [];
        const h = ii(e);
        if (e === void 0) return c;
        if (h !== "object") return c = c.concat([new pt("fog", e, `object expected, ${h} found`)]), c;
        for (const p in e) {
          const m = p.match(/^(.*)-transition$/);
          c = c.concat(m && a[m[1]] && a[m[1]].transition ? jr({ key: p, value: e[p], valueSpec: n.transition, style: i, styleSpec: n }) : a[p] ? jr({ key: p, value: e[p], valueSpec: a[p], style: i, styleSpec: n }) : [new pt(p, e[p], `unknown property "${p}"`)]);
        }
        return c;
      }
      const Su = { "*": () => [], array: _u, boolean: function(t) {
        const e = t.value, i = t.key, n = ii(e);
        return n !== "boolean" ? [new pt(i, e, `boolean expected, ${n} found`)] : [];
      }, number: qa, color: function(t) {
        const e = t.key, i = t.value, n = ii(i);
        return n !== "string" ? [new pt(e, i, `color expected, ${n} found`)] : dt(i) === null ? [new pt(e, i, `color expected, "${i}" found`)] : [];
      }, enum: Pl, filter: Ha, function: Wa, layer: vu, object: to, source: wu, light: Tu, terrain: wc, fog: Eu, string: ds, formatted: function(t) {
        return ds(t).length === 0 ? [] : Tr(t);
      }, resolvedImage: function(t) {
        return ds(t).length === 0 ? [] : Tr(t);
      }, projection: function(t) {
        const e = t.value, i = t.styleSpec, n = i.projection, a = t.style;
        let c = [];
        const h = ii(e);
        if (h === "object") for (const p in e) c = c.concat(jr({ key: p, value: e[p], valueSpec: n[p], style: a, styleSpec: i }));
        else h !== "string" && (c = c.concat([new pt("projection", e, `object or string expected, ${h} found`)]));
        return c;
      } };
      function jr(t) {
        const e = t.value, i = t.valueSpec, n = t.styleSpec;
        return i.expression && Ln(Li(e)) ? Wa(t) : i.expression && eo(lr(e)) ? Tr(t) : i.type && Su[i.type] ? Su[i.type](t) : to(Cr({}, t, { valueSpec: i.type ? n[i.type] : i }));
      }
      function Ph(t) {
        const e = t.value, i = t.key, n = ds(t);
        return n.length || (e.indexOf("{fontstack}") === -1 && n.push(new pt(i, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && n.push(new pt(i, e, '"glyphs" url must include a "{range}" token'))), n;
      }
      function Mu(t, e = Pe) {
        return zn(jr({ key: "", value: t, valueSpec: e.$root, styleSpec: e, style: t, objectElementValidators: { glyphs: Ph, "*": () => [] } }));
      }
      const Lh = (t) => zn(xu(t)), zh = (t) => zn(bc(t));
      function zn(t) {
        return t.slice().sort((e, i) => e.line && i.line ? e.line - i.line : 0);
      }
      function Cu(t, e) {
        let i = !1;
        if (e && e.length) for (const n of e) t.fire(new wr(new Error(n.message))), i = !0;
        return i;
      }
      var kh = To, io = 3;
      function To(t, e, i) {
        var n = this.cells = [];
        if (t instanceof ArrayBuffer) {
          this.arrayBuffer = t;
          var a = new Int32Array(this.arrayBuffer);
          t = a[0], this.d = (e = a[1]) + 2 * (i = a[2]);
          for (var c = 0; c < this.d * this.d; c++) {
            var h = a[io + c], p = a[io + c + 1];
            n.push(h === p ? null : a.subarray(h, p));
          }
          var m = a[io + n.length + 1];
          this.keys = a.subarray(a[io + n.length], m), this.bboxes = a.subarray(m), this.insert = this._insertReadonly;
        } else {
          this.d = e + 2 * i;
          for (var _ = 0; _ < this.d * this.d; _++) n.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = e, this.extent = t, this.padding = i, this.scale = e / t, this.uid = 0;
        var v = i / e * t;
        this.min = -v, this.max = t + v;
      }
      To.prototype.insert = function(t, e, i, n, a) {
        this._forEachCell(e, i, n, a, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(i), this.bboxes.push(n), this.bboxes.push(a);
      }, To.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, To.prototype._insertCell = function(t, e, i, n, a, c) {
        this.cells[a].push(c);
      }, To.prototype.query = function(t, e, i, n, a) {
        var c = this.min, h = this.max;
        if (t <= c && e <= c && h <= i && h <= n && !a) return Array.prototype.slice.call(this.keys);
        var p = [];
        return this._forEachCell(t, e, i, n, this._queryCell, p, {}, a), p;
      }, To.prototype._queryCell = function(t, e, i, n, a, c, h, p) {
        var m = this.cells[a];
        if (m !== null) for (var _ = this.keys, v = this.bboxes, w = 0; w < m.length; w++) {
          var T = m[w];
          if (h[T] === void 0) {
            var C = 4 * T;
            (p ? p(v[C + 0], v[C + 1], v[C + 2], v[C + 3]) : t <= v[C + 2] && e <= v[C + 3] && i >= v[C + 0] && n >= v[C + 1]) ? (h[T] = !0, c.push(_[T])) : h[T] = !1;
          }
        }
      }, To.prototype._forEachCell = function(t, e, i, n, a, c, h, p) {
        for (var m = this._convertToCellCoord(t), _ = this._convertToCellCoord(e), v = this._convertToCellCoord(i), w = this._convertToCellCoord(n), T = m; T <= v; T++) for (var C = _; C <= w; C++) {
          var A = this.d * C + T;
          if ((!p || p(this._convertFromCellCoord(T), this._convertFromCellCoord(C), this._convertFromCellCoord(T + 1), this._convertFromCellCoord(C + 1))) && a.call(this, t, e, i, n, A, c, h, p)) return;
        }
      }, To.prototype._convertFromCellCoord = function(t) {
        return (t - this.padding) / this.scale;
      }, To.prototype._convertToCellCoord = function(t) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
      }, To.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer) return this.arrayBuffer;
        for (var t = this.cells, e = io + this.cells.length + 1 + 1, i = 0, n = 0; n < this.cells.length; n++) i += this.cells[n].length;
        var a = new Int32Array(e + i + this.keys.length + this.bboxes.length);
        a[0] = this.extent, a[1] = this.n, a[2] = this.padding;
        for (var c = e, h = 0; h < t.length; h++) {
          var p = t[h];
          a[io + h] = c, a.set(p, c), c += p.length;
        }
        return a[io + t.length] = c, a.set(this.keys, c), a[io + t.length + 1] = c += this.keys.length, a.set(this.bboxes, c), c += this.bboxes.length, a.buffer;
      };
      var Bs = St(kh);
      const Dl = {};
      function _t(t, e, i = {}) {
        Object.defineProperty(t, "_classRegistryKey", { value: e, writeable: !1 }), Dl[e] = { klass: t, omit: i.omit || [] };
      }
      _t(Object, "Object"), Bs.serialize = function(t, e) {
        const i = t.toArrayBuffer();
        return e && e.push(i), { buffer: i };
      }, Bs.deserialize = function(t) {
        return new Bs(t.buffer);
      }, Object.defineProperty(Bs, "name", { value: "Grid" }), _t(Bs, "Grid"), _t(De, "Color"), _t(Error, "Error"), _t(co, "AJAXError"), _t(xi, "ResolvedImage"), _t(Al, "StylePropertyFunction"), _t(jo, "StyleExpression", { omit: ["_evaluator"] }), _t($a, "ZoomDependentExpression"), _t(fc, "ZoomConstantExpression"), _t(qn, "CompoundExpression", { omit: ["_evaluate"] });
      for (const t in an) Dl[an[t]._classRegistryKey] || _t(an[t], `Expression${t}`);
      function Tc(t) {
        return t && typeof ArrayBuffer < "u" && (t instanceof ArrayBuffer || t.constructor && t.constructor.name === "ArrayBuffer");
      }
      function Ec(t) {
        return re.ImageBitmap && t instanceof re.ImageBitmap;
      }
      function da(t, e) {
        if (t == null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;
        if (Tc(t) || Ec(t)) return e && e.push(t), t;
        if (ArrayBuffer.isView(t)) {
          const i = t;
          return e && e.push(i.buffer), i;
        }
        if (t instanceof re.ImageData) return e && e.push(t.data.buffer), t;
        if (Array.isArray(t)) {
          const i = [];
          for (const n of t) i.push(da(n, e));
          return i;
        }
        if (typeof t == "object") {
          const i = t.constructor, n = i._classRegistryKey;
          if (!n) throw new Error(`can't serialize object of unregistered class ${n}`);
          const a = i.serialize ? i.serialize(t, e) : {};
          if (!i.serialize) {
            for (const c in t) t.hasOwnProperty(c) && (Dl[n].omit.indexOf(c) >= 0 || (a[c] = da(t[c], e)));
            t instanceof Error && (a.message = t.message);
          }
          if (a.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (a.$name = n), a;
        }
        throw new Error("can't serialize object of type " + typeof t);
      }
      function Fs(t) {
        if (t == null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || Tc(t) || Ec(t) || ArrayBuffer.isView(t) || t instanceof re.ImageData) return t;
        if (Array.isArray(t)) return t.map(Fs);
        if (typeof t == "object") {
          const e = t.$name || "Object", { klass: i } = Dl[e];
          if (!i) throw new Error(`can't deserialize unregistered class ${e}`);
          if (i.deserialize) return i.deserialize(t);
          const n = Object.create(i.prototype);
          for (const a of Object.keys(t)) a !== "$name" && (n[a] = Fs(t[a]));
          return n;
        }
        throw new Error("can't deserialize object of type " + typeof t);
      }
      const ct = { "Latin-1 Supplement": (t) => t >= 128 && t <= 255, Arabic: (t) => t >= 1536 && t <= 1791, "Arabic Supplement": (t) => t >= 1872 && t <= 1919, "Arabic Extended-A": (t) => t >= 2208 && t <= 2303, "Hangul Jamo": (t) => t >= 4352 && t <= 4607, "Unified Canadian Aboriginal Syllabics": (t) => t >= 5120 && t <= 5759, Khmer: (t) => t >= 6016 && t <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t) => t >= 6320 && t <= 6399, "General Punctuation": (t) => t >= 8192 && t <= 8303, "Letterlike Symbols": (t) => t >= 8448 && t <= 8527, "Number Forms": (t) => t >= 8528 && t <= 8591, "Miscellaneous Technical": (t) => t >= 8960 && t <= 9215, "Control Pictures": (t) => t >= 9216 && t <= 9279, "Optical Character Recognition": (t) => t >= 9280 && t <= 9311, "Enclosed Alphanumerics": (t) => t >= 9312 && t <= 9471, "Geometric Shapes": (t) => t >= 9632 && t <= 9727, "Miscellaneous Symbols": (t) => t >= 9728 && t <= 9983, "Miscellaneous Symbols and Arrows": (t) => t >= 11008 && t <= 11263, "CJK Radicals Supplement": (t) => t >= 11904 && t <= 12031, "Kangxi Radicals": (t) => t >= 12032 && t <= 12255, "Ideographic Description Characters": (t) => t >= 12272 && t <= 12287, "CJK Symbols and Punctuation": (t) => t >= 12288 && t <= 12351, Hiragana: (t) => t >= 12352 && t <= 12447, Katakana: (t) => t >= 12448 && t <= 12543, Bopomofo: (t) => t >= 12544 && t <= 12591, "Hangul Compatibility Jamo": (t) => t >= 12592 && t <= 12687, Kanbun: (t) => t >= 12688 && t <= 12703, "Bopomofo Extended": (t) => t >= 12704 && t <= 12735, "CJK Strokes": (t) => t >= 12736 && t <= 12783, "Katakana Phonetic Extensions": (t) => t >= 12784 && t <= 12799, "Enclosed CJK Letters and Months": (t) => t >= 12800 && t <= 13055, "CJK Compatibility": (t) => t >= 13056 && t <= 13311, "CJK Unified Ideographs Extension A": (t) => t >= 13312 && t <= 19903, "Yijing Hexagram Symbols": (t) => t >= 19904 && t <= 19967, "CJK Unified Ideographs": (t) => t >= 19968 && t <= 40959, "Yi Syllables": (t) => t >= 40960 && t <= 42127, "Yi Radicals": (t) => t >= 42128 && t <= 42191, "Hangul Jamo Extended-A": (t) => t >= 43360 && t <= 43391, "Hangul Syllables": (t) => t >= 44032 && t <= 55215, "Hangul Jamo Extended-B": (t) => t >= 55216 && t <= 55295, "Private Use Area": (t) => t >= 57344 && t <= 63743, "CJK Compatibility Ideographs": (t) => t >= 63744 && t <= 64255, "Arabic Presentation Forms-A": (t) => t >= 64336 && t <= 65023, "Vertical Forms": (t) => t >= 65040 && t <= 65055, "CJK Compatibility Forms": (t) => t >= 65072 && t <= 65103, "Small Form Variants": (t) => t >= 65104 && t <= 65135, "Arabic Presentation Forms-B": (t) => t >= 65136 && t <= 65279, "Halfwidth and Fullwidth Forms": (t) => t >= 65280 && t <= 65519 };
      function Sc(t) {
        for (const e of t) if (Mc(e.charCodeAt(0))) return !0;
        return !1;
      }
      function Dh(t) {
        for (const e of t) if (!Au(e.charCodeAt(0))) return !1;
        return !0;
      }
      function Au(t) {
        return !(ct.Arabic(t) || ct["Arabic Supplement"](t) || ct["Arabic Extended-A"](t) || ct["Arabic Presentation Forms-A"](t) || ct["Arabic Presentation Forms-B"](t));
      }
      function Mc(t) {
        return !(t !== 746 && t !== 747 && (t < 4352 || !(ct["Bopomofo Extended"](t) || ct.Bopomofo(t) || ct["CJK Compatibility Forms"](t) && !(t >= 65097 && t <= 65103) || ct["CJK Compatibility Ideographs"](t) || ct["CJK Compatibility"](t) || ct["CJK Radicals Supplement"](t) || ct["CJK Strokes"](t) || !(!ct["CJK Symbols and Punctuation"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || t === 12336) || ct["CJK Unified Ideographs Extension A"](t) || ct["CJK Unified Ideographs"](t) || ct["Enclosed CJK Letters and Months"](t) || ct["Hangul Compatibility Jamo"](t) || ct["Hangul Jamo Extended-A"](t) || ct["Hangul Jamo Extended-B"](t) || ct["Hangul Jamo"](t) || ct["Hangul Syllables"](t) || ct.Hiragana(t) || ct["Ideographic Description Characters"](t) || ct.Kanbun(t) || ct["Kangxi Radicals"](t) || ct["Katakana Phonetic Extensions"](t) || ct.Katakana(t) && t !== 12540 || !(!ct["Halfwidth and Fullwidth Forms"](t) || t === 65288 || t === 65289 || t === 65293 || t >= 65306 && t <= 65310 || t === 65339 || t === 65341 || t === 65343 || t >= 65371 && t <= 65503 || t === 65507 || t >= 65512 && t <= 65519) || !(!ct["Small Form Variants"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || ct["Unified Canadian Aboriginal Syllabics"](t) || ct["Unified Canadian Aboriginal Syllabics Extended"](t) || ct["Vertical Forms"](t) || ct["Yijing Hexagram Symbols"](t) || ct["Yi Syllables"](t) || ct["Yi Radicals"](t))));
      }
      function Iu(t) {
        return !(Mc(t) || function(e) {
          return !!(ct["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || ct["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || ct["Letterlike Symbols"](e) || ct["Number Forms"](e) || ct["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || ct["Control Pictures"](e) && e !== 9251 || ct["Optical Character Recognition"](e) || ct["Enclosed Alphanumerics"](e) || ct["Geometric Shapes"](e) || ct["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || ct["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || ct["CJK Symbols and Punctuation"](e) || ct.Katakana(e) || ct["Private Use Area"](e) || ct["CJK Compatibility Forms"](e) || ct["Small Form Variants"](e) || ct["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533);
        }(t));
      }
      function Pu(t) {
        return t >= 1424 && t <= 2303 || ct["Arabic Presentation Forms-A"](t) || ct["Arabic Presentation Forms-B"](t);
      }
      function Rh(t, e) {
        return !(!e && Pu(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || ct.Khmer(t));
      }
      function Oh(t) {
        for (const e of t) if (Pu(e.charCodeAt(0))) return !0;
        return !1;
      }
      const Cc = "deferred", Ac = "loading", Ic = "loaded";
      let pa = null, l = "unavailable", r = null;
      const o = function(t) {
        t && typeof t == "string" && t.indexOf("NetworkError") > -1 && (l = "error"), pa && pa(t);
      };
      function u() {
        d.fire(new uo("pluginStateChange", { pluginStatus: l, pluginURL: r }));
      }
      const d = new Fr(), f = function() {
        return l;
      }, g = function() {
        if (l !== Cc || !r) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        l = Ac, u(), r && es({ url: r }, (t) => {
          t ? o(t) : (l = Ic, u());
        });
      }, x = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => l === Ic || x.applyArabicShaping != null, isLoading: () => l === Ac, setState(t) {
        l = t.pluginStatus, r = t.pluginURL;
      }, isParsed: () => x.applyArabicShaping != null && x.processBidirectionalText != null && x.processStyledBidirectionalText != null, getPluginURL: () => r };
      class b {
        constructor(e, i) {
          this.zoom = e, i ? (this.now = i.now, this.fadeDuration = i.fadeDuration, this.transition = i.transition, this.pitch = i.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
        }
        isSupportedScript(e) {
          return function(i, n) {
            for (const a of i) if (!Rh(a.charCodeAt(0), n)) return !1;
            return !0;
          }(e, x.isLoaded());
        }
      }
      class M {
        constructor(e, i) {
          this.property = e, this.value = i, this.expression = function(n, a) {
            if (Ln(n)) return new Al(n, a);
            if (eo(n)) {
              const c = Za(n, a);
              if (c.result === "error") throw new Error(c.value.map((h) => `${h.key}: ${h.message}`).join(", "));
              return c.value;
            }
            {
              let c = n;
              return typeof n == "string" && a.type === "color" && (c = De.parse(n)), { kind: "constant", evaluate: () => c };
            }
          }(i === void 0 ? e.specification.default : i, e.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(e, i, n) {
          return this.property.possiblyEvaluate(this, e, i, n);
        }
      }
      class S {
        constructor(e) {
          this.property = e, this.value = new M(e, void 0);
        }
        transitioned(e, i) {
          return new F(this.property, this.value, i, si({}, e.transition, this.transition), e.now);
        }
        untransitioned() {
          return new F(this.property, this.value, null, {}, 0);
        }
      }
      class P {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues);
        }
        getValue(e) {
          return qr(this._values[e].value.value);
        }
        setValue(e, i) {
          this._values.hasOwnProperty(e) || (this._values[e] = new S(this._values[e].property)), this._values[e].value = new M(this._values[e].property, i === null ? void 0 : qr(i));
        }
        getTransition(e) {
          return qr(this._values[e].transition);
        }
        setTransition(e, i) {
          this._values.hasOwnProperty(e) || (this._values[e] = new S(this._values[e].property)), this._values[e].transition = qr(i) || void 0;
        }
        serialize() {
          const e = {};
          for (const i of Object.keys(this._values)) {
            const n = this.getValue(i);
            n !== void 0 && (e[i] = n);
            const a = this.getTransition(i);
            a !== void 0 && (e[`${i}-transition`] = a);
          }
          return e;
        }
        transitioned(e, i) {
          const n = new j(this._properties);
          for (const a of Object.keys(this._values)) n._values[a] = this._values[a].transitioned(e, i._values[a]);
          return n;
        }
        untransitioned() {
          const e = new j(this._properties);
          for (const i of Object.keys(this._values)) e._values[i] = this._values[i].untransitioned();
          return e;
        }
      }
      class F {
        constructor(e, i, n, a, c) {
          const h = a.delay || 0, p = a.duration || 0;
          c = c || 0, this.property = e, this.value = i, this.begin = c + h, this.end = this.begin + p, e.specification.transition && (a.delay || a.duration) && (this.prior = n);
        }
        possiblyEvaluate(e, i, n) {
          const a = e.now || 0, c = this.value.possiblyEvaluate(e, i, n), h = this.prior;
          if (h) {
            if (a > this.end) return this.prior = null, c;
            if (this.value.isDataDriven()) return this.prior = null, c;
            if (a < this.begin) return h.possiblyEvaluate(e, i, n);
            {
              const p = (a - this.begin) / (this.end - this.begin);
              return this.property.interpolate(h.possiblyEvaluate(e, i, n), c, Fn(p));
            }
          }
          return c;
        }
      }
      class j {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(e, i, n) {
          const a = new Z(this._properties);
          for (const c of Object.keys(this._values)) a._values[c] = this._values[c].possiblyEvaluate(e, i, n);
          return a;
        }
        hasTransition() {
          for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
          return !1;
        }
      }
      class $ {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPropertyValues);
        }
        getValue(e) {
          return qr(this._values[e].value);
        }
        setValue(e, i) {
          this._values[e] = new M(this._values[e].property, i === null ? void 0 : qr(i));
        }
        serialize() {
          const e = {};
          for (const i of Object.keys(this._values)) {
            const n = this.getValue(i);
            n !== void 0 && (e[i] = n);
          }
          return e;
        }
        possiblyEvaluate(e, i, n) {
          const a = new Z(this._properties);
          for (const c of Object.keys(this._values)) a._values[c] = this._values[c].possiblyEvaluate(e, i, n);
          return a;
        }
      }
      class G {
        constructor(e, i, n) {
          this.property = e, this.value = i, this.parameters = n;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(e) {
          return this.value.kind === "constant" ? this.value.value : e;
        }
        evaluate(e, i, n, a) {
          return this.property.evaluate(this.value, this.parameters, e, i, n, a);
        }
      }
      class Z {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
        }
        get(e) {
          return this._values[e];
        }
      }
      class L {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, i) {
          return e.expression.evaluate(i);
        }
        interpolate(e, i, n) {
          const a = Hr[this.specification.type];
          return a ? a(e, i, n) : e;
        }
      }
      class N {
        constructor(e, i) {
          this.specification = e, this.overrides = i;
        }
        possiblyEvaluate(e, i, n, a) {
          return new G(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(i, null, {}, n, a) } : e.expression, i);
        }
        interpolate(e, i, n) {
          if (e.value.kind !== "constant" || i.value.kind !== "constant") return e;
          if (e.value.value === void 0 || i.value.value === void 0) return new G(this, { kind: "constant", value: void 0 }, e.parameters);
          const a = Hr[this.specification.type];
          return a ? new G(this, { kind: "constant", value: a(e.value.value, i.value.value, n) }, e.parameters) : e;
        }
        evaluate(e, i, n, a, c, h) {
          return e.kind === "constant" ? e.value : e.evaluate(i, n, a, c, h);
        }
      }
      class X {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, i, n, a) {
          return !!e.expression.evaluate(i, null, {}, n, a);
        }
        interpolate() {
          return !1;
        }
      }
      class K {
        constructor(e) {
          this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const i = new b(0, {});
          for (const n in e) {
            const a = e[n];
            a.specification.overridable && this.overridableProperties.push(n);
            const c = this.defaultPropertyValues[n] = new M(a, void 0), h = this.defaultTransitionablePropertyValues[n] = new S(a);
            this.defaultTransitioningPropertyValues[n] = h.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = c.possiblyEvaluate(i);
          }
        }
      }
      function le(t, e) {
        return 256 * (t = Vt(Math.floor(t), 0, 255)) + Vt(Math.floor(e), 0, 255);
      }
      _t(N, "DataDrivenProperty"), _t(L, "DataConstantProperty"), _t(X, "ColorRampProperty");
      const ue = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class ce {
        constructor(e, i) {
          this._structArray = e, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class ge {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(e, i) {
          return e._trim(), i && (e.isTransferred = !0, i.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
        }
        static deserialize(e) {
          const i = Object.create(this.prototype);
          return i.arrayBuffer = e.arrayBuffer, i.length = e.length, i.capacity = e.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(e) {
          this.reserve(e), this.length = e;
        }
        reserve(e) {
          if (e > this.capacity) {
            this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const i = this.uint8;
            this._refreshViews(), i && this.uint8.set(i);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function me(t, e = 1) {
        let i = 0, n = 0;
        return { members: t.map((a) => {
          const c = ue[a.type].BYTES_PER_ELEMENT, h = i = Ee(i, Math.max(e, c)), p = a.components || 1;
          return n = Math.max(n, c), i += c * p, { name: a.name, type: a.type, components: p, offset: h };
        }), size: Ee(i, Math.max(n, e)), alignment: e };
      }
      function Ee(t, e) {
        return Math.ceil(t / e) * e;
      }
      class Ge extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, i) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e, i);
        }
        emplace(e, i, n) {
          const a = 2 * e;
          return this.int16[a + 0] = i, this.int16[a + 1] = n, e;
        }
      }
      Ge.prototype.bytesPerElement = 4, _t(Ge, "StructArrayLayout2i4");
      class be extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, e, i, n);
        }
        emplace(e, i, n, a) {
          const c = 3 * e;
          return this.int16[c + 0] = i, this.int16[c + 1] = n, this.int16[c + 2] = a, e;
        }
      }
      be.prototype.bytesPerElement = 6, _t(be, "StructArrayLayout3i6");
      class Oe extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a) {
          const c = this.length;
          return this.resize(c + 1), this.emplace(c, e, i, n, a);
        }
        emplace(e, i, n, a, c) {
          const h = 4 * e;
          return this.int16[h + 0] = i, this.int16[h + 1] = n, this.int16[h + 2] = a, this.int16[h + 3] = c, e;
        }
      }
      Oe.prototype.bytesPerElement = 8, _t(Oe, "StructArrayLayout4i8");
      class Ce extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c, h, p) {
          const m = this.length;
          return this.resize(m + 1), this.emplace(m, e, i, n, a, c, h, p);
        }
        emplace(e, i, n, a, c, h, p, m) {
          const _ = 6 * e, v = 12 * e, w = 3 * e;
          return this.int16[_ + 0] = i, this.int16[_ + 1] = n, this.uint8[v + 4] = a, this.uint8[v + 5] = c, this.uint8[v + 6] = h, this.uint8[v + 7] = p, this.float32[w + 2] = m, e;
        }
      }
      Ce.prototype.bytesPerElement = 12, _t(Ce, "StructArrayLayout2i4ub1f12");
      class Ve extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a) {
          const c = this.length;
          return this.resize(c + 1), this.emplace(c, e, i, n, a);
        }
        emplace(e, i, n, a, c) {
          const h = 4 * e;
          return this.float32[h + 0] = i, this.float32[h + 1] = n, this.float32[h + 2] = a, this.float32[h + 3] = c, e;
        }
      }
      Ve.prototype.bytesPerElement = 16, _t(Ve, "StructArrayLayout4f16");
      class Te extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, e, i, n, a, c);
        }
        emplace(e, i, n, a, c, h) {
          const p = 6 * e, m = 3 * e;
          return this.uint16[p + 0] = i, this.uint16[p + 1] = n, this.uint16[p + 2] = a, this.uint16[p + 3] = c, this.float32[m + 2] = h, e;
        }
      }
      Te.prototype.bytesPerElement = 12, _t(Te, "StructArrayLayout4ui1f12");
      class Re extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a) {
          const c = this.length;
          return this.resize(c + 1), this.emplace(c, e, i, n, a);
        }
        emplace(e, i, n, a, c) {
          const h = 4 * e;
          return this.uint16[h + 0] = i, this.uint16[h + 1] = n, this.uint16[h + 2] = a, this.uint16[h + 3] = c, e;
        }
      }
      Re.prototype.bytesPerElement = 8, _t(Re, "StructArrayLayout4ui8");
      class We extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c, h) {
          const p = this.length;
          return this.resize(p + 1), this.emplace(p, e, i, n, a, c, h);
        }
        emplace(e, i, n, a, c, h, p) {
          const m = 6 * e;
          return this.int16[m + 0] = i, this.int16[m + 1] = n, this.int16[m + 2] = a, this.int16[m + 3] = c, this.int16[m + 4] = h, this.int16[m + 5] = p, e;
        }
      }
      We.prototype.bytesPerElement = 12, _t(We, "StructArrayLayout6i12");
      class Ne extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c, h, p, m, _, v, w, T) {
          const C = this.length;
          return this.resize(C + 1), this.emplace(C, e, i, n, a, c, h, p, m, _, v, w, T);
        }
        emplace(e, i, n, a, c, h, p, m, _, v, w, T, C) {
          const A = 12 * e;
          return this.int16[A + 0] = i, this.int16[A + 1] = n, this.int16[A + 2] = a, this.int16[A + 3] = c, this.uint16[A + 4] = h, this.uint16[A + 5] = p, this.uint16[A + 6] = m, this.uint16[A + 7] = _, this.int16[A + 8] = v, this.int16[A + 9] = w, this.int16[A + 10] = T, this.int16[A + 11] = C, e;
        }
      }
      Ne.prototype.bytesPerElement = 24, _t(Ne, "StructArrayLayout4i4ui4i24");
      class He extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c, h) {
          const p = this.length;
          return this.resize(p + 1), this.emplace(p, e, i, n, a, c, h);
        }
        emplace(e, i, n, a, c, h, p) {
          const m = 10 * e, _ = 5 * e;
          return this.int16[m + 0] = i, this.int16[m + 1] = n, this.int16[m + 2] = a, this.float32[_ + 2] = c, this.float32[_ + 3] = h, this.float32[_ + 4] = p, e;
        }
      }
      He.prototype.bytesPerElement = 20, _t(He, "StructArrayLayout3i3f20");
      class wt extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, e);
        }
        emplace(e, i) {
          return this.uint32[1 * e + 0] = i, e;
        }
      }
      wt.prototype.bytesPerElement = 4, _t(wt, "StructArrayLayout1ul4");
      class Dt extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c, h, p, m, _, v, w, T, C) {
          const A = this.length;
          return this.resize(A + 1), this.emplace(A, e, i, n, a, c, h, p, m, _, v, w, T, C);
        }
        emplace(e, i, n, a, c, h, p, m, _, v, w, T, C, A) {
          const z = 20 * e, U = 10 * e;
          return this.int16[z + 0] = i, this.int16[z + 1] = n, this.int16[z + 2] = a, this.int16[z + 3] = c, this.int16[z + 4] = h, this.float32[U + 3] = p, this.float32[U + 4] = m, this.float32[U + 5] = _, this.float32[U + 6] = v, this.int16[z + 14] = w, this.uint32[U + 8] = T, this.uint16[z + 18] = C, this.uint16[z + 19] = A, e;
        }
      }
      Dt.prototype.bytesPerElement = 40, _t(Dt, "StructArrayLayout5i4f1i1ul2ui40");
      class gt extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c, h, p) {
          const m = this.length;
          return this.resize(m + 1), this.emplace(m, e, i, n, a, c, h, p);
        }
        emplace(e, i, n, a, c, h, p, m) {
          const _ = 8 * e;
          return this.int16[_ + 0] = i, this.int16[_ + 1] = n, this.int16[_ + 2] = a, this.int16[_ + 4] = c, this.int16[_ + 5] = h, this.int16[_ + 6] = p, this.int16[_ + 7] = m, e;
        }
      }
      gt.prototype.bytesPerElement = 16, _t(gt, "StructArrayLayout3i2i2i16");
      class Ct extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, e, i, n, a, c);
        }
        emplace(e, i, n, a, c, h) {
          const p = 4 * e, m = 8 * e;
          return this.float32[p + 0] = i, this.float32[p + 1] = n, this.float32[p + 2] = a, this.int16[m + 6] = c, this.int16[m + 7] = h, e;
        }
      }
      Ct.prototype.bytesPerElement = 16, _t(Ct, "StructArrayLayout2f1f2i16");
      class ti extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a) {
          const c = this.length;
          return this.resize(c + 1), this.emplace(c, e, i, n, a);
        }
        emplace(e, i, n, a, c) {
          const h = 12 * e, p = 3 * e;
          return this.uint8[h + 0] = i, this.uint8[h + 1] = n, this.float32[p + 1] = a, this.float32[p + 2] = c, e;
        }
      }
      ti.prototype.bytesPerElement = 12, _t(ti, "StructArrayLayout2ub2f12");
      class Yt extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, e, i, n);
        }
        emplace(e, i, n, a) {
          const c = 3 * e;
          return this.float32[c + 0] = i, this.float32[c + 1] = n, this.float32[c + 2] = a, e;
        }
      }
      Yt.prototype.bytesPerElement = 12, _t(Yt, "StructArrayLayout3f12");
      class vt extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, e, i, n);
        }
        emplace(e, i, n, a) {
          const c = 3 * e;
          return this.uint16[c + 0] = i, this.uint16[c + 1] = n, this.uint16[c + 2] = a, e;
        }
      }
      vt.prototype.bytesPerElement = 6, _t(vt, "StructArrayLayout3ui6");
      class vi extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c, h, p, m, _, v, w, T, C, A, z, U, q, ie, W, te, ae) {
          const oe = this.length;
          return this.resize(oe + 1), this.emplace(oe, e, i, n, a, c, h, p, m, _, v, w, T, C, A, z, U, q, ie, W, te, ae);
        }
        emplace(e, i, n, a, c, h, p, m, _, v, w, T, C, A, z, U, q, ie, W, te, ae, oe) {
          const Se = 30 * e, we = 15 * e, ke = 60 * e;
          return this.int16[Se + 0] = i, this.int16[Se + 1] = n, this.int16[Se + 2] = a, this.float32[we + 2] = c, this.float32[we + 3] = h, this.uint16[Se + 8] = p, this.uint16[Se + 9] = m, this.uint32[we + 5] = _, this.uint32[we + 6] = v, this.uint32[we + 7] = w, this.uint16[Se + 16] = T, this.uint16[Se + 17] = C, this.uint16[Se + 18] = A, this.float32[we + 10] = z, this.float32[we + 11] = U, this.uint8[ke + 48] = q, this.uint8[ke + 49] = ie, this.uint8[ke + 50] = W, this.uint32[we + 13] = te, this.int16[Se + 28] = ae, this.uint8[ke + 58] = oe, e;
        }
      }
      vi.prototype.bytesPerElement = 60, _t(vi, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class Ti extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c, h, p, m, _, v, w, T, C, A, z, U, q, ie, W, te, ae, oe, Se, we, ke, $e, Ae, Fe, Ue, je) {
          const Je = this.length;
          return this.resize(Je + 1), this.emplace(Je, e, i, n, a, c, h, p, m, _, v, w, T, C, A, z, U, q, ie, W, te, ae, oe, Se, we, ke, $e, Ae, Fe, Ue, je);
        }
        emplace(e, i, n, a, c, h, p, m, _, v, w, T, C, A, z, U, q, ie, W, te, ae, oe, Se, we, ke, $e, Ae, Fe, Ue, je, Je) {
          const Le = 38 * e, ot = 19 * e;
          return this.int16[Le + 0] = i, this.int16[Le + 1] = n, this.int16[Le + 2] = a, this.float32[ot + 2] = c, this.float32[ot + 3] = h, this.int16[Le + 8] = p, this.int16[Le + 9] = m, this.int16[Le + 10] = _, this.int16[Le + 11] = v, this.int16[Le + 12] = w, this.int16[Le + 13] = T, this.uint16[Le + 14] = C, this.uint16[Le + 15] = A, this.uint16[Le + 16] = z, this.uint16[Le + 17] = U, this.uint16[Le + 18] = q, this.uint16[Le + 19] = ie, this.uint16[Le + 20] = W, this.uint16[Le + 21] = te, this.uint16[Le + 22] = ae, this.uint16[Le + 23] = oe, this.uint16[Le + 24] = Se, this.uint16[Le + 25] = we, this.uint16[Le + 26] = ke, this.uint16[Le + 27] = $e, this.uint16[Le + 28] = Ae, this.uint32[ot + 15] = Fe, this.float32[ot + 16] = Ue, this.float32[ot + 17] = je, this.float32[ot + 18] = Je, e;
        }
      }
      Ti.prototype.bytesPerElement = 76, _t(Ti, "StructArrayLayout3i2f6i15ui1ul3f76");
      class Ei extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, e);
        }
        emplace(e, i) {
          return this.float32[1 * e + 0] = i, e;
        }
      }
      Ei.prototype.bytesPerElement = 4, _t(Ei, "StructArrayLayout1f4");
      class Si extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a, c) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, e, i, n, a, c);
        }
        emplace(e, i, n, a, c, h) {
          const p = 5 * e;
          return this.float32[p + 0] = i, this.float32[p + 1] = n, this.float32[p + 2] = a, this.float32[p + 3] = c, this.float32[p + 4] = h, e;
        }
      }
      Si.prototype.bytesPerElement = 20, _t(Si, "StructArrayLayout5f20");
      class Vr extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, i, n, a) {
          const c = this.length;
          return this.resize(c + 1), this.emplace(c, e, i, n, a);
        }
        emplace(e, i, n, a, c) {
          const h = 6 * e;
          return this.uint32[3 * e + 0] = i, this.uint16[h + 2] = n, this.uint16[h + 3] = a, this.uint16[h + 4] = c, e;
        }
      }
      Vr.prototype.bytesPerElement = 12, _t(Vr, "StructArrayLayout1ul3ui12");
      class Er extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, i) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e, i);
        }
        emplace(e, i, n) {
          const a = 2 * e;
          return this.uint16[a + 0] = i, this.uint16[a + 1] = n, e;
        }
      }
      Er.prototype.bytesPerElement = 4, _t(Er, "StructArrayLayout2ui4");
      class kn extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, e);
        }
        emplace(e, i) {
          return this.uint16[1 * e + 0] = i, e;
        }
      }
      kn.prototype.bytesPerElement = 2, _t(kn, "StructArrayLayout1ui2");
      class Eo extends ge {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, i) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e, i);
        }
        emplace(e, i, n) {
          const a = 2 * e;
          return this.float32[a + 0] = i, this.float32[a + 1] = n, e;
        }
      }
      Eo.prototype.bytesPerElement = 8, _t(Eo, "StructArrayLayout2f8");
      class Gi extends ce {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      Gi.prototype.size = 40;
      class Mi extends Dt {
        get(e) {
          return new Gi(this, e);
        }
      }
      _t(Mi, "CollisionBoxArray");
      class fi extends ce {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(e) {
          this._structArray.uint8[this._pos1 + 49] = e;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(e) {
          this._structArray.uint8[this._pos1 + 50] = e;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 13] = e;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(e) {
          this._structArray.uint8[this._pos1 + 58] = e;
        }
      }
      fi.prototype.size = 60;
      class cr extends vi {
        get(e) {
          return new fi(this, e);
        }
      }
      _t(cr, "PlacedSymbolArray");
      class Jr extends ce {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 13];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 28];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 15];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 15] = e;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 18];
        }
      }
      Jr.prototype.size = 76;
      class ji extends Ti {
        get(e) {
          return new Jr(this, e);
        }
      }
      _t(ji, "SymbolInstanceArray");
      class cn extends Ei {
        getoffsetX(e) {
          return this.float32[1 * e + 0];
        }
      }
      _t(cn, "GlyphOffsetArray");
      class Rl extends Ge {
        getx(e) {
          return this.int16[2 * e + 0];
        }
        gety(e) {
          return this.int16[2 * e + 1];
        }
      }
      _t(Rl, "SymbolLineVertexArray");
      class Us extends ce {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      Us.prototype.size = 12;
      class Ja extends Vr {
        get(e) {
          return new Us(this, e);
        }
      }
      _t(Ja, "FeatureIndexArray");
      class Vo extends Er {
        geta_centroid_pos0(e) {
          return this.uint16[2 * e + 0];
        }
        geta_centroid_pos1(e) {
          return this.uint16[2 * e + 1];
        }
      }
      _t(Vo, "FillExtrusionCentroidArray");
      const ps = me([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), Ns = me([{ name: "a_dash", components: 4, type: "Uint16" }]);
      var Ol = { exports: {} }, Ya = { exports: {} };
      Ya.exports = function(t, e) {
        var i, n, a, c, h, p, m, _;
        for (n = t.length - (i = 3 & t.length), a = e, h = 3432918353, p = 461845907, _ = 0; _ < n; ) m = 255 & t.charCodeAt(_) | (255 & t.charCodeAt(++_)) << 8 | (255 & t.charCodeAt(++_)) << 16 | (255 & t.charCodeAt(++_)) << 24, ++_, a = 27492 + (65535 & (c = 5 * (65535 & (a = (a ^= m = (65535 & (m = (m = (65535 & m) * h + (((m >>> 16) * h & 65535) << 16) & 4294967295) << 15 | m >>> 17)) * p + (((m >>> 16) * p & 65535) << 16) & 4294967295) << 13 | a >>> 19)) + ((5 * (a >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (c >>> 16) & 65535) << 16);
        switch (m = 0, i) {
          case 3:
            m ^= (255 & t.charCodeAt(_ + 2)) << 16;
          case 2:
            m ^= (255 & t.charCodeAt(_ + 1)) << 8;
          case 1:
            a ^= m = (65535 & (m = (m = (65535 & (m ^= 255 & t.charCodeAt(_))) * h + (((m >>> 16) * h & 65535) << 16) & 4294967295) << 15 | m >>> 17)) * p + (((m >>> 16) * p & 65535) << 16) & 4294967295;
        }
        return a ^= t.length, a = 2246822507 * (65535 & (a ^= a >>> 16)) + ((2246822507 * (a >>> 16) & 65535) << 16) & 4294967295, a = 3266489909 * (65535 & (a ^= a >>> 13)) + ((3266489909 * (a >>> 16) & 65535) << 16) & 4294967295, (a ^= a >>> 16) >>> 0;
      };
      var Pc = Ya.exports, pp = { exports: {} };
      pp.exports = function(t, e) {
        for (var i, n = t.length, a = e ^ n, c = 0; n >= 4; ) i = 1540483477 * (65535 & (i = 255 & t.charCodeAt(c) | (255 & t.charCodeAt(++c)) << 8 | (255 & t.charCodeAt(++c)) << 16 | (255 & t.charCodeAt(++c)) << 24)) + ((1540483477 * (i >>> 16) & 65535) << 16), a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ (i = 1540483477 * (65535 & (i ^= i >>> 24)) + ((1540483477 * (i >>> 16) & 65535) << 16)), n -= 4, ++c;
        switch (n) {
          case 3:
            a ^= (255 & t.charCodeAt(c + 2)) << 16;
          case 2:
            a ^= (255 & t.charCodeAt(c + 1)) << 8;
          case 1:
            a = 1540483477 * (65535 & (a ^= 255 & t.charCodeAt(c))) + ((1540483477 * (a >>> 16) & 65535) << 16);
        }
        return a = 1540483477 * (65535 & (a ^= a >>> 13)) + ((1540483477 * (a >>> 16) & 65535) << 16), (a ^= a >>> 15) >>> 0;
      };
      var fp = Pc, $_ = pp.exports;
      Ol.exports = fp, Ol.exports.murmur3 = fp, Ol.exports.murmur2 = $_;
      var Bh = St(Ol.exports);
      class Lu {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(e, i, n, a) {
          this.ids.push(mp(e)), this.positions.push(i, n, a);
        }
        getPositions(e) {
          const i = mp(e);
          let n = 0, a = this.ids.length - 1;
          for (; n < a; ) {
            const h = n + a >> 1;
            this.ids[h] >= i ? a = h : n = h + 1;
          }
          const c = [];
          for (; this.ids[n] === i; ) c.push({ index: this.positions[3 * n], start: this.positions[3 * n + 1], end: this.positions[3 * n + 2] }), n++;
          return c;
        }
        static serialize(e, i) {
          const n = new Float64Array(e.ids), a = new Uint32Array(e.positions);
          return Fh(n, a, 0, n.length - 1), i && i.push(n.buffer, a.buffer), { ids: n, positions: a };
        }
        static deserialize(e) {
          const i = new Lu();
          return i.ids = e.ids, i.positions = e.positions, i.indexed = !0, i;
        }
      }
      function mp(t) {
        const e = +t;
        return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : Bh(String(t));
      }
      function Fh(t, e, i, n) {
        for (; i < n; ) {
          const a = t[i + n >> 1];
          let c = i - 1, h = n + 1;
          for (; ; ) {
            do
              c++;
            while (t[c] < a);
            do
              h--;
            while (t[h] > a);
            if (c >= h) break;
            zu(t, c, h), zu(e, 3 * c, 3 * h), zu(e, 3 * c + 1, 3 * h + 1), zu(e, 3 * c + 2, 3 * h + 2);
          }
          h - i < n - h ? (Fh(t, e, i, h), i = h + 1) : (Fh(t, e, h + 1, n), n = h);
        }
      }
      function zu(t, e, i) {
        const n = t[e];
        t[e] = t[i], t[i] = n;
      }
      _t(Lu, "FeaturePositionMap");
      class js {
        constructor(e) {
          this.gl = e.gl, this.initialized = !1;
        }
        fetchUniformLocation(e, i) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e, i), this.initialized = !0), !!this.location;
        }
      }
      class ku extends js {
        constructor(e) {
          super(e), this.current = 0;
        }
        set(e, i, n) {
          this.fetchUniformLocation(e, i) && this.current !== n && (this.current = n, this.gl.uniform1f(this.location, n));
        }
      }
      class _p extends js {
        constructor(e) {
          super(e), this.current = [0, 0, 0, 0];
        }
        set(e, i, n) {
          this.fetchUniformLocation(e, i) && (n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] && n[3] === this.current[3] || (this.current = n, this.gl.uniform4f(this.location, n[0], n[1], n[2], n[3])));
        }
      }
      class gp extends js {
        constructor(e) {
          super(e), this.current = De.transparent;
        }
        set(e, i, n) {
          this.fetchUniformLocation(e, i) && (n.r === this.current.r && n.g === this.current.g && n.b === this.current.b && n.a === this.current.a || (this.current = n, this.gl.uniform4f(this.location, n.r, n.g, n.b, n.a)));
        }
      }
      const Z_ = new Float32Array(16), q_ = new Float32Array(9), W_ = new Float32Array(4);
      function Uh(t) {
        return [le(255 * t.r, 255 * t.g), le(255 * t.b, 255 * t.a)];
      }
      class Lc {
        constructor(e, i, n) {
          this.value = e, this.uniformNames = i.map((a) => `u_${a}`), this.type = n;
        }
        setUniform(e, i, n, a, c) {
          i.set(e, c, a.constantOr(this.value));
        }
        getBinding(e, i) {
          return this.type === "color" ? new gp(e) : new ku(e);
        }
      }
      class Bl {
        constructor(e, i) {
          this.uniformNames = i.map((n) => `u_${n}`), this.pattern = null, this.pixelRatio = 1;
        }
        setConstantPatternPositions(e) {
          this.pixelRatio = e.pixelRatio || 1, this.pattern = e.tl.concat(e.br);
        }
        setUniform(e, i, n, a, c) {
          const h = c === "u_pattern" || c === "u_dash" ? this.pattern : c === "u_pixel_ratio" ? this.pixelRatio : null;
          h && i.set(e, c, h);
        }
        getBinding(e, i) {
          return i === "u_pattern" || i === "u_dash" ? new _p(e) : new ku(e);
        }
      }
      class Vs {
        constructor(e, i, n, a) {
          this.expression = e, this.type = n, this.maxValue = 0, this.paintVertexAttributes = i.map((c) => ({ name: `a_${c}`, type: "Float32", components: n === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new a();
        }
        populatePaintArray(e, i, n, a, c, h) {
          const p = this.paintVertexArray.length, m = this.expression.evaluate(new b(0), i, {}, c, a, h);
          this.paintVertexArray.resize(e), this._setPaintValue(p, e, m);
        }
        updatePaintArray(e, i, n, a, c) {
          const h = this.expression.evaluate({ zoom: 0 }, n, a, void 0, c);
          this._setPaintValue(e, i, h);
        }
        _setPaintValue(e, i, n) {
          if (this.type === "color") {
            const a = Uh(n);
            for (let c = e; c < i; c++) this.paintVertexArray.emplace(c, a[0], a[1]);
          } else {
            for (let a = e; a < i; a++) this.paintVertexArray.emplace(a, n);
            this.maxValue = Math.max(this.maxValue, Math.abs(n));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Go {
        constructor(e, i, n, a, c, h) {
          this.expression = e, this.uniformNames = i.map((p) => `u_${p}_t`), this.type = n, this.useIntegerZoom = a, this.zoom = c, this.maxValue = 0, this.paintVertexAttributes = i.map((p) => ({ name: `a_${p}`, type: "Float32", components: n === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new h();
        }
        populatePaintArray(e, i, n, a, c, h) {
          const p = this.expression.evaluate(new b(this.zoom), i, {}, c, a, h), m = this.expression.evaluate(new b(this.zoom + 1), i, {}, c, a, h), _ = this.paintVertexArray.length;
          this.paintVertexArray.resize(e), this._setPaintValue(_, e, p, m);
        }
        updatePaintArray(e, i, n, a, c) {
          const h = this.expression.evaluate({ zoom: this.zoom }, n, a, void 0, c), p = this.expression.evaluate({ zoom: this.zoom + 1 }, n, a, void 0, c);
          this._setPaintValue(e, i, h, p);
        }
        _setPaintValue(e, i, n, a) {
          if (this.type === "color") {
            const c = Uh(n), h = Uh(a);
            for (let p = e; p < i; p++) this.paintVertexArray.emplace(p, c[0], c[1], h[0], h[1]);
          } else {
            for (let c = e; c < i; c++) this.paintVertexArray.emplace(c, n, a);
            this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(a));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(e, i, n, a, c) {
          const h = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, p = Vt(this.expression.interpolationFactor(h, this.zoom, this.zoom + 1), 0, 1);
          i.set(e, c, p);
        }
        getBinding(e, i) {
          return new ku(e);
        }
      }
      class fa {
        constructor(e, i, n, a, c) {
          this.expression = e, this.layerId = c, this.paintVertexAttributes = (n === "array" ? Ns : ps).members;
          for (let h = 0; h < i.length; ++h) ;
          this.paintVertexArray = new a();
        }
        populatePaintArray(e, i, n) {
          const a = this.paintVertexArray.length;
          this.paintVertexArray.resize(e), this._setPaintValues(a, e, i.patterns && i.patterns[this.layerId], n);
        }
        updatePaintArray(e, i, n, a, c, h) {
          this._setPaintValues(e, i, n.patterns && n.patterns[this.layerId], h);
        }
        _setPaintValues(e, i, n, a) {
          if (!a || !n) return;
          const c = a[n];
          if (!c) return;
          const { tl: h, br: p, pixelRatio: m } = c;
          for (let _ = e; _ < i; _++) this.paintVertexArray.emplace(_, h[0], h[1], p[0], p[1], m);
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class ma {
        constructor(e, i, n = () => !0) {
          this.binders = {}, this._buffers = [];
          const a = [];
          for (const c in e.paint._values) {
            if (!n(c)) continue;
            const h = e.paint.get(c);
            if (!(h instanceof G && Nr(h.property.specification))) continue;
            const p = H_(c, e.type), m = h.value, _ = h.property.specification.type, v = !!h.property.useIntegerZoom, w = c === "line-dasharray" || c.endsWith("pattern"), T = c === "line-dasharray" && e.layout.get("line-cap").value.kind !== "constant";
            if (m.kind !== "constant" || T) if (m.kind === "source" || T || w) {
              const C = yp(c, _, "source");
              this.binders[c] = w ? new fa(m, p, _, C, e.id) : new Vs(m, p, _, C), a.push(`/a_${c}`);
            } else {
              const C = yp(c, _, "composite");
              this.binders[c] = new Go(m, p, _, v, i, C), a.push(`/z_${c}`);
            }
            else this.binders[c] = w ? new Bl(m.value, p) : new Lc(m.value, p, _), a.push(`/u_${c}`);
          }
          this.cacheKey = a.sort().join("");
        }
        getMaxValue(e) {
          const i = this.binders[e];
          return i instanceof Vs || i instanceof Go ? i.maxValue : 0;
        }
        populatePaintArrays(e, i, n, a, c, h) {
          for (const p in this.binders) {
            const m = this.binders[p];
            (m instanceof Vs || m instanceof Go || m instanceof fa) && m.populatePaintArray(e, i, n, a, c, h);
          }
        }
        setConstantPatternPositions(e) {
          for (const i in this.binders) {
            const n = this.binders[i];
            n instanceof Bl && n.setConstantPatternPositions(e);
          }
        }
        updatePaintArrays(e, i, n, a, c, h) {
          let p = !1;
          for (const m in e) {
            const _ = i.getPositions(m);
            for (const v of _) {
              const w = n.feature(v.index);
              for (const T in this.binders) {
                const C = this.binders[T];
                if ((C instanceof Vs || C instanceof Go || C instanceof fa) && C.expression.isStateDependent === !0) {
                  const A = a.paint.get(T);
                  C.expression = A.value, C.updatePaintArray(v.start, v.end, w, e[m], c, h), p = !0;
                }
              }
            }
          }
          return p;
        }
        defines() {
          const e = [];
          for (const i in this.binders) {
            const n = this.binders[i];
            (n instanceof Lc || n instanceof Bl) && e.push(...n.uniformNames.map((a) => `#define HAS_UNIFORM_${a}`));
          }
          return e;
        }
        getBinderAttributes() {
          const e = [];
          for (const i in this.binders) {
            const n = this.binders[i];
            if (n instanceof Vs || n instanceof Go || n instanceof fa) for (let a = 0; a < n.paintVertexAttributes.length; a++) e.push(n.paintVertexAttributes[a].name);
          }
          return e;
        }
        getBinderUniforms() {
          const e = [];
          for (const i in this.binders) {
            const n = this.binders[i];
            if (n instanceof Lc || n instanceof Bl || n instanceof Go) for (const a of n.uniformNames) e.push(a);
          }
          return e;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(e) {
          const i = [];
          for (const n in this.binders) {
            const a = this.binders[n];
            if (a instanceof Lc || a instanceof Bl || a instanceof Go) for (const c of a.uniformNames) i.push({ name: c, property: n, binding: a.getBinding(e, c) });
          }
          return i;
        }
        setUniforms(e, i, n, a, c) {
          for (const { name: h, property: p, binding: m } of n) this.binders[p].setUniform(e, m, c, a.get(p), h);
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const e in this.binders) {
            const i = this.binders[e];
            (i instanceof Vs || i instanceof Go || i instanceof fa) && i.paintVertexBuffer && this._buffers.push(i.paintVertexBuffer);
          }
        }
        upload(e) {
          for (const i in this.binders) {
            const n = this.binders[i];
            (n instanceof Vs || n instanceof Go || n instanceof fa) && n.upload(e);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const e in this.binders) {
            const i = this.binders[e];
            (i instanceof Vs || i instanceof Go || i instanceof fa) && i.destroy();
          }
        }
      }
      class Qa {
        constructor(e, i, n = () => !0) {
          this.programConfigurations = {};
          for (const a of e) this.programConfigurations[a.id] = new ma(a, i, n);
          this.needsUpload = !1, this._featureMap = new Lu(), this._bufferOffset = 0;
        }
        populatePaintArrays(e, i, n, a, c, h, p) {
          for (const m in this.programConfigurations) this.programConfigurations[m].populatePaintArrays(e, i, a, c, h, p);
          i.id !== void 0 && this._featureMap.add(i.id, n, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0;
        }
        updatePaintArrays(e, i, n, a, c) {
          for (const h of n) this.needsUpload = this.programConfigurations[h.id].updatePaintArrays(e, this._featureMap, i, h, a, c) || this.needsUpload;
        }
        get(e) {
          return this.programConfigurations[e];
        }
        upload(e) {
          if (this.needsUpload) {
            for (const i in this.programConfigurations) this.programConfigurations[i].upload(e);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
        }
      }
      const X_ = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
      function H_(t, e) {
        return X_[t] || [t.replace(`${e}-`, "").replace(/-/g, "_")];
      }
      const K_ = { "line-pattern": { source: Te, composite: Te }, "fill-pattern": { source: Te, composite: Te }, "fill-extrusion-pattern": { source: Te, composite: Te }, "line-dasharray": { source: Re, composite: Re } }, J_ = { color: { source: Eo, composite: Ve }, number: { source: Ei, composite: Eo } };
      function yp(t, e, i) {
        const n = K_[t];
        return n && n[i] || J_[e][i];
      }
      _t(Lc, "ConstantBinder"), _t(Bl, "PatternConstantBinder"), _t(Vs, "SourceExpressionBinder"), _t(fa, "PatternCompositeBinder"), _t(Go, "CompositeExpressionBinder"), _t(ma, "ProgramConfiguration", { omit: ["_buffers"] }), _t(Qa, "ProgramConfigurationSet");
      const xp = "-transition";
      class $o extends Fr {
        constructor(e, i) {
          if (super(), this.id = e.id, this.type = e.type, this._featureFilter = { filter: () => !0, needGeometry: !1, needFeature: !1 }, this._filterCompiled = !1, e.type !== "custom" && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && e.type !== "sky" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), i.layout && (this._unevaluatedLayout = new $(i.layout)), i.paint)) {
            this._transitionablePaint = new P(i.paint);
            for (const n in e.paint) this.setPaintProperty(n, e.paint[n], { validate: !1 });
            for (const n in e.layout) this.setLayoutProperty(n, e.layout[n], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Z(i.paint);
          }
        }
        getLayoutProperty(e) {
          return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
        }
        setLayoutProperty(e, i, n = {}) {
          i != null && this._validate(zh, `layers.${this.id}.layout.${e}`, e, i, n) || (e !== "visibility" ? this._unevaluatedLayout.setValue(e, i) : this.visibility = i);
        }
        getPaintProperty(e) {
          return Wt(e, xp) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
        }
        setPaintProperty(e, i, n = {}) {
          if (i != null && this._validate(Lh, `layers.${this.id}.paint.${e}`, e, i, n)) return !1;
          if (Wt(e, xp)) return this._transitionablePaint.setTransition(e.slice(0, -11), i || void 0), !1;
          {
            const a = this._transitionablePaint._values[e], c = a.value.isDataDriven(), h = a.value;
            this._transitionablePaint.setValue(e, i), this._handleSpecialPaintPropertyUpdate(e);
            const p = this._transitionablePaint._values[e].value, m = p.isDataDriven(), _ = Wt(e, "pattern") || e === "line-dasharray";
            return m || c || _ || this._handleOverridablePaintPropertyUpdate(e, h, p);
          }
        }
        _handleSpecialPaintPropertyUpdate(e) {
        }
        getProgramIds() {
          return null;
        }
        getProgramConfiguration(e) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(e, i, n) {
          return !1;
        }
        isHidden(e) {
          return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(e) {
          this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(e, i) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, i)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, i);
        }
        serialize() {
          const e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), Yo(e, (i, n) => !(i === void 0 || n === "layout" && !Object.keys(i).length || n === "paint" && !Object.keys(i).length));
        }
        _validate(e, i, n, a, c = {}) {
          return (!c || c.validate !== !1) && Cu(this, e.call(Mu, { key: i, layerType: this.type, objectKey: n, value: a, styleSpec: Pe, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isSky() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const e in this.paint._values) {
            const i = this.paint.get(e);
            if (i instanceof G && Nr(i.property.specification) && (i.value.kind === "source" || i.value.kind === "composite") && i.value.isStateDependent) return !0;
          }
          return !1;
        }
        compileFilter() {
          this._filterCompiled || (this._featureFilter = Ll(this.filter), this._filterCompiled = !0);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = !1;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
      }
      const Y_ = me([{ name: "a_pos", components: 2, type: "Int16" }], 4), Q_ = me([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class ur {
        constructor(e = []) {
          this.segments = e;
        }
        prepareSegment(e, i, n, a) {
          let c = this.segments[this.segments.length - 1];
          return e > ur.MAX_VERTEX_ARRAY_LENGTH && Ui(`Max vertices per segment is ${ur.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!c || c.vertexLength + e > ur.MAX_VERTEX_ARRAY_LENGTH || c.sortKey !== a) && (c = { vertexOffset: i.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0 }, a !== void 0 && (c.sortKey = a), this.segments.push(c)), c;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const e of this.segments) for (const i in e.vaos) e.vaos[i].destroy();
        }
        static simpleSegment(e, i, n, a) {
          return new ur([{ vertexOffset: e, primitiveOffset: i, vertexLength: n, primitiveLength: a, vaos: {}, sortKey: 0 }]);
        }
      }
      ur.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, _t(ur, "SegmentVector");
      var Et = 8192;
      class _a {
        constructor(e, i) {
          e && (i ? this.setSouthWest(e).setNorthEast(i) : e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1]));
        }
        setNorthEast(e) {
          return this._ne = e instanceof Ci ? new Ci(e.lng, e.lat) : Ci.convert(e), this;
        }
        setSouthWest(e) {
          return this._sw = e instanceof Ci ? new Ci(e.lng, e.lat) : Ci.convert(e), this;
        }
        extend(e) {
          const i = this._sw, n = this._ne;
          let a, c;
          if (e instanceof Ci) a = e, c = e;
          else {
            if (!(e instanceof _a)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(_a.convert(e)) : this.extend(Ci.convert(e)) : typeof e == "object" && e !== null && e.hasOwnProperty("lat") && (e.hasOwnProperty("lon") || e.hasOwnProperty("lng")) ? this.extend(Ci.convert(e)) : this;
            if (a = e._sw, c = e._ne, !a || !c) return this;
          }
          return i || n ? (i.lng = Math.min(a.lng, i.lng), i.lat = Math.min(a.lat, i.lat), n.lng = Math.max(c.lng, n.lng), n.lat = Math.max(c.lat, n.lat)) : (this._sw = new Ci(a.lng, a.lat), this._ne = new Ci(c.lng, c.lat)), this;
        }
        getCenter() {
          return new Ci((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new Ci(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new Ci(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e) {
          const { lng: i, lat: n } = Ci.convert(e);
          let a = this._sw.lng <= i && i <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (a = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= n && n <= this._ne.lat && a;
        }
        static convert(e) {
          return !e || e instanceof _a ? e : new _a(e);
        }
      }
      var Du = 1e-6, Dn = typeof Float32Array < "u" ? Float32Array : Array;
      function vp() {
        var t = new Dn(9);
        return Dn != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
      }
      function bp(t, e, i) {
        var n = e[0], a = e[1], c = e[2], h = e[3], p = e[4], m = e[5], _ = e[6], v = e[7], w = e[8], T = i[0], C = i[1], A = i[2], z = i[3], U = i[4], q = i[5], ie = i[6], W = i[7], te = i[8];
        return t[0] = T * n + C * h + A * _, t[1] = T * a + C * p + A * v, t[2] = T * c + C * m + A * w, t[3] = z * n + U * h + q * _, t[4] = z * a + U * p + q * v, t[5] = z * c + U * m + q * w, t[6] = ie * n + W * h + te * _, t[7] = ie * a + W * p + te * v, t[8] = ie * c + W * m + te * w, t;
      }
      function Zo(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }
      function Nh(t, e) {
        var i = e[0], n = e[1], a = e[2], c = e[3], h = e[4], p = e[5], m = e[6], _ = e[7], v = e[8], w = e[9], T = e[10], C = e[11], A = e[12], z = e[13], U = e[14], q = e[15], ie = i * p - n * h, W = i * m - a * h, te = i * _ - c * h, ae = n * m - a * p, oe = n * _ - c * p, Se = a * _ - c * m, we = v * z - w * A, ke = v * U - T * A, $e = v * q - C * A, Ae = w * U - T * z, Fe = w * q - C * z, Ue = T * q - C * U, je = ie * Ue - W * Fe + te * Ae + ae * $e - oe * ke + Se * we;
        return je ? (t[0] = (p * Ue - m * Fe + _ * Ae) * (je = 1 / je), t[1] = (a * Fe - n * Ue - c * Ae) * je, t[2] = (z * Se - U * oe + q * ae) * je, t[3] = (T * oe - w * Se - C * ae) * je, t[4] = (m * $e - h * Ue - _ * ke) * je, t[5] = (i * Ue - a * $e + c * ke) * je, t[6] = (U * te - A * Se - q * W) * je, t[7] = (v * Se - T * te + C * W) * je, t[8] = (h * Fe - p * $e + _ * we) * je, t[9] = (n * $e - i * Fe - c * we) * je, t[10] = (A * oe - z * te + q * ie) * je, t[11] = (w * te - v * oe - C * ie) * je, t[12] = (p * ke - h * Ae - m * we) * je, t[13] = (i * Ae - n * ke + a * we) * je, t[14] = (z * W - A * ae - U * ie) * je, t[15] = (v * ae - w * W + T * ie) * je, t) : null;
      }
      function el(t, e, i) {
        var n = e[0], a = e[1], c = e[2], h = e[3], p = e[4], m = e[5], _ = e[6], v = e[7], w = e[8], T = e[9], C = e[10], A = e[11], z = e[12], U = e[13], q = e[14], ie = e[15], W = i[0], te = i[1], ae = i[2], oe = i[3];
        return t[0] = W * n + te * p + ae * w + oe * z, t[1] = W * a + te * m + ae * T + oe * U, t[2] = W * c + te * _ + ae * C + oe * q, t[3] = W * h + te * v + ae * A + oe * ie, t[4] = (W = i[4]) * n + (te = i[5]) * p + (ae = i[6]) * w + (oe = i[7]) * z, t[5] = W * a + te * m + ae * T + oe * U, t[6] = W * c + te * _ + ae * C + oe * q, t[7] = W * h + te * v + ae * A + oe * ie, t[8] = (W = i[8]) * n + (te = i[9]) * p + (ae = i[10]) * w + (oe = i[11]) * z, t[9] = W * a + te * m + ae * T + oe * U, t[10] = W * c + te * _ + ae * C + oe * q, t[11] = W * h + te * v + ae * A + oe * ie, t[12] = (W = i[12]) * n + (te = i[13]) * p + (ae = i[14]) * w + (oe = i[15]) * z, t[13] = W * a + te * m + ae * T + oe * U, t[14] = W * c + te * _ + ae * C + oe * q, t[15] = W * h + te * v + ae * A + oe * ie, t;
      }
      function zc(t, e, i) {
        var n, a, c, h, p, m, _, v, w, T, C, A, z = i[0], U = i[1], q = i[2];
        return e === t ? (t[12] = e[0] * z + e[4] * U + e[8] * q + e[12], t[13] = e[1] * z + e[5] * U + e[9] * q + e[13], t[14] = e[2] * z + e[6] * U + e[10] * q + e[14], t[15] = e[3] * z + e[7] * U + e[11] * q + e[15]) : (a = e[1], c = e[2], h = e[3], p = e[4], m = e[5], _ = e[6], v = e[7], w = e[8], T = e[9], C = e[10], A = e[11], t[0] = n = e[0], t[1] = a, t[2] = c, t[3] = h, t[4] = p, t[5] = m, t[6] = _, t[7] = v, t[8] = w, t[9] = T, t[10] = C, t[11] = A, t[12] = n * z + p * U + w * q + e[12], t[13] = a * z + m * U + T * q + e[13], t[14] = c * z + _ * U + C * q + e[14], t[15] = h * z + v * U + A * q + e[15]), t;
      }
      function tl(t, e, i) {
        var n = i[0], a = i[1], c = i[2];
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * a, t[5] = e[5] * a, t[6] = e[6] * a, t[7] = e[7] * a, t[8] = e[8] * c, t[9] = e[9] * c, t[10] = e[10] * c, t[11] = e[11] * c, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
      }
      function jh(t, e, i) {
        var n = Math.sin(i), a = Math.cos(i), c = e[4], h = e[5], p = e[6], m = e[7], _ = e[8], v = e[9], w = e[10], T = e[11];
        return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = c * a + _ * n, t[5] = h * a + v * n, t[6] = p * a + w * n, t[7] = m * a + T * n, t[8] = _ * a - c * n, t[9] = v * a - h * n, t[10] = w * a - p * n, t[11] = T * a - m * n, t;
      }
      function Ru(t, e, i) {
        var n = Math.sin(i), a = Math.cos(i), c = e[0], h = e[1], p = e[2], m = e[3], _ = e[8], v = e[9], w = e[10], T = e[11];
        return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = c * a - _ * n, t[1] = h * a - v * n, t[2] = p * a - w * n, t[3] = m * a - T * n, t[8] = c * n + _ * a, t[9] = h * n + v * a, t[10] = p * n + w * a, t[11] = m * n + T * a, t;
      }
      function wp(t, e) {
        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }
      function Tp(t, e, i) {
        var n, a, c, h = i[0], p = i[1], m = i[2], _ = Math.hypot(h, p, m);
        return _ < Du ? null : (h *= _ = 1 / _, p *= _, m *= _, n = Math.sin(e), a = Math.cos(e), t[0] = h * h * (c = 1 - a) + a, t[1] = p * h * c + m * n, t[2] = m * h * c - p * n, t[3] = 0, t[4] = h * p * c - m * n, t[5] = p * p * c + a, t[6] = m * p * c + h * n, t[7] = 0, t[8] = h * m * c + p * n, t[9] = p * m * c - h * n, t[10] = m * m * c + a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
      }
      Math.hypot || (Math.hypot = function() {
        for (var t = 0, e = arguments.length; e--; ) t += arguments[e] * arguments[e];
        return Math.sqrt(t);
      });
      var eg = el;
      function Vh() {
        var t = new Dn(3);
        return Dn != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
      }
      function Ep(t) {
        var e = new Dn(3);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
      }
      function kc(t) {
        return Math.hypot(t[0], t[1], t[2]);
      }
      function Fl(t, e, i) {
        var n = new Dn(3);
        return n[0] = t, n[1] = e, n[2] = i, n;
      }
      function Gs(t, e, i) {
        return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t;
      }
      function Gh(t, e, i) {
        return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t;
      }
      function Sp(t, e, i) {
        return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t[2] = e[2] * i[2], t;
      }
      function Dc(t, e, i) {
        return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t[2] = Math.min(e[2], i[2]), t;
      }
      function Rc(t, e, i) {
        return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t[2] = Math.max(e[2], i[2]), t;
      }
      function ro(t, e, i) {
        return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t;
      }
      function Oc(t, e, i, n) {
        return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t[2] = e[2] + i[2] * n, t;
      }
      function un(t, e) {
        var i = e[0], n = e[1], a = e[2], c = i * i + n * n + a * a;
        return c > 0 && (c = 1 / Math.sqrt(c)), t[0] = e[0] * c, t[1] = e[1] * c, t[2] = e[2] * c, t;
      }
      function So(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
      }
      function $h(t, e, i) {
        var n = e[0], a = e[1], c = e[2], h = i[0], p = i[1], m = i[2];
        return t[0] = a * m - c * p, t[1] = c * h - n * m, t[2] = n * p - a * h, t;
      }
      function rr(t, e, i) {
        var n = e[0], a = e[1], c = e[2], h = i[3] * n + i[7] * a + i[11] * c + i[15];
        return t[0] = (i[0] * n + i[4] * a + i[8] * c + i[12]) / (h = h || 1), t[1] = (i[1] * n + i[5] * a + i[9] * c + i[13]) / h, t[2] = (i[2] * n + i[6] * a + i[10] * c + i[14]) / h, t;
      }
      function Mp(t, e, i) {
        var n = i[0], a = i[1], c = i[2], h = e[0], p = e[1], m = e[2], _ = a * m - c * p, v = c * h - n * m, w = n * p - a * h, T = a * w - c * v, C = c * _ - n * w, A = n * v - a * _, z = 2 * i[3];
        return v *= z, w *= z, C *= 2, A *= 2, t[0] = h + (_ *= z) + (T *= 2), t[1] = p + v + C, t[2] = m + w + A, t;
      }
      var Bc, qo = Gh, tg = Sp, ig = kc;
      function Cp(t, e, i) {
        return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t;
      }
      function Ap(t, e) {
        var i = e[0], n = e[1], a = e[2], c = e[3], h = i * i + n * n + a * a + c * c;
        return h > 0 && (h = 1 / Math.sqrt(h)), t[0] = i * h, t[1] = n * h, t[2] = a * h, t[3] = c * h, t;
      }
      function il(t, e, i) {
        var n = e[0], a = e[1], c = e[2], h = e[3];
        return t[0] = i[0] * n + i[4] * a + i[8] * c + i[12] * h, t[1] = i[1] * n + i[5] * a + i[9] * c + i[13] * h, t[2] = i[2] * n + i[6] * a + i[10] * c + i[14] * h, t[3] = i[3] * n + i[7] * a + i[11] * c + i[15] * h, t;
      }
      function Ip() {
        var t = new Dn(4);
        return Dn != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
      }
      function Pp(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
      }
      function Lp(t, e, i) {
        i *= 0.5;
        var n = e[0], a = e[1], c = e[2], h = e[3], p = Math.sin(i), m = Math.cos(i);
        return t[0] = n * m + h * p, t[1] = a * m + c * p, t[2] = c * m - a * p, t[3] = h * m - n * p, t;
      }
      function zp(t, e, i) {
        i *= 0.5;
        var n = e[0], a = e[1], c = e[2], h = e[3], p = Math.sin(i), m = Math.cos(i);
        return t[0] = n * m - c * p, t[1] = a * m + h * p, t[2] = c * m + n * p, t[3] = h * m - a * p, t;
      }
      Vh(), Bc = new Dn(4), Dn != Float32Array && (Bc[0] = 0, Bc[1] = 0, Bc[2] = 0, Bc[3] = 0);
      var rg = Ap;
      Vh(), Fl(1, 0, 0), Fl(0, 1, 0), Ip(), Ip(), vp();
      const ng = me([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: kp } = ng, Dp = me([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var Fc = me([{ name: "a_pos", type: "Int16", components: 2 }]);
      class Zh {
        constructor(e, i) {
          this.pos = e, this.dir = i;
        }
        intersectsPlane(e, i, n) {
          const a = So(i, this.dir);
          if (Math.abs(a) < 1e-6) return !1;
          const c = ((e[0] - this.pos[0]) * i[0] + (e[1] - this.pos[1]) * i[1] + (e[2] - this.pos[2]) * i[2]) / a;
          return n[0] = this.pos[0] + this.dir[0] * c, n[1] = this.pos[1] + this.dir[1] * c, n[2] = this.pos[2] + this.dir[2] * c, !0;
        }
        closestPointOnSphere(e, i, n) {
          if (function(C, A) {
            var z = C[0], U = C[1], q = C[2], ie = A[0], W = A[1], te = A[2];
            return Math.abs(z - ie) <= Du * Math.max(1, Math.abs(z), Math.abs(ie)) && Math.abs(U - W) <= Du * Math.max(1, Math.abs(U), Math.abs(W)) && Math.abs(q - te) <= Du * Math.max(1, Math.abs(q), Math.abs(te));
          }(this.pos, e) || i === 0) return n[0] = n[1] = n[2] = 0, !1;
          const [a, c, h] = this.dir, p = this.pos[0] - e[0], m = this.pos[1] - e[1], _ = this.pos[2] - e[2], v = a * a + c * c + h * h, w = 2 * (p * a + m * c + _ * h), T = w * w - 4 * v * (p * p + m * m + _ * _ - i * i);
          if (T < 0) {
            const C = Math.max(-w / 2, 0), A = p + a * C, z = m + c * C, U = _ + h * C, q = Math.hypot(A, z, U);
            return n[0] = A * i / q, n[1] = z * i / q, n[2] = U * i / q, !1;
          }
          {
            const C = (-w - Math.sqrt(T)) / (2 * v);
            if (C < 0) {
              const A = Math.hypot(p, m, _);
              return n[0] = p * i / A, n[1] = m * i / A, n[2] = _ * i / A, !1;
            }
            return n[0] = p + a * C, n[1] = m + c * C, n[2] = _ + h * C, !0;
          }
        }
      }
      class qh {
        constructor(e, i, n, a, c) {
          this.TL = e, this.TR = i, this.BR = n, this.BL = a, this.horizon = c;
        }
        static fromInvProjectionMatrix(e, i, n) {
          const a = [-1, 1, 1], c = [1, 1, 1], h = [1, -1, 1], p = [-1, -1, 1], m = rr(a, a, e), _ = rr(c, c, e), v = rr(h, h, e), w = rr(p, p, e);
          return new qh(m, _, v, w, i / n);
        }
      }
      class Wh {
        constructor(e, i) {
          this.points = e, this.planes = i;
        }
        static fromInvProjectionMatrix(e, i, n, a) {
          const c = Math.pow(2, n), h = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((m) => {
            const _ = il([], m, e), v = 1 / _[3] / i * c;
            return function(w, T, C) {
              return w[0] = T[0] * C[0], w[1] = T[1] * C[1], w[2] = T[2] * C[2], w[3] = T[3] * C[3], w;
            }(_, _, [v, v, a ? 1 / _[3] : v, v]);
          }), p = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((m) => {
            const _ = un([], $h([], qo([], h[m[0]], h[m[1]]), qo([], h[m[2]], h[m[1]]))), v = -So(_, h[m[1]]);
            return _.concat(v);
          });
          return new Wh(h, p);
        }
      }
      class hn {
        static fromPoints(e) {
          const i = [1 / 0, 1 / 0, 1 / 0], n = [-1 / 0, -1 / 0, -1 / 0];
          for (const a of e) Dc(i, i, a), Rc(n, n, a);
          return new hn(i, n);
        }
        static applyTransform(e, i) {
          const n = e.getCorners();
          for (let a = 0; a < n.length; ++a) rr(n[a], n[a], i);
          return hn.fromPoints(n);
        }
        constructor(e, i) {
          this.min = e, this.max = i, this.center = ro([], Gs([], this.min, this.max), 0.5);
        }
        quadrant(e) {
          const i = [e % 2 == 0, e < 2], n = Ep(this.min), a = Ep(this.max);
          for (let c = 0; c < i.length; c++) n[c] = i[c] ? this.min[c] : this.center[c], a[c] = i[c] ? this.center[c] : this.max[c];
          return a[2] = this.max[2], new hn(n, a);
        }
        distanceX(e) {
          return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
        }
        distanceY(e) {
          return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
        }
        distanceZ(e) {
          return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2];
        }
        getCorners() {
          const e = this.min, i = this.max;
          return [[e[0], e[1], e[2]], [i[0], e[1], e[2]], [i[0], i[1], e[2]], [e[0], i[1], e[2]], [e[0], e[1], i[2]], [i[0], e[1], i[2]], [i[0], i[1], i[2]], [e[0], i[1], i[2]]];
        }
        intersects(e) {
          const i = this.getCorners();
          let n = !0;
          for (let a = 0; a < e.planes.length; a++) {
            const c = e.planes[a];
            let h = 0;
            for (let p = 0; p < i.length; p++) h += So(c, i[p]) + c[3] >= 0;
            if (h === 0) return 0;
            h !== i.length && (n = !1);
          }
          if (n) return 2;
          for (let a = 0; a < 3; a++) {
            let c = Number.MAX_VALUE, h = -Number.MAX_VALUE;
            for (let p = 0; p < e.points.length; p++) {
              const m = e.points[p][a] - this.min[a];
              c = Math.min(c, m), h = Math.max(h, m);
            }
            if (h < 0 || c > this.max[a] - this.min[a]) return 0;
          }
          return 1;
        }
      }
      const Xh = 5, Rp = 6, fs = Et / Math.PI / 2, og = 16383, rl = 64, Uc = [rl, 32, 16], Mo = -fs, Co = fs, sg = [new hn([Mo, Mo, Mo], [Co, Co, Co]), new hn([Mo, Mo, Mo], [0, 0, Co]), new hn([0, Mo, Mo], [Co, 0, Co]), new hn([Mo, 0, Mo], [0, Co, Co]), new hn([0, 0, Mo], [Co, Co, Co])];
      function Ou(t) {
        return t * fs / Vc;
      }
      function Op(t, e, i, n = !0) {
        const a = ro([], t._camera.position, t.worldSize), c = [e, i, 1, 1];
        il(c, c, t.pixelMatrixInverse), Cp(c, c, 1 / c[3]);
        const h = un([], qo([], c, a)), p = t.globeMatrix, m = [p[12], p[13], p[14]], _ = qo([], m, a), v = kc(_), w = un([], _), T = t.worldSize / (2 * Math.PI), C = So(w, h), A = Math.asin(T / v);
        if (A < Math.acos(C)) {
          if (!n) return null;
          const $e = [], Ae = [];
          ro($e, h, v / C), un(Ae, qo(Ae, $e, _)), un(h, Gs(h, _, ro(h, Ae, Math.tan(A) * v)));
        }
        const z = [];
        new Zh(a, h).closestPointOnSphere(m, T, z);
        const U = un([], Vn(p, 0)), q = un([], Vn(p, 1)), ie = un([], Vn(p, 2)), W = So(U, z), te = So(q, z), ae = So(ie, z), oe = Fi(Math.asin(-te / T));
        let Se = Fi(Math.atan2(W, ae));
        Se = t.center.lng + function($e, Ae) {
          const Fe = (Ae - $e + 180) % 360 - 180;
          return Fe < -180 ? Fe + 360 : Fe;
        }(t.center.lng, Se);
        const we = _s(Se), ke = Vt(gs(oe), 0, 1);
        return new Vl(we, ke);
      }
      class ag {
        constructor(e, i, n) {
          this.a = qo([], e, n), this.b = qo([], i, n), this.center = n;
          const a = un([], this.a), c = un([], this.b);
          this.angle = Math.acos(So(a, c));
        }
      }
      function Hh(t, e) {
        if (t.angle === 0) return null;
        let i;
        return i = t.a[e] === 0 ? 1 / t.angle * 0.5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)), i < 0 || i > 1 ? null : function(n, a, c, h) {
          const p = Math.sin(c);
          return n * (Math.sin((1 - h) * c) / p) + a * (Math.sin(h * c) / p);
        }(t.a[e], t.b[e], t.angle, Vt(i, 0, 1)) + t.center[e];
      }
      function ms(t) {
        if (t.z <= 1) return sg[t.z + 2 * t.y + t.x];
        const e = Kh(Bu(t));
        return hn.fromPoints(e);
      }
      function nl(t, e, i) {
        return ro(t, t, 1 - i), Oc(t, t, e, i);
      }
      function Bp(t, e) {
        const i = jl(e.zoom);
        if (i === 0) return ms(t);
        const n = Bu(t), a = Kh(n), c = _s(n.getWest()) * e.worldSize, h = _s(n.getEast()) * e.worldSize, p = gs(n.getNorth()) * e.worldSize, m = gs(n.getSouth()) * e.worldSize, _ = [c, p, 0], v = [h, p, 0], w = [c, m, 0], T = [h, m, 0], C = Nh([], e.globeMatrix);
        return rr(_, _, C), rr(v, v, C), rr(w, w, C), rr(T, T, C), a[0] = nl(a[0], w, i), a[1] = nl(a[1], T, i), a[2] = nl(a[2], v, i), a[3] = nl(a[3], _, i), hn.fromPoints(a);
      }
      function Fp(t, e, i) {
        for (const n of t) rr(n, n, e), ro(n, n, i);
      }
      function lg(t, e, i) {
        const n = e / t.worldSize, a = t.globeMatrix;
        if (i.z <= 1) {
          const we = ms(i).getCorners();
          return Fp(we, a, n), hn.fromPoints(we);
        }
        const c = Bu(i), h = Kh(c);
        Fp(h, a, n);
        const p = Number.MAX_VALUE, m = [-p, -p, -p], _ = [p, p, p];
        if (c.contains(t.center)) {
          for (const $e of h) Dc(_, _, $e), Rc(m, m, $e);
          m[2] = 0;
          const we = t.point, ke = [we.x * n, we.y * n, 0];
          return Dc(_, _, ke), Rc(m, m, ke), new hn(_, m);
        }
        const v = [a[12] * n, a[13] * n, a[14] * n], w = c.getCenter(), T = Vt(t.center.lat, -$r, $r), C = Vt(w.lat, -$r, $r), A = _s(t.center.lng), z = gs(T);
        let U = A - _s(w.lng);
        const q = z - gs(C);
        U > 0.5 ? U -= 1 : U < -0.5 && (U += 1);
        let ie = 0;
        Math.abs(U) > Math.abs(q) ? ie = U >= 0 ? 1 : 3 : (ie = q >= 0 ? 0 : 2, Oc(v, v, [a[4] * n, a[5] * n, a[6] * n], -Math.sin(Pt(q >= 0 ? c.getSouth() : c.getNorth())) * fs));
        const W = h[ie], te = h[(ie + 1) % 4], ae = new ag(W, te, v), oe = [Hh(ae, 0) || W[0], Hh(ae, 1) || W[1], Hh(ae, 2) || W[2]], Se = jl(t.zoom);
        if (Se > 0) {
          const we = function({ x: $e, y: Ae, z: Fe }, Ue, je, Je, Le) {
            const ot = 1 / (1 << Fe);
            let yt = $e * ot, at = yt + ot, Ut = Ae * ot, Ye = Ut + ot, Tt = 0;
            const Nt = (yt + at) / 2 - Je;
            return Nt > 0.5 ? Tt = -1 : Nt < -0.5 && (Tt = 1), yt = ((yt + Tt) * Ue - (Je *= Ue)) * je + Je, at = ((at + Tt) * Ue - Je) * je + Je, Ut = (Ut * Ue - (Le *= Ue)) * je + Le, Ye = (Ye * Ue - Le) * je + Le, [[yt, Ye, 0], [at, Ye, 0], [at, Ut, 0], [yt, Ut, 0]];
          }(i, e, t._pixelsPerMercatorPixel, A, z);
          for (let $e = 0; $e < h.length; $e++) nl(h[$e], we[$e], Se);
          const ke = Gs([], we[ie], we[(ie + 1) % 4]);
          ro(ke, ke, 0.5), nl(oe, ke, Se);
        }
        for (const we of h) Dc(_, _, we), Rc(m, m, we);
        return _[2] = Math.min(W[2], te[2]), Dc(_, _, oe), Rc(m, m, oe), new hn(_, m);
      }
      function Bu({ x: t, y: e, z: i }) {
        const n = 1 / (1 << i), a = new Ci(no(t * n), Gr((e + 1) * n)), c = new Ci(no((t + 1) * n), Gr(e * n));
        return new _a(a, c);
      }
      function Kh(t) {
        const e = Pt(t.getNorth()), i = Pt(t.getSouth()), n = Math.cos(e), a = Math.cos(i), c = Math.sin(e), h = Math.sin(i), p = t.getWest(), m = t.getEast();
        return [Ul(a, h, p), Ul(a, h, m), Ul(n, c, m), Ul(n, c, p)];
      }
      function Ul(t, e, i, n = fs) {
        return i = Pt(i), [t * Math.sin(i) * n, -e * n, t * Math.cos(i) * n];
      }
      function Nl(t, e, i) {
        return Ul(Math.cos(Pt(t)), Math.sin(Pt(t)), e, i);
      }
      function Nc(t, e, i, n) {
        const a = 1 << i.z, c = (t / Et + i.x) / a;
        return Nl(Gr((e / Et + i.y) / a), no(c), n);
      }
      function Fu({ min: t, max: e }) {
        return og / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2]);
      }
      const Up = new Float64Array(16);
      function jc(t) {
        const e = Fu(t), i = wp(Up, [e, e, e]);
        return zc(i, i, ((n = [])[0] = -(a = t.min)[0], n[1] = -a[1], n[2] = -a[2], n));
        var n, a;
      }
      function Jh(t) {
        const e = (n = t.min, (i = Up)[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = n[0], i[13] = n[1], i[14] = n[2], i[15] = 1, i);
        var i, n;
        const a = 1 / Fu(t);
        return tl(e, e, [a, a, a]);
      }
      function Np(t, e, i, n, a) {
        const c = function(m) {
          const _ = Et / (2 * Math.PI);
          return m / (2 * Math.PI) / _;
        }(i), h = [t, e, -i / (2 * Math.PI)], p = Zo(new Float64Array(16));
        return zc(p, p, h), tl(p, p, [c, c, c]), jh(p, p, Pt(-a)), Ru(p, p, Pt(-n)), p;
      }
      function jl(t) {
        return Sn(Xh, Rp, t);
      }
      function jp(t, e) {
        const i = Nl(e.lat, e.lng), n = function(A) {
          const z = Nl(A._center.lat, A._center.lng);
          let U = $h([], Fl(0, 1, 0), z);
          const q = Tp([], -A.angle, z);
          U = rr(U, U, q), Tp(q, -A._pitch, U);
          const ie = un([], z);
          return ro(ie, ie, Ou(A.cameraToCenterDistance / A.pixelsPerMeter)), rr(ie, ie, q), Gs([], z, ie);
        }(t);
        return h = (a = Gh([], n, i))[0], p = a[1], m = a[2], _ = (c = i)[0], v = c[1], w = c[2], C = (T = Math.sqrt(h * h + p * p + m * m) * Math.sqrt(_ * _ + v * v + w * w)) && So(a, c) / T, Math.acos(Math.min(Math.max(C, -1), 1));
        var a, c, h, p, m, _, v, w, T, C;
      }
      function Yh(t, e) {
        return jp(t, e) > Math.PI / 2 * 1.01;
      }
      const Vp = Pt(85), cg = Math.cos(Vp), ug = Math.sin(Vp), Vc = 63710088e-1, Gp = 2 * Math.PI * Vc;
      class ga {
        constructor(e, i) {
          if (isNaN(e) || isNaN(i)) throw new Error(`Invalid LngLat object: (${e}, ${i})`);
          if (this.lng = +e, this.lat = +i, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new ga(Zi(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(e) {
          const i = Math.PI / 180, n = this.lat * i, a = e.lat * i, c = Math.sin(n) * Math.sin(a) + Math.cos(n) * Math.cos(a) * Math.cos((e.lng - this.lng) * i);
          return Vc * Math.acos(Math.min(c, 1));
        }
        toBounds(e = 0) {
          const i = 360 * e / 40075017, n = i / Math.cos(Math.PI / 180 * this.lat);
          return new _a(new ga(this.lng - n, this.lat - i), new ga(this.lng + n, this.lat + i));
        }
        toEcef(e) {
          const i = Ou(e);
          return Nl(this.lat, this.lng, fs + i);
        }
        static convert(e) {
          if (e instanceof ga) return e;
          if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new ga(Number(e[0]), Number(e[1]));
          if (!Array.isArray(e) && typeof e == "object" && e !== null) return new ga(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      var Ci = ga;
      function Qh(t) {
        return Gp * Math.cos(t * Math.PI / 180);
      }
      function _s(t) {
        return (180 + t) / 360;
      }
      function gs(t) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;
      }
      function Wo(t, e) {
        return t / Qh(e);
      }
      function no(t) {
        return 360 * t - 180;
      }
      function Gr(t) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;
      }
      function $p(t, e) {
        return t * Qh(Gr(e));
      }
      const $r = 85.051129;
      function Zp(t) {
        return 1 / Math.cos(t * Math.PI / 180);
      }
      class Vl {
        constructor(e, i, n = 0) {
          this.x = +e, this.y = +i, this.z = +n;
        }
        static fromLngLat(e, i = 0) {
          const n = Ci.convert(e);
          return new Vl(_s(n.lng), gs(n.lat), Wo(i, n.lat));
        }
        toLngLat() {
          return new Ci(no(this.x), Gr(this.y));
        }
        toAltitude() {
          return $p(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Gp * Zp(Gr(this.y));
        }
      }
      function ed(t, e, i, n, a, c, h, p, m) {
        const _ = (e + n) / 2, v = (i + a) / 2, w = new et(_, v);
        p(w), function(T, C, A, z, U, q) {
          const ie = A - U, W = z - q;
          return Math.abs((z - C) * ie - (A - T) * W) / Math.hypot(ie, W);
        }(w.x, w.y, c.x, c.y, h.x, h.y) >= m ? (ed(t, e, i, _, v, c, w, p, m), ed(t, _, v, n, a, w, h, p, m)) : t.push(h);
      }
      function qp(t, e, i) {
        let n = t[0], a = n.x, c = n.y;
        e(n);
        const h = [n];
        for (let p = 1; p < t.length; p++) {
          const m = t[p], { x: _, y: v } = m;
          e(m), ed(h, a, c, _, v, n, m, e, i), a = _, c = v, n = m;
        }
        return h;
      }
      function td(t, e, i, n) {
        if (n(e, i)) {
          const a = e.add(i)._mult(0.5);
          td(t, e, a, n), td(t, a, i, n);
        } else t.push(i);
      }
      function hg(t, e) {
        let i = t[0];
        const n = [i];
        for (let a = 1; a < t.length; a++) {
          const c = t[a];
          td(n, i, c, e), i = c;
        }
        return n;
      }
      const id = Math.pow(2, 14) - 1, Wp = -id - 1;
      function dg(t, e) {
        const i = Math.round(t.x * e), n = Math.round(t.y * e);
        return t.x = Vt(i, Wp, id), t.y = Vt(n, Wp, id), (i < t.x || i > t.x + 1 || n < t.y || n > t.y + 1) && Ui("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t;
      }
      function $s(t, e, i) {
        const n = t.loadGeometry(), a = t.extent, c = Et / a;
        if (e && i && i.projection.isReprojectedInTileSpace) {
          const h = 1 << e.z, { scale: p, x: m, y: _, projection: v } = i, w = (T) => {
            const C = no((e.x + T.x / a) / h), A = Gr((e.y + T.y / a) / h), z = v.project(C, A);
            T.x = (z.x * p - m) * a, T.y = (z.y * p - _) * a;
          };
          for (let T = 0; T < n.length; T++) if (t.type !== 1) n[T] = qp(n[T], w, 1);
          else {
            const C = [];
            for (const A of n[T]) A.x < 0 || A.x >= a || A.y < 0 || A.y >= a || (w(A), C.push(A));
            n[T] = C;
          }
        }
        for (const h of n) for (const p of h) dg(p, c);
        return n;
      }
      function ol(t, e) {
        return { type: t.type, id: t.id, properties: t.properties, geometry: e ? $s(t) : [] };
      }
      function Uu(t, e, i, n, a) {
        t.emplaceBack(2 * e + (n + 1) / 2, 2 * i + (a + 1) / 2);
      }
      function Nu(t, e, i) {
        t.emplaceBack(e.x, e.y, e.z, i[0] * 16384, i[1] * 16384, i[2] * 16384);
      }
      class rd {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((i) => i.id), this.index = e.index, this.hasPattern = !1, this.projection = e.projection, this.layoutVertexArray = new Ge(), this.indexArray = new vt(), this.segments = new ur(), this.programConfigurations = new Qa(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id);
        }
        populate(e, i, n, a) {
          const c = this.layers[0], h = [];
          let p = null;
          c.type === "circle" && (p = c.layout.get("circle-sort-key"));
          for (const { feature: _, id: v, index: w, sourceLayerIndex: T } of e) {
            const C = this.layers[0]._featureFilter.needGeometry, A = ol(_, C);
            if (!this.layers[0]._featureFilter.filter(new b(this.zoom), A, n)) continue;
            const z = p ? p.evaluate(A, {}, n) : void 0, U = { id: v, properties: _.properties, type: _.type, sourceLayerIndex: T, index: w, geometry: C ? A.geometry : $s(_, n, a), patterns: {}, sortKey: z };
            h.push(U);
          }
          p && h.sort((_, v) => _.sortKey - v.sortKey);
          let m = null;
          a.projection.name === "globe" && (this.globeExtVertexArray = new We(), m = a.projection);
          for (const _ of h) {
            const { geometry: v, index: w, sourceLayerIndex: T } = _, C = e[w].feature;
            this.addFeature(_, v, w, i.availableImages, n, m), i.featureIndex.insert(C, v, w, T, this.index);
          }
        }
        update(e, i, n, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, i, this.stateDependentLayers, n, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Y_.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, Q_.members))), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(e, i, n, a, c, h) {
          for (const p of i) for (const m of p) {
            const _ = m.x, v = m.y;
            if (_ < 0 || _ >= Et || v < 0 || v >= Et) continue;
            if (h) {
              const C = h.projectTilePoint(_, v, c), A = h.upVector(c, _, v), z = this.globeExtVertexArray;
              Nu(z, C, A), Nu(z, C, A), Nu(z, C, A), Nu(z, C, A);
            }
            const w = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), T = w.vertexLength;
            Uu(this.layoutVertexArray, _, v, -1, -1), Uu(this.layoutVertexArray, _, v, 1, -1), Uu(this.layoutVertexArray, _, v, 1, 1), Uu(this.layoutVertexArray, _, v, -1, 1), this.indexArray.emplaceBack(T, T + 1, T + 2), this.indexArray.emplaceBack(T, T + 2, T + 3), w.vertexLength += 4, w.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, {}, a, c);
        }
      }
      function Xp(t, e) {
        for (let i = 0; i < t.length; i++) if (sl(e, t[i])) return !0;
        for (let i = 0; i < e.length; i++) if (sl(t, e[i])) return !0;
        return !!nd(t, e);
      }
      function pg(t, e, i) {
        return !!sl(t, e) || !!od(e, t, i);
      }
      function Hp(t, e) {
        if (t.length === 1) return Jp(e, t[0]);
        for (let i = 0; i < e.length; i++) {
          const n = e[i];
          for (let a = 0; a < n.length; a++) if (sl(t, n[a])) return !0;
        }
        for (let i = 0; i < t.length; i++) if (Jp(e, t[i])) return !0;
        for (let i = 0; i < e.length; i++) if (nd(t, e[i])) return !0;
        return !1;
      }
      function fg(t, e, i) {
        if (t.length > 1) {
          if (nd(t, e)) return !0;
          for (let n = 0; n < e.length; n++) if (od(e[n], t, i)) return !0;
        }
        for (let n = 0; n < t.length; n++) if (od(t[n], e, i)) return !0;
        return !1;
      }
      function nd(t, e) {
        if (t.length === 0 || e.length === 0) return !1;
        for (let i = 0; i < t.length - 1; i++) {
          const n = t[i], a = t[i + 1];
          for (let c = 0; c < e.length - 1; c++) if (mg(n, a, e[c], e[c + 1])) return !0;
        }
        return !1;
      }
      function mg(t, e, i, n) {
        return oi(t, i, n) !== oi(e, i, n) && oi(t, e, i) !== oi(t, e, n);
      }
      function od(t, e, i) {
        const n = i * i;
        if (e.length === 1) return t.distSqr(e[0]) < n;
        for (let a = 1; a < e.length; a++) if (Kp(t, e[a - 1], e[a]) < n) return !0;
        return !1;
      }
      function Kp(t, e, i) {
        const n = e.distSqr(i);
        if (n === 0) return t.distSqr(e);
        const a = ((t.x - e.x) * (i.x - e.x) + (t.y - e.y) * (i.y - e.y)) / n;
        return t.distSqr(a < 0 ? e : a > 1 ? i : i.sub(e)._mult(a)._add(e));
      }
      function Jp(t, e) {
        let i, n, a, c = !1;
        for (let h = 0; h < t.length; h++) {
          i = t[h];
          for (let p = 0, m = i.length - 1; p < i.length; m = p++) n = i[p], a = i[m], n.y > e.y != a.y > e.y && e.x < (a.x - n.x) * (e.y - n.y) / (a.y - n.y) + n.x && (c = !c);
        }
        return c;
      }
      function sl(t, e) {
        let i = !1;
        for (let n = 0, a = t.length - 1; n < t.length; a = n++) {
          const c = t[n], h = t[a];
          c.y > e.y != h.y > e.y && e.x < (h.x - c.x) * (e.y - c.y) / (h.y - c.y) + c.x && (i = !i);
        }
        return i;
      }
      function Yp(t, e, i, n, a) {
        for (const h of t) if (e <= h.x && i <= h.y && n >= h.x && a >= h.y) return !0;
        const c = [new et(e, i), new et(e, a), new et(n, a), new et(n, i)];
        if (t.length > 2) {
          for (const h of c) if (sl(t, h)) return !0;
        }
        for (let h = 0; h < t.length - 1; h++) if (_g(t[h], t[h + 1], c)) return !0;
        return !1;
      }
      function _g(t, e, i) {
        const n = i[0], a = i[2];
        if (t.x < n.x && e.x < n.x || t.x > a.x && e.x > a.x || t.y < n.y && e.y < n.y || t.y > a.y && e.y > a.y) return !1;
        const c = oi(t, e, i[0]);
        return c !== oi(t, e, i[1]) || c !== oi(t, e, i[2]) || c !== oi(t, e, i[3]);
      }
      function Gl(t, e, i) {
        const n = e.paint.get(t).value;
        return n.kind === "constant" ? n.value : i.programConfigurations.get(e.id).getMaxValue(t);
      }
      function ju(t) {
        return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
      }
      function Qp(t, e, i, n, a) {
        if (!e[0] && !e[1]) return t;
        const c = et.convert(e)._mult(a);
        i === "viewport" && c._rotate(-n);
        const h = [];
        for (let p = 0; p < t.length; p++) h.push(t[p].sub(c));
        return h;
      }
      function ef(t, e, i, n) {
        const a = et.convert(t)._mult(n);
        return e === "viewport" && a._rotate(-i), a;
      }
      _t(rd, "CircleBucket", { omit: ["layers"] });
      const gg = new K({ "circle-sort-key": new N(Pe.layout_circle["circle-sort-key"]) });
      var yg = { paint: new K({ "circle-radius": new N(Pe.paint_circle["circle-radius"]), "circle-color": new N(Pe.paint_circle["circle-color"]), "circle-blur": new N(Pe.paint_circle["circle-blur"]), "circle-opacity": new N(Pe.paint_circle["circle-opacity"]), "circle-translate": new L(Pe.paint_circle["circle-translate"]), "circle-translate-anchor": new L(Pe.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new L(Pe.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new L(Pe.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new N(Pe.paint_circle["circle-stroke-width"]), "circle-stroke-color": new N(Pe.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new N(Pe.paint_circle["circle-stroke-opacity"]) }), layout: gg };
      function tf(t, e, i, n, a, c, h, p, m) {
        if (c && t.queryGeometry.isAboveHorizon) return !1;
        c && (m *= t.pixelToTileUnitsFactor);
        const _ = t.tileID.canonical, v = i.projection.upVectorScale(_, i.center.lat, i.worldSize).metersToTile;
        for (const w of e) for (const T of w) {
          const C = T.add(p), A = a && i.elevation ? i.elevation.exaggeration() * a.getElevationAt(C.x, C.y, !0) : 0, z = i.projection.projectTilePoint(C.x, C.y, _);
          if (A > 0) {
            const W = i.projection.upVector(_, C.x, C.y);
            z.x += W[0] * v * A, z.y += W[1] * v * A, z.z += W[2] * v * A;
          }
          const U = c ? C : xg(z.x, z.y, z.z, n), q = c ? t.tilespaceRays.map((W) => bg(W, A)) : t.queryGeometry.screenGeometry, ie = il([], [z.x, z.y, z.z, 1], n);
          if (!h && c ? m *= ie[3] / i.cameraToCenterDistance : h && !c && (m *= i.cameraToCenterDistance / ie[3]), c) {
            const W = Gr((T.y / Et + _.y) / (1 << _.z));
            m /= i.projection.pixelsPerMeter(W, 1) / Wo(1, W);
          }
          if (pg(q, U, m)) return !0;
        }
        return !1;
      }
      function xg(t, e, i, n) {
        const a = il([], [t, e, i, 1], n);
        return new et(a[0] / a[3], a[1] / a[3]);
      }
      const rf = Fl(0, 0, 0), vg = Fl(0, 0, 1);
      function bg(t, e) {
        const i = Vh();
        return rf[2] = e, t.intersectsPlane(rf, vg, i), new et(i[0], i[1]);
      }
      class nf extends rd {
      }
      function of(t, { width: e, height: i }, n, a) {
        if (a) {
          if (a instanceof Uint8ClampedArray) a = new Uint8Array(a.buffer);
          else if (a.length !== e * i * n) throw new RangeError("mismatched image size");
        } else a = new Uint8Array(e * i * n);
        return t.width = e, t.height = i, t.data = a, t;
      }
      function sf(t, e, i) {
        const { width: n, height: a } = e;
        n === t.width && a === t.height || (sd(t, e, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t.width, n), height: Math.min(t.height, a) }, i), t.width = n, t.height = a, t.data = e.data);
      }
      function sd(t, e, i, n, a, c) {
        if (a.width === 0 || a.height === 0) return e;
        if (a.width > t.width || a.height > t.height || i.x > t.width - a.width || i.y > t.height - a.height) throw new RangeError("out of range source coordinates for image copy");
        if (a.width > e.width || a.height > e.height || n.x > e.width - a.width || n.y > e.height - a.height) throw new RangeError("out of range destination coordinates for image copy");
        const h = t.data, p = e.data;
        for (let m = 0; m < a.height; m++) {
          const _ = ((i.y + m) * t.width + i.x) * c, v = ((n.y + m) * e.width + n.x) * c;
          for (let w = 0; w < a.width * c; w++) p[v + w] = h[_ + w];
        }
        return e;
      }
      _t(nf, "HeatmapBucket", { omit: ["layers"] });
      class Zs {
        constructor(e, i) {
          of(this, e, 1, i);
        }
        resize(e) {
          sf(this, new Zs(e), 1);
        }
        clone() {
          return new Zs({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, i, n, a, c) {
          sd(e, i, n, a, c, 1);
        }
      }
      class Rn {
        constructor(e, i) {
          of(this, e, 4, i);
        }
        resize(e) {
          sf(this, new Rn(e), 4);
        }
        replace(e, i) {
          i ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
        }
        clone() {
          return new Rn({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, i, n, a, c) {
          sd(e, i, n, a, c, 4);
        }
      }
      _t(Zs, "AlphaImage"), _t(Rn, "RGBAImage");
      var wg = { paint: new K({ "heatmap-radius": new N(Pe.paint_heatmap["heatmap-radius"]), "heatmap-weight": new N(Pe.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new L(Pe.paint_heatmap["heatmap-intensity"]), "heatmap-color": new X(Pe.paint_heatmap["heatmap-color"]), "heatmap-opacity": new L(Pe.paint_heatmap["heatmap-opacity"]) }) };
      function ad(t) {
        const e = {}, i = t.resolution || 256, n = t.clips ? t.clips.length : 1, a = t.image || new Rn({ width: i, height: n }), c = (h, p, m) => {
          e[t.evaluationKey] = m;
          const _ = t.expression.evaluate(e);
          a.data[h + p + 0] = Math.floor(255 * _.r / _.a), a.data[h + p + 1] = Math.floor(255 * _.g / _.a), a.data[h + p + 2] = Math.floor(255 * _.b / _.a), a.data[h + p + 3] = Math.floor(255 * _.a);
        };
        if (t.clips) for (let h = 0, p = 0; h < n; ++h, p += 4 * i) for (let m = 0, _ = 0; m < i; m++, _ += 4) {
          const v = m / (i - 1), { start: w, end: T } = t.clips[h];
          c(p, _, w * (1 - v) + T * v);
        }
        else for (let h = 0, p = 0; h < i; h++, p += 4) c(0, p, h / (i - 1));
        return a;
      }
      var Tg = { paint: new K({ "hillshade-illumination-direction": new L(Pe.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new L(Pe.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new L(Pe.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new L(Pe.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new L(Pe.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new L(Pe.paint_hillshade["hillshade-accent-color"]) }) };
      const Eg = me([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Sg } = Eg;
      var ld = { exports: {} };
      function Vu(t, e, i) {
        i = i || 2;
        var n, a, c, h, p, m, _, v = e && e.length, w = v ? e[0] * i : t.length, T = af(t, 0, w, i, !0), C = [];
        if (!T || T.next === T.prev) return C;
        if (v && (T = function(z, U, q, ie) {
          var W, te, ae, oe = [];
          for (W = 0, te = U.length; W < te; W++) (ae = af(z, U[W] * ie, W < te - 1 ? U[W + 1] * ie : z.length, ie, !1)) === ae.next && (ae.steiner = !0), oe.push(kg(ae));
          for (oe.sort(Pg), W = 0; W < oe.length; W++) q = Lg(oe[W], q);
          return q;
        }(t, e, T, i)), t.length > 80 * i) {
          n = c = t[0], a = h = t[1];
          for (var A = i; A < w; A += i) (p = t[A]) < n && (n = p), (m = t[A + 1]) < a && (a = m), p > c && (c = p), m > h && (h = m);
          _ = (_ = Math.max(c - n, h - a)) !== 0 ? 32767 / _ : 0;
        }
        return Gc(T, C, i, n, a, _, 0), C;
      }
      function af(t, e, i, n, a) {
        var c, h;
        if (a === hd(t, e, i, n) > 0) for (c = e; c < i; c += n) h = uf(c, t[c], t[c + 1], h);
        else for (c = i - n; c >= e; c -= n) h = uf(c, t[c], t[c + 1], h);
        return h && Gu(h, h.next) && (Zc(h), h = h.next), h;
      }
      function al(t, e) {
        if (!t) return t;
        e || (e = t);
        var i, n = t;
        do
          if (i = !1, n.steiner || !Gu(n, n.next) && hr(n.prev, n, n.next) !== 0) n = n.next;
          else {
            if (Zc(n), (n = e = n.prev) === n.next) break;
            i = !0;
          }
        while (i || n !== e);
        return e;
      }
      function Gc(t, e, i, n, a, c, h) {
        if (t) {
          !h && c && function(v, w, T, C) {
            var A = v;
            do
              A.z === 0 && (A.z = cd(A.x, A.y, w, T, C)), A.prevZ = A.prev, A.nextZ = A.next, A = A.next;
            while (A !== v);
            A.prevZ.nextZ = null, A.prevZ = null, function(z) {
              var U, q, ie, W, te, ae, oe, Se, we = 1;
              do {
                for (q = z, z = null, te = null, ae = 0; q; ) {
                  for (ae++, ie = q, oe = 0, U = 0; U < we && (oe++, ie = ie.nextZ); U++) ;
                  for (Se = we; oe > 0 || Se > 0 && ie; ) oe !== 0 && (Se === 0 || !ie || q.z <= ie.z) ? (W = q, q = q.nextZ, oe--) : (W = ie, ie = ie.nextZ, Se--), te ? te.nextZ = W : z = W, W.prevZ = te, te = W;
                  q = ie;
                }
                te.nextZ = null, we *= 2;
              } while (ae > 1);
            }(A);
          }(t, n, a, c);
          for (var p, m, _ = t; t.prev !== t.next; ) if (p = t.prev, m = t.next, c ? Cg(t, n, a, c) : Mg(t)) e.push(p.i / i | 0), e.push(t.i / i | 0), e.push(m.i / i | 0), Zc(t), t = m.next, _ = m.next;
          else if ((t = m) === _) {
            h ? h === 1 ? Gc(t = Ag(al(t), e, i), e, i, n, a, c, 2) : h === 2 && Ig(t, e, i, n, a, c) : Gc(al(t), e, i, n, a, c, 1);
            break;
          }
        }
      }
      function Mg(t) {
        var e = t.prev, i = t, n = t.next;
        if (hr(e, i, n) >= 0) return !1;
        for (var a = e.x, c = i.x, h = n.x, p = e.y, m = i.y, _ = n.y, v = a < c ? a < h ? a : h : c < h ? c : h, w = p < m ? p < _ ? p : _ : m < _ ? m : _, T = a > c ? a > h ? a : h : c > h ? c : h, C = p > m ? p > _ ? p : _ : m > _ ? m : _, A = n.next; A !== e; ) {
          if (A.x >= v && A.x <= T && A.y >= w && A.y <= C && $l(a, p, c, m, h, _, A.x, A.y) && hr(A.prev, A, A.next) >= 0) return !1;
          A = A.next;
        }
        return !0;
      }
      function Cg(t, e, i, n) {
        var a = t.prev, c = t, h = t.next;
        if (hr(a, c, h) >= 0) return !1;
        for (var p = a.x, m = c.x, _ = h.x, v = a.y, w = c.y, T = h.y, C = p < m ? p < _ ? p : _ : m < _ ? m : _, A = v < w ? v < T ? v : T : w < T ? w : T, z = p > m ? p > _ ? p : _ : m > _ ? m : _, U = v > w ? v > T ? v : T : w > T ? w : T, q = cd(C, A, e, i, n), ie = cd(z, U, e, i, n), W = t.prevZ, te = t.nextZ; W && W.z >= q && te && te.z <= ie; ) {
          if (W.x >= C && W.x <= z && W.y >= A && W.y <= U && W !== a && W !== h && $l(p, v, m, w, _, T, W.x, W.y) && hr(W.prev, W, W.next) >= 0 || (W = W.prevZ, te.x >= C && te.x <= z && te.y >= A && te.y <= U && te !== a && te !== h && $l(p, v, m, w, _, T, te.x, te.y) && hr(te.prev, te, te.next) >= 0)) return !1;
          te = te.nextZ;
        }
        for (; W && W.z >= q; ) {
          if (W.x >= C && W.x <= z && W.y >= A && W.y <= U && W !== a && W !== h && $l(p, v, m, w, _, T, W.x, W.y) && hr(W.prev, W, W.next) >= 0) return !1;
          W = W.prevZ;
        }
        for (; te && te.z <= ie; ) {
          if (te.x >= C && te.x <= z && te.y >= A && te.y <= U && te !== a && te !== h && $l(p, v, m, w, _, T, te.x, te.y) && hr(te.prev, te, te.next) >= 0) return !1;
          te = te.nextZ;
        }
        return !0;
      }
      function Ag(t, e, i) {
        var n = t;
        do {
          var a = n.prev, c = n.next.next;
          !Gu(a, c) && lf(a, n, n.next, c) && $c(a, c) && $c(c, a) && (e.push(a.i / i | 0), e.push(n.i / i | 0), e.push(c.i / i | 0), Zc(n), Zc(n.next), n = t = c), n = n.next;
        } while (n !== t);
        return al(n);
      }
      function Ig(t, e, i, n, a, c) {
        var h = t;
        do {
          for (var p = h.next.next; p !== h.prev; ) {
            if (h.i !== p.i && Dg(h, p)) {
              var m = cf(h, p);
              return h = al(h, h.next), m = al(m, m.next), Gc(h, e, i, n, a, c, 0), void Gc(m, e, i, n, a, c, 0);
            }
            p = p.next;
          }
          h = h.next;
        } while (h !== t);
      }
      function Pg(t, e) {
        return t.x - e.x;
      }
      function Lg(t, e) {
        var i = function(a, c) {
          var h, p = c, m = a.x, _ = a.y, v = -1 / 0;
          do {
            if (_ <= p.y && _ >= p.next.y && p.next.y !== p.y) {
              var w = p.x + (_ - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
              if (w <= m && w > v && (v = w, h = p.x < p.next.x ? p : p.next, w === m)) return h;
            }
            p = p.next;
          } while (p !== c);
          if (!h) return null;
          var T, C = h, A = h.x, z = h.y, U = 1 / 0;
          p = h;
          do
            m >= p.x && p.x >= A && m !== p.x && $l(_ < z ? m : v, _, A, z, _ < z ? v : m, _, p.x, p.y) && (T = Math.abs(_ - p.y) / (m - p.x), $c(p, a) && (T < U || T === U && (p.x > h.x || p.x === h.x && zg(h, p))) && (h = p, U = T)), p = p.next;
          while (p !== C);
          return h;
        }(t, e);
        if (!i) return e;
        var n = cf(i, t);
        return al(n, n.next), al(i, i.next);
      }
      function zg(t, e) {
        return hr(t.prev, t, e.prev) < 0 && hr(e.next, t, t.next) < 0;
      }
      function cd(t, e, i, n, a) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * a | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * a | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
      }
      function kg(t) {
        var e = t, i = t;
        do
          (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next;
        while (e !== t);
        return i;
      }
      function $l(t, e, i, n, a, c, h, p) {
        return (a - h) * (e - p) >= (t - h) * (c - p) && (t - h) * (n - p) >= (i - h) * (e - p) && (i - h) * (c - p) >= (a - h) * (n - p);
      }
      function Dg(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && !function(i, n) {
          var a = i;
          do {
            if (a.i !== i.i && a.next.i !== i.i && a.i !== n.i && a.next.i !== n.i && lf(a, a.next, i, n)) return !0;
            a = a.next;
          } while (a !== i);
          return !1;
        }(t, e) && ($c(t, e) && $c(e, t) && function(i, n) {
          var a = i, c = !1, h = (i.x + n.x) / 2, p = (i.y + n.y) / 2;
          do
            a.y > p != a.next.y > p && a.next.y !== a.y && h < (a.next.x - a.x) * (p - a.y) / (a.next.y - a.y) + a.x && (c = !c), a = a.next;
          while (a !== i);
          return c;
        }(t, e) && (hr(t.prev, t, e.prev) || hr(t, e.prev, e)) || Gu(t, e) && hr(t.prev, t, t.next) > 0 && hr(e.prev, e, e.next) > 0);
      }
      function hr(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
      }
      function Gu(t, e) {
        return t.x === e.x && t.y === e.y;
      }
      function lf(t, e, i, n) {
        var a = Zu(hr(t, e, i)), c = Zu(hr(t, e, n)), h = Zu(hr(i, n, t)), p = Zu(hr(i, n, e));
        return a !== c && h !== p || !(a !== 0 || !$u(t, i, e)) || !(c !== 0 || !$u(t, n, e)) || !(h !== 0 || !$u(i, t, n)) || !(p !== 0 || !$u(i, e, n));
      }
      function $u(t, e, i) {
        return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y);
      }
      function Zu(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      }
      function $c(t, e) {
        return hr(t.prev, t, t.next) < 0 ? hr(t, e, t.next) >= 0 && hr(t, t.prev, e) >= 0 : hr(t, e, t.prev) < 0 || hr(t, t.next, e) < 0;
      }
      function cf(t, e) {
        var i = new ud(t.i, t.x, t.y), n = new ud(e.i, e.x, e.y), a = t.next, c = e.prev;
        return t.next = e, e.prev = t, i.next = a, a.prev = i, n.next = i, i.prev = n, c.next = n, n.prev = c, n;
      }
      function uf(t, e, i, n) {
        var a = new ud(t, e, i);
        return n ? (a.next = n.next, a.prev = n, n.next.prev = a, n.next = a) : (a.prev = a, a.next = a), a;
      }
      function Zc(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
      }
      function ud(t, e, i) {
        this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
      }
      function hd(t, e, i, n) {
        for (var a = 0, c = e, h = i - n; c < i; c += n) a += (t[h] - t[c]) * (t[c + 1] + t[h + 1]), h = c;
        return a;
      }
      ld.exports = Vu, ld.exports.default = Vu, Vu.deviation = function(t, e, i, n) {
        var a = e && e.length, c = Math.abs(hd(t, 0, a ? e[0] * i : t.length, i));
        if (a) for (var h = 0, p = e.length; h < p; h++) c -= Math.abs(hd(t, e[h] * i, h < p - 1 ? e[h + 1] * i : t.length, i));
        var m = 0;
        for (h = 0; h < n.length; h += 3) {
          var _ = n[h] * i, v = n[h + 1] * i, w = n[h + 2] * i;
          m += Math.abs((t[_] - t[w]) * (t[v + 1] - t[_ + 1]) - (t[_] - t[v]) * (t[w + 1] - t[_ + 1]));
        }
        return c === 0 && m === 0 ? 0 : Math.abs((m - c) / c);
      }, Vu.flatten = function(t) {
        for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, n = 0, a = 0; a < t.length; a++) {
          for (var c = 0; c < t[a].length; c++) for (var h = 0; h < e; h++) i.vertices.push(t[a][c][h]);
          a > 0 && i.holes.push(n += t[a - 1].length);
        }
        return i;
      };
      var dd = St(ld.exports);
      function Rg(t, e, i, n, a) {
        hf(t, e, i, n || t.length - 1, a || Og);
      }
      function hf(t, e, i, n, a) {
        for (; n > i; ) {
          if (n - i > 600) {
            var c = n - i + 1, h = e - i + 1, p = Math.log(c), m = 0.5 * Math.exp(2 * p / 3), _ = 0.5 * Math.sqrt(p * m * (c - m) / c) * (h - c / 2 < 0 ? -1 : 1);
            hf(t, e, Math.max(i, Math.floor(e - h * m / c + _)), Math.min(n, Math.floor(e + (c - h) * m / c + _)), a);
          }
          var v = t[e], w = i, T = n;
          for (qc(t, i, e), a(t[n], v) > 0 && qc(t, i, n); w < T; ) {
            for (qc(t, w, T), w++, T--; a(t[w], v) < 0; ) w++;
            for (; a(t[T], v) > 0; ) T--;
          }
          a(t[i], v) === 0 ? qc(t, i, T) : qc(t, ++T, n), T <= e && (i = T + 1), e <= T && (n = T - 1);
        }
      }
      function qc(t, e, i) {
        var n = t[e];
        t[e] = t[i], t[i] = n;
      }
      function Og(t, e) {
        return t < e ? -1 : t > e ? 1 : 0;
      }
      function pd(t, e) {
        const i = t.length;
        if (i <= 1) return [t];
        const n = [];
        let a, c;
        for (let h = 0; h < i; h++) {
          const p = ws(t[h]);
          p !== 0 && (t[h].area = Math.abs(p), c === void 0 && (c = p < 0), c === p < 0 ? (a && n.push(a), a = [t[h]]) : a.push(t[h]));
        }
        if (a && n.push(a), e > 1) for (let h = 0; h < n.length; h++) n[h].length <= e || (Rg(n[h], e, 1, n[h].length - 1, Bg), n[h] = n[h].slice(0, e));
        return n;
      }
      function Bg(t, e) {
        return e.area - t.area;
      }
      function fd(t, e, i) {
        const n = i.patternDependencies;
        let a = !1;
        for (const c of e) {
          const h = c.paint.get(`${t}-pattern`);
          h.isConstant() || (a = !0);
          const p = h.constantOr(null);
          p && (a = !0, n[p] = !0);
        }
        return a;
      }
      function md(t, e, i, n, a) {
        const c = a.patternDependencies;
        for (const h of e) {
          const p = h.paint.get(`${t}-pattern`).value;
          if (p.kind !== "constant") {
            let m = p.evaluate({ zoom: n }, i, {}, a.availableImages);
            m = m && m.name ? m.name : m, c[m] = !0, i.patterns[h.id] = m;
          }
        }
        return i;
      }
      class qu {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((i) => i.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Ge(), this.indexArray = new vt(), this.indexArray2 = new Er(), this.programConfigurations = new Qa(e.layers, e.zoom), this.segments = new ur(), this.segments2 = new ur(), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id), this.projection = e.projection;
        }
        populate(e, i, n, a) {
          this.hasPattern = fd("fill", this.layers, i);
          const c = this.layers[0].layout.get("fill-sort-key"), h = [];
          for (const { feature: p, id: m, index: _, sourceLayerIndex: v } of e) {
            const w = this.layers[0]._featureFilter.needGeometry, T = ol(p, w);
            if (!this.layers[0]._featureFilter.filter(new b(this.zoom), T, n)) continue;
            const C = c ? c.evaluate(T, {}, n, i.availableImages) : void 0, A = { id: m, properties: p.properties, type: p.type, sourceLayerIndex: v, index: _, geometry: w ? T.geometry : $s(p, n, a), patterns: {}, sortKey: C };
            h.push(A);
          }
          c && h.sort((p, m) => p.sortKey - m.sortKey);
          for (const p of h) {
            const { geometry: m, index: _, sourceLayerIndex: v } = p;
            if (this.hasPattern) {
              const w = md("fill", this.layers, p, this.zoom, i);
              this.patternFeatures.push(w);
            } else this.addFeature(p, m, _, n, {}, i.availableImages);
            i.featureIndex.insert(e[_].feature, m, _, v, this.index);
          }
        }
        update(e, i, n, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, i, this.stateDependentLayers, n, a);
        }
        addFeatures(e, i, n, a, c) {
          for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, i, n, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Sg), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(e, i, n, a, c, h = []) {
          for (const p of pd(i, 500)) {
            let m = 0;
            for (const A of p) m += A.length;
            const _ = this.segments.prepareSegment(m, this.layoutVertexArray, this.indexArray), v = _.vertexLength, w = [], T = [];
            for (const A of p) {
              if (A.length === 0) continue;
              A !== p[0] && T.push(w.length / 2);
              const z = this.segments2.prepareSegment(A.length, this.layoutVertexArray, this.indexArray2), U = z.vertexLength;
              this.layoutVertexArray.emplaceBack(A[0].x, A[0].y), this.indexArray2.emplaceBack(U + A.length - 1, U), w.push(A[0].x), w.push(A[0].y);
              for (let q = 1; q < A.length; q++) this.layoutVertexArray.emplaceBack(A[q].x, A[q].y), this.indexArray2.emplaceBack(U + q - 1, U + q), w.push(A[q].x), w.push(A[q].y);
              z.vertexLength += A.length, z.primitiveLength += A.length;
            }
            const C = dd(w, T);
            for (let A = 0; A < C.length; A += 3) this.indexArray.emplaceBack(v + C[A], v + C[A + 1], v + C[A + 2]);
            _.vertexLength += m, _.primitiveLength += C.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, c, h, a);
        }
      }
      _t(qu, "FillBucket", { omit: ["layers", "patternFeatures"] });
      const Fg = new K({ "fill-sort-key": new N(Pe.layout_fill["fill-sort-key"]) });
      var Ug = { paint: new K({ "fill-antialias": new L(Pe.paint_fill["fill-antialias"]), "fill-opacity": new N(Pe.paint_fill["fill-opacity"]), "fill-color": new N(Pe.paint_fill["fill-color"]), "fill-outline-color": new N(Pe.paint_fill["fill-outline-color"]), "fill-translate": new L(Pe.paint_fill["fill-translate"]), "fill-translate-anchor": new L(Pe.paint_fill["fill-translate-anchor"]), "fill-pattern": new N(Pe.paint_fill["fill-pattern"]) }), layout: Fg };
      const Ng = me([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), jg = me([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Vg = me([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Gg } = Ng;
      var Wu = {}, $g = ui, df = Zl;
      function Zl(t, e, i, n, a) {
        this.properties = {}, this.extent = i, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = a, t.readFields(Zg, this, e);
      }
      function Zg(t, e, i) {
        t == 1 ? e.id = i.readVarint() : t == 2 ? function(n, a) {
          for (var c = n.readVarint() + n.pos; n.pos < c; ) {
            var h = a._keys[n.readVarint()], p = a._values[n.readVarint()];
            a.properties[h] = p;
          }
        }(i, e) : t == 3 ? e.type = i.readVarint() : t == 4 && (e._geometry = i.pos);
      }
      function qg(t) {
        for (var e, i, n = 0, a = 0, c = t.length, h = c - 1; a < c; h = a++) n += ((i = t[h]).x - (e = t[a]).x) * (e.y + i.y);
        return n;
      }
      Zl.types = ["Unknown", "Point", "LineString", "Polygon"], Zl.prototype.loadGeometry = function() {
        var t = this._pbf;
        t.pos = this._geometry;
        for (var e, i = t.readVarint() + t.pos, n = 1, a = 0, c = 0, h = 0, p = []; t.pos < i; ) {
          if (a <= 0) {
            var m = t.readVarint();
            n = 7 & m, a = m >> 3;
          }
          if (a--, n === 1 || n === 2) c += t.readSVarint(), h += t.readSVarint(), n === 1 && (e && p.push(e), e = []), e.push(new $g(c, h));
          else {
            if (n !== 7) throw new Error("unknown command " + n);
            e && e.push(e[0].clone());
          }
        }
        return e && p.push(e), p;
      }, Zl.prototype.bbox = function() {
        var t = this._pbf;
        t.pos = this._geometry;
        for (var e = t.readVarint() + t.pos, i = 1, n = 0, a = 0, c = 0, h = 1 / 0, p = -1 / 0, m = 1 / 0, _ = -1 / 0; t.pos < e; ) {
          if (n <= 0) {
            var v = t.readVarint();
            i = 7 & v, n = v >> 3;
          }
          if (n--, i === 1 || i === 2) (a += t.readSVarint()) < h && (h = a), a > p && (p = a), (c += t.readSVarint()) < m && (m = c), c > _ && (_ = c);
          else if (i !== 7) throw new Error("unknown command " + i);
        }
        return [h, m, p, _];
      }, Zl.prototype.toGeoJSON = function(t, e, i) {
        var n, a, c = this.extent * Math.pow(2, i), h = this.extent * t, p = this.extent * e, m = this.loadGeometry(), _ = Zl.types[this.type];
        function v(C) {
          for (var A = 0; A < C.length; A++) {
            var z = C[A];
            C[A] = [360 * (z.x + h) / c - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (z.y + p) / c) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var w = [];
            for (n = 0; n < m.length; n++) w[n] = m[n][0];
            v(m = w);
            break;
          case 2:
            for (n = 0; n < m.length; n++) v(m[n]);
            break;
          case 3:
            for (m = function(C) {
              var A = C.length;
              if (A <= 1) return [C];
              for (var z, U, q = [], ie = 0; ie < A; ie++) {
                var W = qg(C[ie]);
                W !== 0 && (U === void 0 && (U = W < 0), U === W < 0 ? (z && q.push(z), z = [C[ie]]) : z.push(C[ie]));
              }
              return z && q.push(z), q;
            }(m), n = 0; n < m.length; n++) for (a = 0; a < m[n].length; a++) v(m[n][a]);
        }
        m.length === 1 ? m = m[0] : _ = "Multi" + _;
        var T = { type: "Feature", geometry: { type: _, coordinates: m }, properties: this.properties };
        return "id" in this && (T.id = this.id), T;
      };
      var Wg = df, pf = ff;
      function ff(t, e) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(Xg, this, e), this.length = this._features.length;
      }
      function Xg(t, e, i) {
        t === 15 ? e.version = i.readVarint() : t === 1 ? e.name = i.readString() : t === 5 ? e.extent = i.readVarint() : t === 2 ? e._features.push(i.pos) : t === 3 ? e._keys.push(i.readString()) : t === 4 && e._values.push(function(n) {
          for (var a = null, c = n.readVarint() + n.pos; n.pos < c; ) {
            var h = n.readVarint() >> 3;
            a = h === 1 ? n.readString() : h === 2 ? n.readFloat() : h === 3 ? n.readDouble() : h === 4 ? n.readVarint64() : h === 5 ? n.readVarint() : h === 6 ? n.readSVarint() : h === 7 ? n.readBoolean() : null;
          }
          return a;
        }(i));
      }
      ff.prototype.feature = function(t) {
        if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[t];
        var e = this._pbf.readVarint() + this._pbf.pos;
        return new Wg(this._pbf, e, this.extent, this._keys, this._values);
      };
      var Hg = pf;
      function Kg(t, e, i) {
        if (t === 3) {
          var n = new Hg(i, i.readVarint() + i.pos);
          n.length && (e[n.name] = n);
        }
      }
      var _d = Wu.VectorTile = function(t, e) {
        this.layers = t.readFields(Kg, {}, e);
      }, Xu = Wu.VectorTileFeature = df;
      function Hu(t, e, i, n) {
        const a = [], c = n === 0 ? (h, p, m, _, v, w) => {
          h.push(new et(w, m + (w - p) / (_ - p) * (v - m)));
        } : (h, p, m, _, v, w) => {
          h.push(new et(p + (w - m) / (v - m) * (_ - p), w));
        };
        for (const h of t) {
          const p = [];
          for (const m of h) {
            if (m.length <= 2) continue;
            const _ = [];
            for (let T = 0; T < m.length - 1; T++) {
              const C = m[T].x, A = m[T].y, z = m[T + 1].x, U = m[T + 1].y, q = n === 0 ? C : A, ie = n === 0 ? z : U;
              q < e ? ie > e && c(_, C, A, z, U, e) : q > i ? ie < i && c(_, C, A, z, U, i) : _.push(m[T]), ie < e && q >= e && c(_, C, A, z, U, e), ie > i && q <= i && c(_, C, A, z, U, i);
            }
            let v = m[m.length - 1];
            const w = n === 0 ? v.x : v.y;
            w >= e && w <= i && _.push(v), _.length && (v = _[_.length - 1], _[0].x === v.x && _[0].y === v.y || _.push(_[0]), p.push(_));
          }
          p.length && a.push(p);
        }
        return a;
      }
      Wu.VectorTileLayer = pf;
      const Jg = Xu.types, Yg = Math.pow(2, 13);
      function Wc(t, e, i, n, a, c, h, p) {
        t.emplaceBack((e << 1) + h, (i << 1) + c, (Math.floor(n * Yg) << 1) + a, Math.round(p));
      }
      function Xc(t, e, i) {
        t.emplaceBack(e.x, e.y, e.z, i[0] * 16384, i[1] * 16384, i[2] * 16384);
      }
      class mf {
        constructor() {
          this.acc = new et(0, 0), this.polyCount = [];
        }
        startRing(e) {
          this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new et(e.x, e.y), this.max = new et(e.x, e.y));
        }
        append(e, i) {
          this.currentPolyCount.edges++, this.acc._add(e);
          const n = this.min, a = this.max;
          e.x < n.x ? n.x = e.x : e.x > a.x && (a.x = e.x), e.y < n.y ? n.y = e.y : e.y > a.y && (a.y = e.y), ((e.x === 0 || e.x === Et) && e.x === i.x) != ((e.y === 0 || e.y === Et) && e.y === i.y) && this.processBorderOverlap(e, i), i.x < 0 != e.x < 0 && this.addBorderIntersection(0, Kt(i.y, e.y, (0 - i.x) / (e.x - i.x))), i.x > Et != e.x > Et && this.addBorderIntersection(1, Kt(i.y, e.y, (Et - i.x) / (e.x - i.x))), i.y < 0 != e.y < 0 && this.addBorderIntersection(2, Kt(i.x, e.x, (0 - i.y) / (e.y - i.y))), i.y > Et != e.y > Et && this.addBorderIntersection(3, Kt(i.x, e.x, (Et - i.y) / (e.y - i.y)));
        }
        addBorderIntersection(e, i) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const n = this.borders[e];
          i < n[0] && (n[0] = i), i > n[1] && (n[1] = i);
        }
        processBorderOverlap(e, i) {
          if (e.x === i.x) {
            if (e.y === i.y) return;
            const n = e.x === 0 ? 0 : 1;
            this.addBorderIntersection(n, i.y), this.addBorderIntersection(n, e.y);
          } else {
            const n = e.y === 0 ? 2 : 3;
            this.addBorderIntersection(n, i.x), this.addBorderIntersection(n, e.x);
          }
        }
        centroid() {
          const e = this.polyCount.reduce((i, n) => i + n.edges, 0);
          return e !== 0 ? this.acc.div(e)._round() : new et(0, 0);
        }
        span() {
          return new et(this.max.x - this.min.x, this.max.y - this.min.y);
        }
        intersectsCount() {
          return this.borders.reduce((e, i) => e + +(i[0] !== Number.MAX_VALUE), 0);
        }
      }
      class Hc {
        constructor(e) {
          this.zoom = e.zoom, this.canonical = e.canonical, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((i) => i.id), this.index = e.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = e.projection, this.layoutVertexArray = new Oe(), this.centroidVertexArray = new Vo(), this.indexArray = new vt(), this.programConfigurations = new Qa(e.layers, e.zoom), this.segments = new ur(), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id), this.enableTerrain = e.enableTerrain;
        }
        populate(e, i, n, a) {
          this.features = [], this.hasPattern = fd("fill-extrusion", this.layers, i), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function(c) {
            const h = Math.exp(Math.PI * (1 - c.y / (1 << c.z) * 2));
            return 80150034 * h / (h * h + 1) / Et / (1 << c.z);
          }(n), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
          for (const { feature: c, id: h, index: p, sourceLayerIndex: m } of e) {
            const _ = this.layers[0]._featureFilter.needGeometry, v = ol(c, _);
            if (!this.layers[0]._featureFilter.filter(new b(this.zoom), v, n)) continue;
            const w = { id: h, sourceLayerIndex: m, index: p, geometry: _ ? v.geometry : $s(c, n, a), properties: c.properties, type: c.type, patterns: {} }, T = this.layoutVertexArray.length;
            this.hasPattern ? this.features.push(md("fill-extrusion", this.layers, w, this.zoom, i)) : this.addFeature(w, w.geometry, p, n, {}, i.availableImages, a), i.featureIndex.insert(c, w.geometry, p, m, this.index, T);
          }
          this.sortBorders();
        }
        addFeatures(e, i, n, a, c) {
          for (const h of this.features) {
            const { geometry: p } = h;
            this.addFeature(h, p, h.index, i, n, a, c);
          }
          this.sortBorders();
        }
        update(e, i, n, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, i, this.stateDependentLayers, n, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Gg), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e.createVertexBuffer(this.layoutVertexExtArray, Vg.members, !0))), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        uploadCentroid(e) {
          this.centroidVertexArray.length !== 0 && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, jg.members, !0), this.needsCentroidUpdate = !1);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(e, i, n, a, c, h, p) {
          const m = [new et(0, 0), new et(Et, Et)], _ = p.projection, v = _.name === "globe", w = this.enableTerrain && !v ? new mf() : null, T = Jg[e.type] === "Polygon";
          v && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new We());
          const C = pd(i, 500);
          for (let q = C.length - 1; q >= 0; q--) {
            const ie = C[q];
            (ie.length === 0 || (A = ie[0]).every((W) => W.x <= 0) || A.every((W) => W.x >= Et) || A.every((W) => W.y <= 0) || A.every((W) => W.y >= Et)) && C.splice(q, 1);
          }
          var A;
          let z;
          if (v) z = wf(C, m, a);
          else {
            z = [];
            for (const q of C) z.push({ polygon: q, bounds: m });
          }
          const U = T ? this.edgeRadius : 0;
          for (const { polygon: q, bounds: ie } of z) {
            let W = 0, te = 0;
            for (const oe of q) T && !oe[0].equals(oe[oe.length - 1]) && oe.push(oe[0]), te += T ? oe.length - 1 : oe.length;
            const ae = this.segments.prepareSegment((T ? 5 : 4) * te, this.layoutVertexArray, this.indexArray);
            if (T) {
              const oe = [], Se = [];
              W = ae.vertexLength;
              for (const ke of q) {
                let $e, Ae;
                ke.length && ke !== q[0] && Se.push(oe.length / 2), $e = ke[1].sub(ke[0])._perp()._unit();
                for (let Fe = 1; Fe < ke.length; Fe++) {
                  const Ue = ke[Fe], je = ke[Fe === ke.length - 1 ? 1 : Fe + 1];
                  let { x: Je, y: Le } = Ue;
                  if (U) {
                    Ae = je.sub(Ue)._perp()._unit();
                    const ot = $e.add(Ae)._unit(), yt = U * Math.min(4, 1 / ($e.x * ot.x + $e.y * ot.y));
                    Je += yt * ot.x, Le += yt * ot.y, $e = Ae;
                  }
                  Wc(this.layoutVertexArray, Je, Le, 0, 0, 1, 1, 0), ae.vertexLength++, oe.push(Ue.x, Ue.y), v && Xc(this.layoutVertexExtArray, _.projectTilePoint(Je, Le, a), _.upVector(a, Je, Le));
                }
              }
              const we = dd(oe, Se);
              for (let ke = 0; ke < we.length; ke += 3) this.indexArray.emplaceBack(W + we[ke], W + we[ke + 2], W + we[ke + 1]), ae.primitiveLength++;
            }
            for (const oe of q) {
              w && oe.length && w.startRing(oe[0]);
              let Se, we, ke, $e = oe.length > 4 && xf(oe[oe.length - 2], oe[0], oe[1]), Ae = U ? Qg(oe[oe.length - 2], oe[0], oe[1], U) : 0;
              we = oe[1].sub(oe[0])._perp()._unit();
              let Fe = !0;
              for (let Ue = 1, je = 0; Ue < oe.length; Ue++) {
                let Je = oe[Ue - 1], Le = oe[Ue];
                const ot = oe[Ue === oe.length - 1 ? 1 : Ue + 1];
                if (w && T && w.currentPolyCount.top++, yf(Le, Je, ie)) {
                  U && (we = ot.sub(Le)._perp()._unit(), Fe = !Fe);
                  continue;
                }
                w && w.append(Le, Je);
                const yt = Le.sub(Je)._perp(), at = yt.x / (Math.abs(yt.x) + Math.abs(yt.y)), Ut = yt.y > 0 ? 1 : 0, Ye = Je.dist(Le);
                if (je + Ye > 32768 && (je = 0), U) {
                  ke = ot.sub(Le)._perp()._unit();
                  let jt = gf(Je, Le, ot, _f(we, ke), U);
                  isNaN(jt) && (jt = 0);
                  const At = Le.sub(Je)._unit();
                  Je = Je.add(At.mult(Ae))._round(), Le = Le.add(At.mult(-jt))._round(), Ae = jt, we = ke;
                }
                const Tt = ae.vertexLength, Nt = oe.length > 4 && xf(Je, Le, ot);
                let hi = vf(je, $e, Fe);
                if (Wc(this.layoutVertexArray, Je.x, Je.y, at, Ut, 0, 0, hi), Wc(this.layoutVertexArray, Je.x, Je.y, at, Ut, 0, 1, hi), je += Ye, hi = vf(je, Nt, !Fe), $e = Nt, Wc(this.layoutVertexArray, Le.x, Le.y, at, Ut, 0, 0, hi), Wc(this.layoutVertexArray, Le.x, Le.y, at, Ut, 0, 1, hi), ae.vertexLength += 4, this.indexArray.emplaceBack(Tt + 0, Tt + 1, Tt + 2), this.indexArray.emplaceBack(Tt + 1, Tt + 3, Tt + 2), ae.primitiveLength += 2, U) {
                  const jt = W + (Ue === 1 ? oe.length - 2 : Ue - 2), At = Ue === 1 ? W : jt + 1;
                  if (this.indexArray.emplaceBack(Tt + 1, jt, Tt + 3), this.indexArray.emplaceBack(jt, At, Tt + 3), ae.primitiveLength += 2, Se === void 0 && (Se = Tt), !yf(ot, oe[Ue], ie)) {
                    const Bi = Ue === oe.length - 1 ? Se : ae.vertexLength;
                    this.indexArray.emplaceBack(Tt + 2, Tt + 3, Bi), this.indexArray.emplaceBack(Tt + 3, Bi + 1, Bi), this.indexArray.emplaceBack(Tt + 3, At, Bi + 1), ae.primitiveLength += 3;
                  }
                  Fe = !Fe;
                }
                if (v) {
                  const jt = this.layoutVertexExtArray, At = _.projectTilePoint(Je.x, Je.y, a), Bi = _.projectTilePoint(Le.x, Le.y, a), $t = _.upVector(a, Je.x, Je.y), Zt = _.upVector(a, Le.x, Le.y);
                  Xc(jt, At, $t), Xc(jt, At, $t), Xc(jt, Bi, Zt), Xc(jt, Bi, Zt);
                }
              }
              T && (W += oe.length - 1);
            }
          }
          if (w && w.polyCount.length > 0) {
            if (w.borders) {
              w.vertexArrayOffset = this.centroidVertexArray.length;
              const q = w.borders, ie = this.featuresOnBorder.push(w) - 1;
              for (let W = 0; W < 4; W++) q[W][0] !== Number.MAX_VALUE && this.borders[W].push(ie);
            }
            this.encodeCentroid(w.borders ? void 0 : w.centroid(), w);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, c, h, a);
        }
        sortBorders() {
          for (let e = 0; e < 4; e++) this.borders[e].sort((i, n) => this.featuresOnBorder[i].borders[e][0] - this.featuresOnBorder[n].borders[e][0]);
        }
        encodeCentroid(e, i, n = !0) {
          let a, c;
          if (e) if (e.y !== 0) {
            const p = i.span()._mult(this.tileToMeter);
            a = (Math.max(e.x, 1) << 3) + Math.min(7, Math.round(p.x / 10)), c = (Math.max(e.y, 1) << 3) + Math.min(7, Math.round(p.y / 10));
          } else a = Math.ceil(7 * (e.x + 450)), c = 0;
          else a = 0, c = +n;
          let h = n ? this.centroidVertexArray.length : i.vertexArrayOffset;
          for (const p of i.polyCount) {
            n && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * p.edges + p.top);
            for (let m = 0; m < p.top; m++) this.centroidVertexArray.emplace(h++, a, c);
            for (let m = 0; m < 2 * p.edges; m++) this.centroidVertexArray.emplace(h++, 0, c), this.centroidVertexArray.emplace(h++, a, c);
          }
        }
      }
      function _f(t, e) {
        const i = t.add(e)._unit();
        return t.x * i.x + t.y * i.y;
      }
      function Qg(t, e, i, n) {
        const a = e.sub(t)._perp()._unit(), c = i.sub(e)._perp()._unit();
        return gf(t, e, i, _f(a, c), n);
      }
      function gf(t, e, i, n, a) {
        const c = Math.sqrt(1 - n * n);
        return Math.min(t.dist(e) / 3, e.dist(i) / 3, a * c / n);
      }
      function yf(t, e, i) {
        return t.x < i[0].x && e.x < i[0].x || t.x > i[1].x && e.x > i[1].x || t.y < i[0].y && e.y < i[0].y || t.y > i[1].y && e.y > i[1].y;
      }
      function xf(t, e, i) {
        if (t.x < 0 || t.x >= Et || e.x < 0 || e.x >= Et || i.x < 0 || i.x >= Et) return !1;
        const n = i.sub(e), a = n.perp(), c = t.sub(e);
        return (n.x * c.x + n.y * c.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (c.x * c.x + c.y * c.y)) > -0.866 && a.x * c.x + a.y * c.y < 0;
      }
      function vf(t, e, i) {
        const n = e ? 2 | t : -3 & t;
        return i ? 1 | n : -2 & n;
      }
      function bf() {
        const t = Math.PI / 32, e = Math.tan(t), i = Vc;
        return i * Math.sqrt(1 + 2 * e * e) - i;
      }
      function wf(t, e, i) {
        const n = 1 << i.z, a = no(i.x / n), c = no((i.x + 1) / n), h = Gr(i.y / n), p = Gr((i.y + 1) / n);
        return function(m, _, v, w, T = 0, C) {
          const A = [];
          if (!m.length || !v || !w) return A;
          const z = (oe, Se) => {
            for (const we of oe) A.push({ polygon: we, bounds: Se });
          }, U = Math.ceil(Math.log2(v)), q = Math.ceil(Math.log2(w)), ie = U - q, W = [];
          for (let oe = 0; oe < Math.abs(ie); oe++) W.push(ie > 0 ? 0 : 1);
          for (let oe = 0; oe < Math.min(U, q); oe++) W.push(0), W.push(1);
          let te = m;
          if (te = Hu(te, _[0].y - T, _[1].y + T, 1), te = Hu(te, _[0].x - T, _[1].x + T, 0), !te.length) return A;
          const ae = [];
          for (W.length ? ae.push({ polygons: te, bounds: _, depth: 0 }) : z(te, _); ae.length; ) {
            const oe = ae.pop(), Se = oe.depth, we = W[Se], ke = oe.bounds[0], $e = oe.bounds[1], Ae = we === 0 ? ke.x : ke.y, Fe = we === 0 ? $e.x : $e.y, Ue = C ? C(we, Ae, Fe) : 0.5 * (Ae + Fe), je = Hu(oe.polygons, Ae - T, Ue + T, we), Je = Hu(oe.polygons, Ue - T, Fe + T, we);
            if (je.length) {
              const Le = [ke, new et(we === 0 ? Ue : $e.x, we === 1 ? Ue : $e.y)];
              W.length > Se + 1 ? ae.push({ polygons: je, bounds: Le, depth: Se + 1 }) : z(je, Le);
            }
            if (Je.length) {
              const Le = [new et(we === 0 ? Ue : ke.x, we === 1 ? Ue : ke.y), $e];
              W.length > Se + 1 ? ae.push({ polygons: Je, bounds: Le, depth: Se + 1 }) : z(Je, Le);
            }
          }
          return A;
        }(t, e, Math.ceil((c - a) / 11.25), Math.ceil((h - p) / 11.25), 1, (m, _, v) => {
          if (m === 0) return 0.5 * (_ + v);
          {
            const w = Gr((i.y + _ / Et) / n);
            return (gs(0.5 * (Gr((i.y + v / Et) / n) + w)) * n - i.y) * Et;
          }
        });
      }
      _t(Hc, "FillExtrusionBucket", { omit: ["layers", "features"] }), _t(mf, "PartMetadata");
      const ey = new K({ "fill-extrusion-edge-radius": new L(Pe["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
      var ty = { paint: new K({ "fill-extrusion-opacity": new L(Pe["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new N(Pe["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new L(Pe["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new L(Pe["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new N(Pe["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new N(Pe["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new N(Pe["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new L(Pe["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new L(Pe["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new L(Pe["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-rounded-roof": new L(Pe["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]) }), layout: ey };
      function Tf(t, e, i) {
        var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i);
        return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];
      }
      class Ku {
        constructor(e, i, n) {
          this.z = e, this.x = i, this.y = n, this.key = Kc(0, e, e, i, n);
        }
        equals(e) {
          return this.z === e.z && this.x === e.x && this.y === e.y;
        }
        url(e, i) {
          const n = function(c, h, p) {
            var m = Tf(256 * c, 256 * (h = Math.pow(2, p) - h - 1), p), _ = Tf(256 * (c + 1), 256 * (h + 1), p);
            return m[0] + "," + m[1] + "," + _[0] + "," + _[1];
          }(this.x, this.y, this.z), a = function(c, h, p) {
            let m, _ = "";
            for (let v = c; v > 0; v--) m = 1 << v - 1, _ += (h & m ? 1 : 0) + (p & m ? 2 : 0);
            return _;
          }(this.z, this.x, this.y);
          return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", a).replace("{bbox-epsg-3857}", n);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Ef {
        constructor(e, i) {
          this.wrap = e, this.canonical = i, this.key = Kc(e, i.z, i.z, i.x, i.y);
        }
      }
      class dn {
        constructor(e, i, n, a, c) {
          this.overscaledZ = e, this.wrap = i, this.canonical = new Ku(n, +a, +c), this.key = i === 0 && e === n ? this.canonical.key : Kc(i, e, n, a, c);
        }
        equals(e) {
          return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
        }
        scaledTo(e) {
          const i = this.canonical.z - e;
          return e > this.canonical.z ? new dn(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new dn(e, this.wrap, e, this.canonical.x >> i, this.canonical.y >> i);
        }
        calculateScaledKey(e, i = !0) {
          if (this.overscaledZ === e && i) return this.key;
          if (e > this.canonical.z) return Kc(this.wrap * +i, e, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const n = this.canonical.z - e;
            return Kc(this.wrap * +i, e, e, this.canonical.x >> n, this.canonical.y >> n);
          }
        }
        isChildOf(e) {
          if (e.wrap !== this.wrap) return !1;
          const i = this.canonical.z - e.canonical.z;
          return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> i && e.canonical.y === this.canonical.y >> i;
        }
        children(e) {
          if (this.overscaledZ >= e) return [new dn(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const i = this.canonical.z + 1, n = 2 * this.canonical.x, a = 2 * this.canonical.y;
          return [new dn(i, this.wrap, i, n, a), new dn(i, this.wrap, i, n + 1, a), new dn(i, this.wrap, i, n, a + 1), new dn(i, this.wrap, i, n + 1, a + 1)];
        }
        isLessThan(e) {
          return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
        }
        wrapped() {
          return new dn(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(e) {
          return new dn(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Ef(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function Kc(t, e, i, n, a) {
        const c = 1 << Math.min(i, 22);
        let h = c * (a % c) + n % c;
        return t && i < 22 && (h += c * c * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - i)))), 16 * (32 * h + i) + (e - i);
      }
      _t(Ku, "CanonicalTileID"), _t(dn, "OverscaledTileID", { omit: ["projMatrix"] });
      class ql extends et {
        constructor(e, i, n) {
          super(e, i), this.z = n;
        }
      }
      function Jc(t, e) {
        return t.x * e.x + t.y * e.y;
      }
      function Sf(t, e) {
        if (t.length === 1) {
          let i = 0;
          const n = e[i++];
          let a;
          for (; !a || n.equals(a); ) if (a = e[i++], !a) return 1 / 0;
          for (; i < e.length; i++) {
            const c = e[i], h = t[0], p = a.sub(n), m = c.sub(n), _ = h.sub(n), v = Jc(p, p), w = Jc(p, m), T = Jc(m, m), C = Jc(_, p), A = Jc(_, m), z = v * T - w * w, U = (T * C - w * A) / z, q = (v * A - w * C) / z, ie = n.z * (1 - U - q) + a.z * U + c.z * q;
            if (isFinite(ie)) return ie;
          }
          return 1 / 0;
        }
        {
          let i = 1 / 0;
          for (const n of e) i = Math.min(i, n.z);
          return i;
        }
      }
      function Mf(t, e, i, n, a, c, h, p) {
        const m = h * a.getElevationAt(t, e, !0, !0), _ = c[0] !== 0, v = _ ? c[1] === 0 ? h * (c[0] / 7 - 450) : h * function(w, T, C) {
          const A = Math.floor(T[0] / 8), z = Math.floor(T[1] / 8), U = 10 * (T[0] - 8 * A), q = 10 * (T[1] - 8 * z), ie = w.getElevationAt(A, z, !0, !0), W = w.getMeterToDEM(C), te = Math.floor(0.5 * (U * W - 1)), ae = Math.floor(0.5 * (q * W - 1)), oe = w.tileCoordToPixel(A, z), Se = 2 * te + 1, we = 2 * ae + 1, ke = function(Je, Le, ot, yt, at) {
            return [Je.getElevationAtPixel(Le, ot, !0), Je.getElevationAtPixel(Le + at, ot, !0), Je.getElevationAtPixel(Le, ot + at, !0), Je.getElevationAtPixel(Le + yt, ot + at, !0)];
          }(w, oe.x - te, oe.y - ae, Se, we), $e = Math.abs(ke[0] - ke[1]), Ae = Math.abs(ke[2] - ke[3]), Fe = Math.abs(ke[0] - ke[2]) + Math.abs(ke[1] - ke[3]), Ue = Math.min(0.25, 0.5 * W * ($e + Ae) / Se), je = Math.min(0.25, 0.5 * W * Fe / we);
          return ie + Math.max(Ue * U, je * q);
        }(a, c, p) : m;
        return { base: m + (i === 0) ? -1 : i, top: _ ? Math.max(v + n, m + i + 2) : m + n };
      }
      const iy = me([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: ry } = iy, ny = me([{ name: "a_packed", components: 4, type: "Float32" }]), { members: oy } = ny, sy = Xu.types, ay = Math.cos(Math.PI / 180 * 37.5);
      class Ju {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((i) => i.id), this.index = e.index, this.projection = e.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((i) => {
            this.gradients[i.id] = {};
          }), this.layoutVertexArray = new Ce(), this.layoutVertexArray2 = new Ve(), this.indexArray = new vt(), this.programConfigurations = new Qa(e.layers, e.zoom), this.segments = new ur(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id);
        }
        populate(e, i, n, a) {
          this.hasPattern = fd("line", this.layers, i);
          const c = this.layers[0].layout.get("line-sort-key"), h = [];
          for (const { feature: v, id: w, index: T, sourceLayerIndex: C } of e) {
            const A = this.layers[0]._featureFilter.needGeometry, z = ol(v, A);
            if (!this.layers[0]._featureFilter.filter(new b(this.zoom), z, n)) continue;
            const U = c ? c.evaluate(z, {}, n) : void 0, q = { id: w, properties: v.properties, type: v.type, sourceLayerIndex: C, index: T, geometry: A ? z.geometry : $s(v, n, a), patterns: {}, sortKey: U };
            h.push(q);
          }
          c && h.sort((v, w) => v.sortKey - w.sortKey);
          const { lineAtlas: p, featureIndex: m } = i, _ = this.addConstantDashes(p);
          for (const v of h) {
            const { geometry: w, index: T, sourceLayerIndex: C } = v;
            if (_ && this.addFeatureDashes(v, p), this.hasPattern) {
              const A = md("line", this.layers, v, this.zoom, i);
              this.patternFeatures.push(A);
            } else this.addFeature(v, w, T, n, p.positions, i.availableImages);
            m.insert(e[T].feature, w, T, C, this.index);
          }
        }
        addConstantDashes(e) {
          let i = !1;
          for (const n of this.layers) {
            const a = n.paint.get("line-dasharray").value, c = n.layout.get("line-cap").value;
            if (a.kind !== "constant" || c.kind !== "constant") i = !0;
            else {
              const h = c.value, p = a.value;
              if (!p) continue;
              e.addDash(p, h);
            }
          }
          return i;
        }
        addFeatureDashes(e, i) {
          const n = this.zoom;
          for (const a of this.layers) {
            const c = a.paint.get("line-dasharray").value, h = a.layout.get("line-cap").value;
            if (c.kind === "constant" && h.kind === "constant") continue;
            let p, m;
            if (c.kind === "constant") {
              if (p = c.value, !p) continue;
            } else p = c.evaluate({ zoom: n }, e);
            m = h.kind === "constant" ? h.value : h.evaluate({ zoom: n }, e), i.addDash(p, m), e.patterns[a.id] = i.getKey(p, m);
          }
        }
        update(e, i, n, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, i, this.stateDependentLayers, n, a);
        }
        addFeatures(e, i, n, a, c) {
          for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, i, n, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, oy)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, ry), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(e) {
          if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
        }
        addFeature(e, i, n, a, c, h) {
          const p = this.layers[0].layout, m = p.get("line-join").evaluate(e, {}), _ = p.get("line-cap").evaluate(e, {}), v = p.get("line-miter-limit"), w = p.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(e);
          for (const T of i) this.addLine(T, e, m, _, v, w);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, c, h, a);
        }
        addLine(e, i, n, a, c, h) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let q = 0; q < e.length - 1; q++) this.totalDistance += e[q].dist(e[q + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const p = sy[i.type] === "Polygon";
          let m = e.length;
          for (; m >= 2 && e[m - 1].equals(e[m - 2]); ) m--;
          let _ = 0;
          for (; _ < m - 1 && e[_].equals(e[_ + 1]); ) _++;
          if (m < (p ? 3 : 2)) return;
          n === "bevel" && (c = 1.05);
          const v = this.overscaling <= 16 ? 15 * Et / (512 * this.overscaling) : 0, w = this.segments.prepareSegment(10 * m, this.layoutVertexArray, this.indexArray);
          let T, C, A, z, U;
          this.e1 = this.e2 = -1, p && (T = e[m - 2], U = e[_].sub(T)._unit()._perp());
          for (let q = _; q < m; q++) {
            if (A = q === m - 1 ? p ? e[_ + 1] : void 0 : e[q + 1], A && e[q].equals(A)) continue;
            U && (z = U), T && (C = T), T = e[q], U = A ? A.sub(T)._unit()._perp() : z, z = z || U;
            let ie = z.add(U);
            ie.x === 0 && ie.y === 0 || ie._unit();
            const W = z.x * U.x + z.y * U.y, te = ie.x * U.x + ie.y * U.y, ae = te !== 0 ? 1 / te : 1 / 0, oe = 2 * Math.sqrt(2 - 2 * te), Se = te < ay && C && A, we = z.x * U.y - z.y * U.x > 0;
            if (Se && q > _) {
              const Ae = T.dist(C);
              if (Ae > 2 * v) {
                const Fe = T.sub(T.sub(C)._mult(v / Ae)._round());
                this.updateDistance(C, Fe), this.addCurrentVertex(Fe, z, 0, 0, w), C = Fe;
              }
            }
            const ke = C && A;
            let $e = ke ? n : p ? "butt" : a;
            if (ke && $e === "round" && (ae < h ? $e = "miter" : ae <= 2 && ($e = "fakeround")), $e === "miter" && ae > c && ($e = "bevel"), $e === "bevel" && (ae > 2 && ($e = "flipbevel"), ae < c && ($e = "miter")), C && this.updateDistance(C, T), $e === "miter") ie._mult(ae), this.addCurrentVertex(T, ie, 0, 0, w);
            else if ($e === "flipbevel") {
              if (ae > 100) ie = U.mult(-1);
              else {
                const Ae = ae * z.add(U).mag() / z.sub(U).mag();
                ie._perp()._mult(Ae * (we ? -1 : 1));
              }
              this.addCurrentVertex(T, ie, 0, 0, w), this.addCurrentVertex(T, ie.mult(-1), 0, 0, w);
            } else if ($e === "bevel" || $e === "fakeround") {
              const Ae = -Math.sqrt(ae * ae - 1), Fe = we ? Ae : 0, Ue = we ? 0 : Ae;
              if (C && this.addCurrentVertex(T, z, Fe, Ue, w), $e === "fakeround") {
                const je = Math.round(180 * oe / Math.PI / 20);
                for (let Je = 1; Je < je; Je++) {
                  let Le = Je / je;
                  if (Le !== 0.5) {
                    const yt = Le - 0.5;
                    Le += Le * yt * (Le - 1) * ((1.0904 + W * (W * (3.55645 - 1.43519 * W) - 3.2452)) * yt * yt + (0.848013 + W * (0.215638 * W - 1.06021)));
                  }
                  const ot = U.sub(z)._mult(Le)._add(z)._unit()._mult(we ? -1 : 1);
                  this.addHalfVertex(T, ot.x, ot.y, !1, we, 0, w);
                }
              }
              A && this.addCurrentVertex(T, U, -Fe, -Ue, w);
            } else if ($e === "butt") this.addCurrentVertex(T, ie, 0, 0, w);
            else if ($e === "square") {
              const Ae = C ? 1 : -1;
              C || this.addCurrentVertex(T, ie, Ae, Ae, w), this.addCurrentVertex(T, ie, 0, 0, w), C && this.addCurrentVertex(T, ie, Ae, Ae, w);
            } else $e === "round" && (C && (this.addCurrentVertex(T, z, 0, 0, w), this.addCurrentVertex(T, z, 1, 1, w, !0)), A && (this.addCurrentVertex(T, U, -1, -1, w, !0), this.addCurrentVertex(T, U, 0, 0, w)));
            if (Se && q < m - 1) {
              const Ae = T.dist(A);
              if (Ae > 2 * v) {
                const Fe = T.add(A.sub(T)._mult(v / Ae)._round());
                this.updateDistance(T, Fe), this.addCurrentVertex(Fe, U, 0, 0, w), T = Fe;
              }
            }
          }
        }
        addCurrentVertex(e, i, n, a, c, h = !1) {
          const p = i.y * a - i.x, m = -i.y - i.x * a;
          this.addHalfVertex(e, i.x + i.y * n, i.y - i.x * n, h, !1, n, c), this.addHalfVertex(e, p, m, h, !0, -a, c);
        }
        addHalfVertex({ x: e, y: i }, n, a, c, h, p, m) {
          this.layoutVertexArray.emplaceBack((e << 1) + (c ? 1 : 0), (i << 1) + (h ? 1 : 0), Math.round(63 * n) + 128, Math.round(63 * a) + 128, 1 + (p === 0 ? 0 : p < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const _ = m.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, _), m.primitiveLength++), h ? this.e2 = _ : this.e1 = _;
        }
        updateScaledDistance() {
          if (this.lineClips) {
            const e = this.totalDistance / (this.lineClips.end - this.lineClips.start);
            this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = e * this.lineClips.start + this.distance;
          } else this.lineSoFar = this.distance;
        }
        updateDistance(e, i) {
          this.distance += e.dist(i), this.updateScaledDistance();
        }
      }
      _t(Ju, "LineBucket", { omit: ["layers", "patternFeatures"] });
      const ly = new K({ "line-cap": new N(Pe.layout_line["line-cap"]), "line-join": new N(Pe.layout_line["line-join"]), "line-miter-limit": new L(Pe.layout_line["line-miter-limit"]), "line-round-limit": new L(Pe.layout_line["line-round-limit"]), "line-sort-key": new N(Pe.layout_line["line-sort-key"]) });
      var Cf = { paint: new K({ "line-opacity": new N(Pe.paint_line["line-opacity"]), "line-color": new N(Pe.paint_line["line-color"]), "line-translate": new L(Pe.paint_line["line-translate"]), "line-translate-anchor": new L(Pe.paint_line["line-translate-anchor"]), "line-width": new N(Pe.paint_line["line-width"]), "line-gap-width": new N(Pe.paint_line["line-gap-width"]), "line-offset": new N(Pe.paint_line["line-offset"]), "line-blur": new N(Pe.paint_line["line-blur"]), "line-dasharray": new N(Pe.paint_line["line-dasharray"]), "line-pattern": new N(Pe.paint_line["line-pattern"]), "line-gradient": new X(Pe.paint_line["line-gradient"]), "line-trim-offset": new L(Pe.paint_line["line-trim-offset"]) }), layout: ly };
      const Af = new class extends N {
        possiblyEvaluate(t, e) {
          return e = new b(Math.floor(e.zoom), { now: e.now, fadeDuration: e.fadeDuration, transition: e.transition }), super.possiblyEvaluate(t, e);
        }
        evaluate(t, e, i, n) {
          return e = si({}, e, { zoom: Math.floor(e.zoom) }), super.evaluate(t, e, i, n);
        }
      }(Cf.paint.properties["line-width"].specification);
      function If(t, e) {
        return e > 0 ? e + 2 * t : t;
      }
      Af.useIntegerZoom = !0;
      const cy = me([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), uy = me([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), hy = me([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      me([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const dy = me([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), py = me([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
      me([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Pf = me([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), fy = me([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      me([{ name: "triangle", components: 3, type: "Uint16" }]), me([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), me([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), me([{ type: "Float32", name: "offsetX" }]), me([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
      var zr = 24;
      const Xo = 128;
      function gd(t, e) {
        const { expression: i } = e;
        if (i.kind === "constant") return { kind: "constant", layoutSize: i.evaluate(new b(t + 1)) };
        if (i.kind === "source") return { kind: "source" };
        {
          const { zoomStops: n, interpolationType: a } = i;
          let c = 0;
          for (; c < n.length && n[c] <= t; ) c++;
          c = Math.max(0, c - 1);
          let h = c;
          for (; h < n.length && n[h] < t + 1; ) h++;
          h = Math.min(n.length - 1, h);
          const p = n[c], m = n[h];
          return i.kind === "composite" ? { kind: "composite", minZoom: p, maxZoom: m, interpolationType: a } : { kind: "camera", minZoom: p, maxZoom: m, minSize: i.evaluate(new b(p)), maxSize: i.evaluate(new b(m)), interpolationType: a };
        }
      }
      function Yu(t, { uSize: e, uSizeT: i }, { lowerSize: n, upperSize: a }) {
        return t.kind === "source" ? n / Xo : t.kind === "composite" ? Kt(n / Xo, a / Xo, i) : e;
      }
      function Wl(t, e) {
        let i = 0, n = 0;
        if (t.kind === "constant") n = t.layoutSize;
        else if (t.kind !== "source") {
          const { interpolationType: a, minZoom: c, maxZoom: h } = t, p = a ? Vt(Kr.interpolationFactor(a, e, c, h), 0, 1) : 0;
          t.kind === "camera" ? n = Kt(t.minSize, t.maxSize, p) : i = p;
        }
        return { uSizeT: i, uSize: n };
      }
      var my = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Xo, evaluateSizeForFeature: Yu, evaluateSizeForZoom: Wl, getSizeData: gd });
      function _y(t, e, i) {
        return t.sections.forEach((n) => {
          n.text = function(a, c, h) {
            const p = c.layout.get("text-transform").evaluate(h, {});
            return p === "uppercase" ? a = a.toLocaleUpperCase() : p === "lowercase" && (a = a.toLocaleLowerCase()), x.applyArabicShaping && (a = x.applyArabicShaping(a)), a;
          }(n.text, e, i);
        }), t;
      }
      const Yc = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂", "←": "↑", "→": "↓" };
      function gy(t) {
        return t === "︶" || t === "﹈" || t === "︸" || t === "﹄" || t === "﹂" || t === "︾" || t === "︼" || t === "︺" || t === "︘" || t === "﹀" || t === "︐" || t === "︓" || t === "︔" || t === "｀" || t === "￣" || t === "︑" || t === "︒";
      }
      function yy(t) {
        return t === "︵" || t === "﹇" || t === "︷" || t === "﹃" || t === "﹁" || t === "︽" || t === "︻" || t === "︹" || t === "︗" || t === "︿";
      }
      var Lf = zi, zf = function(t, e, i, n, a) {
        var c, h, p = 8 * a - n - 1, m = (1 << p) - 1, _ = m >> 1, v = -7, w = a - 1, T = -1, C = t[e + w];
        for (w += T, c = C & (1 << -v) - 1, C >>= -v, v += p; v > 0; c = 256 * c + t[e + w], w += T, v -= 8) ;
        for (h = c & (1 << -v) - 1, c >>= -v, v += n; v > 0; h = 256 * h + t[e + w], w += T, v -= 8) ;
        if (c === 0) c = 1 - _;
        else {
          if (c === m) return h ? NaN : 1 / 0 * (C ? -1 : 1);
          h += Math.pow(2, n), c -= _;
        }
        return (C ? -1 : 1) * h * Math.pow(2, c - n);
      }, kf = function(t, e, i, n, a, c) {
        var h, p, m, _ = 8 * c - a - 1, v = (1 << _) - 1, w = v >> 1, T = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, C = 0, A = 1, z = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (p = isNaN(e) ? 1 : 0, h = v) : (h = Math.floor(Math.log(e) / Math.LN2), e * (m = Math.pow(2, -h)) < 1 && (h--, m *= 2), (e += h + w >= 1 ? T / m : T * Math.pow(2, 1 - w)) * m >= 2 && (h++, m /= 2), h + w >= v ? (p = 0, h = v) : h + w >= 1 ? (p = (e * m - 1) * Math.pow(2, a), h += w) : (p = e * Math.pow(2, w - 1) * Math.pow(2, a), h = 0)); a >= 8; t[i + C] = 255 & p, C += A, p /= 256, a -= 8) ;
        for (h = h << a | p, _ += a; _ > 0; t[i + C] = 255 & h, C += A, h /= 256, _ -= 8) ;
        t[i + C - A] |= 128 * z;
      };
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      function zi(t) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      zi.Varint = 0, zi.Fixed64 = 1, zi.Bytes = 2, zi.Fixed32 = 5;
      var yd = 4294967296, Df = 1 / yd, Rf = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
      function qs(t) {
        return t.type === zi.Bytes ? t.readVarint() + t.pos : t.pos + 1;
      }
      function Xl(t, e, i) {
        return i ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);
      }
      function Of(t, e, i) {
        var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
        i.realloc(n);
        for (var a = i.pos - 1; a >= t; a--) i.buf[a + n] = i.buf[a];
      }
      function xy(t, e) {
        for (var i = 0; i < t.length; i++) e.writeVarint(t[i]);
      }
      function vy(t, e) {
        for (var i = 0; i < t.length; i++) e.writeSVarint(t[i]);
      }
      function by(t, e) {
        for (var i = 0; i < t.length; i++) e.writeFloat(t[i]);
      }
      function wy(t, e) {
        for (var i = 0; i < t.length; i++) e.writeDouble(t[i]);
      }
      function Ty(t, e) {
        for (var i = 0; i < t.length; i++) e.writeBoolean(t[i]);
      }
      function Ey(t, e) {
        for (var i = 0; i < t.length; i++) e.writeFixed32(t[i]);
      }
      function Sy(t, e) {
        for (var i = 0; i < t.length; i++) e.writeSFixed32(t[i]);
      }
      function My(t, e) {
        for (var i = 0; i < t.length; i++) e.writeFixed64(t[i]);
      }
      function Cy(t, e) {
        for (var i = 0; i < t.length; i++) e.writeSFixed64(t[i]);
      }
      function Qu(t, e) {
        return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];
      }
      function Hl(t, e, i) {
        t[i] = e, t[i + 1] = e >>> 8, t[i + 2] = e >>> 16, t[i + 3] = e >>> 24;
      }
      function Bf(t, e) {
        return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);
      }
      zi.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(t, e, i) {
        for (i = i || this.length; this.pos < i; ) {
          var n = this.readVarint(), a = n >> 3, c = this.pos;
          this.type = 7 & n, t(a, e, this), this.pos === c && this.skip(n);
        }
        return e;
      }, readMessage: function(t, e) {
        return this.readFields(t, e, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var t = Qu(this.buf, this.pos);
        return this.pos += 4, t;
      }, readSFixed32: function() {
        var t = Bf(this.buf, this.pos);
        return this.pos += 4, t;
      }, readFixed64: function() {
        var t = Qu(this.buf, this.pos) + Qu(this.buf, this.pos + 4) * yd;
        return this.pos += 8, t;
      }, readSFixed64: function() {
        var t = Qu(this.buf, this.pos) + Bf(this.buf, this.pos + 4) * yd;
        return this.pos += 8, t;
      }, readFloat: function() {
        var t = zf(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, t;
      }, readDouble: function() {
        var t = zf(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, t;
      }, readVarint: function(t) {
        var e, i, n = this.buf;
        return e = 127 & (i = n[this.pos++]), i < 128 ? e : (e |= (127 & (i = n[this.pos++])) << 7, i < 128 ? e : (e |= (127 & (i = n[this.pos++])) << 14, i < 128 ? e : (e |= (127 & (i = n[this.pos++])) << 21, i < 128 ? e : function(a, c, h) {
          var p, m, _ = h.buf;
          if (p = (112 & (m = _[h.pos++])) >> 4, m < 128 || (p |= (127 & (m = _[h.pos++])) << 3, m < 128) || (p |= (127 & (m = _[h.pos++])) << 10, m < 128) || (p |= (127 & (m = _[h.pos++])) << 17, m < 128) || (p |= (127 & (m = _[h.pos++])) << 24, m < 128) || (p |= (1 & (m = _[h.pos++])) << 31, m < 128)) return Xl(a, p, c);
          throw new Error("Expected varint not more than 10 bytes");
        }(e |= (15 & (i = n[this.pos])) << 28, t, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var t = this.readVarint();
        return t % 2 == 1 ? (t + 1) / -2 : t / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var t = this.readVarint() + this.pos, e = this.pos;
        return this.pos = t, t - e >= 12 && Rf ? function(i, n, a) {
          return Rf.decode(i.subarray(n, a));
        }(this.buf, e, t) : function(i, n, a) {
          for (var c = "", h = n; h < a; ) {
            var p, m, _, v = i[h], w = null, T = v > 239 ? 4 : v > 223 ? 3 : v > 191 ? 2 : 1;
            if (h + T > a) break;
            T === 1 ? v < 128 && (w = v) : T === 2 ? (192 & (p = i[h + 1])) == 128 && (w = (31 & v) << 6 | 63 & p) <= 127 && (w = null) : T === 3 ? (m = i[h + 2], (192 & (p = i[h + 1])) == 128 && (192 & m) == 128 && ((w = (15 & v) << 12 | (63 & p) << 6 | 63 & m) <= 2047 || w >= 55296 && w <= 57343) && (w = null)) : T === 4 && (m = i[h + 2], _ = i[h + 3], (192 & (p = i[h + 1])) == 128 && (192 & m) == 128 && (192 & _) == 128 && ((w = (15 & v) << 18 | (63 & p) << 12 | (63 & m) << 6 | 63 & _) <= 65535 || w >= 1114112) && (w = null)), w === null ? (w = 65533, T = 1) : w > 65535 && (w -= 65536, c += String.fromCharCode(w >>> 10 & 1023 | 55296), w = 56320 | 1023 & w), c += String.fromCharCode(w), h += T;
          }
          return c;
        }(this.buf, e, t);
      }, readBytes: function() {
        var t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t);
        return this.pos = t, e;
      }, readPackedVarint: function(t, e) {
        if (this.type !== zi.Bytes) return t.push(this.readVarint(e));
        var i = qs(this);
        for (t = t || []; this.pos < i; ) t.push(this.readVarint(e));
        return t;
      }, readPackedSVarint: function(t) {
        if (this.type !== zi.Bytes) return t.push(this.readSVarint());
        var e = qs(this);
        for (t = t || []; this.pos < e; ) t.push(this.readSVarint());
        return t;
      }, readPackedBoolean: function(t) {
        if (this.type !== zi.Bytes) return t.push(this.readBoolean());
        var e = qs(this);
        for (t = t || []; this.pos < e; ) t.push(this.readBoolean());
        return t;
      }, readPackedFloat: function(t) {
        if (this.type !== zi.Bytes) return t.push(this.readFloat());
        var e = qs(this);
        for (t = t || []; this.pos < e; ) t.push(this.readFloat());
        return t;
      }, readPackedDouble: function(t) {
        if (this.type !== zi.Bytes) return t.push(this.readDouble());
        var e = qs(this);
        for (t = t || []; this.pos < e; ) t.push(this.readDouble());
        return t;
      }, readPackedFixed32: function(t) {
        if (this.type !== zi.Bytes) return t.push(this.readFixed32());
        var e = qs(this);
        for (t = t || []; this.pos < e; ) t.push(this.readFixed32());
        return t;
      }, readPackedSFixed32: function(t) {
        if (this.type !== zi.Bytes) return t.push(this.readSFixed32());
        var e = qs(this);
        for (t = t || []; this.pos < e; ) t.push(this.readSFixed32());
        return t;
      }, readPackedFixed64: function(t) {
        if (this.type !== zi.Bytes) return t.push(this.readFixed64());
        var e = qs(this);
        for (t = t || []; this.pos < e; ) t.push(this.readFixed64());
        return t;
      }, readPackedSFixed64: function(t) {
        if (this.type !== zi.Bytes) return t.push(this.readSFixed64());
        var e = qs(this);
        for (t = t || []; this.pos < e; ) t.push(this.readSFixed64());
        return t;
      }, skip: function(t) {
        var e = 7 & t;
        if (e === zi.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (e === zi.Bytes) this.pos = this.readVarint() + this.pos;
        else if (e === zi.Fixed32) this.pos += 4;
        else {
          if (e !== zi.Fixed64) throw new Error("Unimplemented type: " + e);
          this.pos += 8;
        }
      }, writeTag: function(t, e) {
        this.writeVarint(t << 3 | e);
      }, realloc: function(t) {
        for (var e = this.length || 16; e < this.pos + t; ) e *= 2;
        if (e !== this.length) {
          var i = new Uint8Array(e);
          i.set(this.buf), this.buf = i, this.length = e;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(t) {
        this.realloc(4), Hl(this.buf, t, this.pos), this.pos += 4;
      }, writeSFixed32: function(t) {
        this.realloc(4), Hl(this.buf, t, this.pos), this.pos += 4;
      }, writeFixed64: function(t) {
        this.realloc(8), Hl(this.buf, -1 & t, this.pos), Hl(this.buf, Math.floor(t * Df), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(t) {
        this.realloc(8), Hl(this.buf, -1 & t, this.pos), Hl(this.buf, Math.floor(t * Df), this.pos + 4), this.pos += 8;
      }, writeVarint: function(t) {
        (t = +t || 0) > 268435455 || t < 0 ? function(e, i) {
          var n, a;
          if (e >= 0 ? (n = e % 4294967296 | 0, a = e / 4294967296 | 0) : (a = ~(-e / 4294967296), 4294967295 ^ (n = ~(-e % 4294967296)) ? n = n + 1 | 0 : (n = 0, a = a + 1 | 0)), e >= 18446744073709552e3 || e < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          i.realloc(10), function(c, h, p) {
            p.buf[p.pos++] = 127 & c | 128, c >>>= 7, p.buf[p.pos++] = 127 & c | 128, c >>>= 7, p.buf[p.pos++] = 127 & c | 128, c >>>= 7, p.buf[p.pos++] = 127 & c | 128, p.buf[p.pos] = 127 & (c >>>= 7);
          }(n, 0, i), function(c, h) {
            var p = (7 & c) << 4;
            h.buf[h.pos++] |= p | ((c >>>= 3) ? 128 : 0), c && (h.buf[h.pos++] = 127 & c | ((c >>>= 7) ? 128 : 0), c && (h.buf[h.pos++] = 127 & c | ((c >>>= 7) ? 128 : 0), c && (h.buf[h.pos++] = 127 & c | ((c >>>= 7) ? 128 : 0), c && (h.buf[h.pos++] = 127 & c | ((c >>>= 7) ? 128 : 0), c && (h.buf[h.pos++] = 127 & c)))));
          }(a, i);
        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
      }, writeSVarint: function(t) {
        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
      }, writeBoolean: function(t) {
        this.writeVarint(!!t);
      }, writeString: function(t) {
        t = String(t), this.realloc(4 * t.length), this.pos++;
        var e = this.pos;
        this.pos = function(n, a, c) {
          for (var h, p, m = 0; m < a.length; m++) {
            if ((h = a.charCodeAt(m)) > 55295 && h < 57344) {
              if (!p) {
                h > 56319 || m + 1 === a.length ? (n[c++] = 239, n[c++] = 191, n[c++] = 189) : p = h;
                continue;
              }
              if (h < 56320) {
                n[c++] = 239, n[c++] = 191, n[c++] = 189, p = h;
                continue;
              }
              h = p - 55296 << 10 | h - 56320 | 65536, p = null;
            } else p && (n[c++] = 239, n[c++] = 191, n[c++] = 189, p = null);
            h < 128 ? n[c++] = h : (h < 2048 ? n[c++] = h >> 6 | 192 : (h < 65536 ? n[c++] = h >> 12 | 224 : (n[c++] = h >> 18 | 240, n[c++] = h >> 12 & 63 | 128), n[c++] = h >> 6 & 63 | 128), n[c++] = 63 & h | 128);
          }
          return c;
        }(this.buf, t, this.pos);
        var i = this.pos - e;
        i >= 128 && Of(e, i, this), this.pos = e - 1, this.writeVarint(i), this.pos += i;
      }, writeFloat: function(t) {
        this.realloc(4), kf(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(t) {
        this.realloc(8), kf(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(t) {
        var e = t.length;
        this.writeVarint(e), this.realloc(e);
        for (var i = 0; i < e; i++) this.buf[this.pos++] = t[i];
      }, writeRawMessage: function(t, e) {
        this.pos++;
        var i = this.pos;
        t(e, this);
        var n = this.pos - i;
        n >= 128 && Of(i, n, this), this.pos = i - 1, this.writeVarint(n), this.pos += n;
      }, writeMessage: function(t, e, i) {
        this.writeTag(t, zi.Bytes), this.writeRawMessage(e, i);
      }, writePackedVarint: function(t, e) {
        e.length && this.writeMessage(t, xy, e);
      }, writePackedSVarint: function(t, e) {
        e.length && this.writeMessage(t, vy, e);
      }, writePackedBoolean: function(t, e) {
        e.length && this.writeMessage(t, Ty, e);
      }, writePackedFloat: function(t, e) {
        e.length && this.writeMessage(t, by, e);
      }, writePackedDouble: function(t, e) {
        e.length && this.writeMessage(t, wy, e);
      }, writePackedFixed32: function(t, e) {
        e.length && this.writeMessage(t, Ey, e);
      }, writePackedSFixed32: function(t, e) {
        e.length && this.writeMessage(t, Sy, e);
      }, writePackedFixed64: function(t, e) {
        e.length && this.writeMessage(t, My, e);
      }, writePackedSFixed64: function(t, e) {
        e.length && this.writeMessage(t, Cy, e);
      }, writeBytesField: function(t, e) {
        this.writeTag(t, zi.Bytes), this.writeBytes(e);
      }, writeFixed32Field: function(t, e) {
        this.writeTag(t, zi.Fixed32), this.writeFixed32(e);
      }, writeSFixed32Field: function(t, e) {
        this.writeTag(t, zi.Fixed32), this.writeSFixed32(e);
      }, writeFixed64Field: function(t, e) {
        this.writeTag(t, zi.Fixed64), this.writeFixed64(e);
      }, writeSFixed64Field: function(t, e) {
        this.writeTag(t, zi.Fixed64), this.writeSFixed64(e);
      }, writeVarintField: function(t, e) {
        this.writeTag(t, zi.Varint), this.writeVarint(e);
      }, writeSVarintField: function(t, e) {
        this.writeTag(t, zi.Varint), this.writeSVarint(e);
      }, writeStringField: function(t, e) {
        this.writeTag(t, zi.Bytes), this.writeString(e);
      }, writeFloatField: function(t, e) {
        this.writeTag(t, zi.Fixed32), this.writeFloat(e);
      }, writeDoubleField: function(t, e) {
        this.writeTag(t, zi.Fixed64), this.writeDouble(e);
      }, writeBooleanField: function(t, e) {
        this.writeVarintField(t, !!e);
      } };
      var eh = St(Lf);
      const xd = 3;
      function Ay(t, e, i) {
        e.glyphs = [], t === 1 && i.readMessage(Iy, e);
      }
      function Iy(t, e, i) {
        if (t === 3) {
          const { id: n, bitmap: a, width: c, height: h, left: p, top: m, advance: _ } = i.readMessage(Py, {});
          e.glyphs.push({ id: n, bitmap: new Zs({ width: c + 2 * xd, height: h + 2 * xd }, a), metrics: { width: c, height: h, left: p, top: m, advance: _ } });
        } else t === 4 ? e.ascender = i.readSVarint() : t === 5 && (e.descender = i.readSVarint());
      }
      function Py(t, e, i) {
        t === 1 ? e.id = i.readVarint() : t === 2 ? e.bitmap = i.readBytes() : t === 3 ? e.width = i.readVarint() : t === 4 ? e.height = i.readVarint() : t === 5 ? e.left = i.readSVarint() : t === 6 ? e.top = i.readSVarint() : t === 7 && (e.advance = i.readVarint());
      }
      const Ff = xd;
      function vd(t) {
        let e = 0, i = 0;
        for (const h of t) e += h.w * h.h, i = Math.max(i, h.w);
        t.sort((h, p) => p.h - h.h);
        const n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), i), h: 1 / 0 }];
        let a = 0, c = 0;
        for (const h of t) for (let p = n.length - 1; p >= 0; p--) {
          const m = n[p];
          if (!(h.w > m.w || h.h > m.h)) {
            if (h.x = m.x, h.y = m.y, c = Math.max(c, h.y + h.h), a = Math.max(a, h.x + h.w), h.w === m.w && h.h === m.h) {
              const _ = n.pop();
              p < n.length && (n[p] = _);
            } else h.h === m.h ? (m.x += h.w, m.w -= h.w) : h.w === m.w ? (m.y += h.h, m.h -= h.h) : (n.push({ x: m.x + h.w, y: m.y, w: m.w - h.w, h: h.h }), m.y += h.h, m.h -= h.h);
            break;
          }
        }
        return { w: a, h: c, fill: e / (a * c) || 0 };
      }
      const Tn = 1;
      class bd {
        constructor(e, { pixelRatio: i, version: n, stretchX: a, stretchY: c, content: h }) {
          this.paddedRect = e, this.pixelRatio = i, this.stretchX = a, this.stretchY = c, this.content = h, this.version = n;
        }
        get tl() {
          return [this.paddedRect.x + Tn, this.paddedRect.y + Tn];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - Tn, this.paddedRect.y + this.paddedRect.h - Tn];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * Tn) / this.pixelRatio, (this.paddedRect.h - 2 * Tn) / this.pixelRatio];
        }
      }
      class Uf {
        constructor(e, i) {
          const n = {}, a = {};
          this.haveRenderCallbacks = [];
          const c = [];
          this.addImages(e, n, c), this.addImages(i, a, c);
          const { w: h, h: p } = vd(c), m = new Rn({ width: h || 1, height: p || 1 });
          for (const _ in e) {
            const v = e[_], w = n[_].paddedRect;
            Rn.copy(v.data, m, { x: 0, y: 0 }, { x: w.x + Tn, y: w.y + Tn }, v.data);
          }
          for (const _ in i) {
            const v = i[_], w = a[_].paddedRect, T = w.x + Tn, C = w.y + Tn, A = v.data.width, z = v.data.height;
            Rn.copy(v.data, m, { x: 0, y: 0 }, { x: T, y: C }, v.data), Rn.copy(v.data, m, { x: 0, y: z - 1 }, { x: T, y: C - 1 }, { width: A, height: 1 }), Rn.copy(v.data, m, { x: 0, y: 0 }, { x: T, y: C + z }, { width: A, height: 1 }), Rn.copy(v.data, m, { x: A - 1, y: 0 }, { x: T - 1, y: C }, { width: 1, height: z }), Rn.copy(v.data, m, { x: 0, y: 0 }, { x: T + A, y: C }, { width: 1, height: z });
          }
          this.image = m, this.iconPositions = n, this.patternPositions = a;
        }
        addImages(e, i, n) {
          for (const a in e) {
            const c = e[a], h = { x: 0, y: 0, w: c.data.width + 2 * Tn, h: c.data.height + 2 * Tn };
            n.push(h), i[a] = new bd(h, c), c.hasRenderCallback && this.haveRenderCallbacks.push(a);
          }
        }
        patchUpdatedImages(e, i) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((n) => e.hasImage(n)), e.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const n in e.updatedImages) this.patchUpdatedImage(this.iconPositions[n], e.getImage(n), i), this.patchUpdatedImage(this.patternPositions[n], e.getImage(n), i);
        }
        patchUpdatedImage(e, i, n) {
          if (!e || !i || e.version === i.version) return;
          e.version = i.version;
          const [a, c] = e.tl;
          n.update(i.data, void 0, { x: a, y: c });
        }
      }
      _t(bd, "ImagePosition"), _t(Uf, "ImageAtlas");
      const oo = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, Nf = -17;
      class Qc {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(e, i) {
          const n = new Qc();
          return n.scale = e || 1, n.fontStack = i, n;
        }
        static forImage(e) {
          const i = new Qc();
          return i.imageName = e, i;
        }
      }
      class Kl {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(e, i) {
          const n = new Kl();
          for (let a = 0; a < e.sections.length; a++) {
            const c = e.sections[a];
            c.image ? n.addImageSection(c) : n.addTextSection(c, i);
          }
          return n;
        }
        length() {
          return this.text.length;
        }
        getSection(e) {
          return this.sections[this.sectionIndex[e]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(e) {
          return this.sectionIndex[e];
        }
        getCharCode(e) {
          return this.text.charCodeAt(e);
        }
        verticalizePunctuation(e) {
          this.text = function(i, n) {
            let a = "";
            for (let c = 0; c < i.length; c++) {
              const h = i.charCodeAt(c + 1) || null, p = i.charCodeAt(c - 1) || null;
              a += !n && (h && Iu(h) && !Yc[i[c + 1]] || p && Iu(p) && !Yc[i[c - 1]]) || !Yc[i[c]] ? i[c] : Yc[i[c]];
            }
            return a;
          }(this.text, e);
        }
        trim() {
          let e = 0;
          for (let n = 0; n < this.text.length && th[this.text.charCodeAt(n)]; n++) e++;
          let i = this.text.length;
          for (let n = this.text.length - 1; n >= 0 && n >= e && th[this.text.charCodeAt(n)]; n--) i--;
          this.text = this.text.substring(e, i), this.sectionIndex = this.sectionIndex.slice(e, i);
        }
        substring(e, i) {
          const n = new Kl();
          return n.text = this.text.substring(e, i), n.sectionIndex = this.sectionIndex.slice(e, i), n.sections = this.sections, n;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((e, i) => Math.max(e, this.sections[i].scale), 0);
        }
        addTextSection(e, i) {
          this.text += e.text, this.sections.push(Qc.forText(e.scale, e.fontStack || i));
          const n = this.sections.length - 1;
          for (let a = 0; a < e.text.length; ++a) this.sectionIndex.push(n);
        }
        addImageSection(e) {
          const i = e.image ? e.image.name : "";
          if (i.length === 0) return void Ui("Can't add FormattedSection with an empty image.");
          const n = this.getNextImageSectionCharCode();
          n ? (this.text += String.fromCharCode(n), this.sections.push(Qc.forImage(i)), this.sectionIndex.push(this.sections.length - 1)) : Ui("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function wd(t, e, i, n, a, c, h, p, m, _, v, w, T, C, A) {
        const z = Kl.fromFeature(t, a);
        w === oo.vertical && z.verticalizePunctuation(T);
        let U = [];
        const q = function(oe, Se, we, ke, $e, Ae) {
          if (!oe) return [];
          const Fe = [], Ue = function(ot, yt, at, Ut, Ye, Tt) {
            let Nt = 0;
            for (let hi = 0; hi < ot.length(); hi++) {
              const jt = ot.getSection(hi);
              Nt += jf(ot.getCharCode(hi), jt, Ut, Ye, yt, Tt);
            }
            return Nt / Math.max(1, Math.ceil(Nt / at));
          }(oe, Se, we, ke, $e, Ae), je = oe.text.indexOf("​") >= 0;
          let Je = 0;
          for (let ot = 0; ot < oe.length(); ot++) {
            const yt = oe.getSection(ot), at = oe.getCharCode(ot);
            if (th[at] || (Je += jf(at, yt, ke, $e, Se, Ae)), ot < oe.length() - 1) {
              const Ut = !((Le = at) < 11904 || !(ct["Bopomofo Extended"](Le) || ct.Bopomofo(Le) || ct["CJK Compatibility Forms"](Le) || ct["CJK Compatibility Ideographs"](Le) || ct["CJK Compatibility"](Le) || ct["CJK Radicals Supplement"](Le) || ct["CJK Strokes"](Le) || ct["CJK Symbols and Punctuation"](Le) || ct["CJK Unified Ideographs Extension A"](Le) || ct["CJK Unified Ideographs"](Le) || ct["Enclosed CJK Letters and Months"](Le) || ct["Halfwidth and Fullwidth Forms"](Le) || ct.Hiragana(Le) || ct["Ideographic Description Characters"](Le) || ct["Kangxi Radicals"](Le) || ct["Katakana Phonetic Extensions"](Le) || ct.Katakana(Le) || ct["Vertical Forms"](Le) || ct["Yi Radicals"](Le) || ct["Yi Syllables"](Le)));
              (Ly[at] || Ut || yt.imageName) && Fe.push(Gf(ot + 1, Je, Ue, Fe, zy(at, oe.getCharCode(ot + 1), Ut && je), !1));
            }
          }
          var Le;
          return $f(Gf(oe.length(), Je, Ue, Fe, 0, !0));
        }(z, _, c, e, n, C), { processBidirectionalText: ie, processStyledBidirectionalText: W } = x;
        if (ie && z.sections.length === 1) {
          const oe = ie(z.toString(), q);
          for (const Se of oe) {
            const we = new Kl();
            we.text = Se, we.sections = z.sections;
            for (let ke = 0; ke < Se.length; ke++) we.sectionIndex.push(0);
            U.push(we);
          }
        } else if (W) {
          const oe = W(z.text, z.sectionIndex, q);
          for (const Se of oe) {
            const we = new Kl();
            we.text = Se[0], we.sectionIndex = Se[1], we.sections = z.sections, U.push(we);
          }
        } else U = function(oe, Se) {
          const we = [], ke = oe.text;
          let $e = 0;
          for (const Ae of Se) we.push(oe.substring($e, Ae)), $e = Ae;
          return $e < ke.length && we.push(oe.substring($e, ke.length)), we;
        }(z, q);
        const te = [], ae = { positionedLines: te, text: z.toString(), top: v[1], bottom: v[1], left: v[0], right: v[0], writingMode: w, iconsInText: !1, verticalizable: !1, hasBaseline: !1 };
        return function(oe, Se, we, ke, $e, Ae, Fe, Ue, je, Je, Le, ot) {
          let yt = 0, at = 0, Ut = 0;
          const Ye = Ue === "right" ? 1 : Ue === "left" ? 0 : 0.5;
          let Tt = !1;
          for (const $t of $e) {
            const Zt = $t.getSections();
            for (const Ai of Zt) {
              if (Ai.imageName) continue;
              const ki = Se[Ai.fontStack];
              if (ki && (Tt = ki.ascender !== void 0 && ki.descender !== void 0, !Tt)) break;
            }
            if (!Tt) break;
          }
          let Nt = 0;
          for (const $t of $e) {
            $t.trim();
            const Zt = $t.getMaxScale(), Ai = (Zt - 1) * zr, ki = { positionedGlyphs: [], lineOffset: 0 };
            oe.positionedLines[Nt] = ki;
            const Di = ki.positionedGlyphs;
            let Ii = 0;
            if (!$t.length()) {
              at += Ae, ++Nt;
              continue;
            }
            let Xi = 0, Qi = 0;
            for (let Pi = 0; Pi < $t.length(); Pi++) {
              const vr = $t.getSection(Pi), pr = $t.getSectionIndex(Pi), Ji = $t.getCharCode(Pi);
              let mi = vr.scale, fr = null, Ri = null, pn = null, mr = zr, kr = 0;
              const Sr = !(je === oo.horizontal || !Le && !Mc(Ji) || Le && (th[Ji] || (hi = Ji, ct.Arabic(hi) || ct["Arabic Supplement"](hi) || ct["Arabic Extended-A"](hi) || ct["Arabic Presentation Forms-A"](hi) || ct["Arabic Presentation Forms-B"](hi))));
              if (vr.imageName) {
                const fn = ke[vr.imageName];
                if (!fn) continue;
                pn = vr.imageName, oe.iconsInText = oe.iconsInText || !0, Ri = fn.paddedRect;
                const Mr = fn.displaySize;
                mi = mi * zr / ot, fr = { width: Mr[0], height: Mr[1], left: Tn, top: -Ff, advance: Sr ? Mr[1] : Mr[0], localGlyph: !1 }, kr = Tt ? -fr.height * mi : Nf + Zt * zr - Mr[1] * mi, mr = fr.advance;
                const Jo = (Sr ? Mr[0] : Mr[1]) * mi - zr * Zt;
                Jo > 0 && Jo > Ii && (Ii = Jo);
              } else {
                const fn = we[vr.fontStack];
                if (!fn) continue;
                fn[Ji] && (Ri = fn[Ji]);
                const Mr = Se[vr.fontStack];
                if (!Mr) continue;
                const Jo = Mr.glyphs[Ji];
                if (!Jo) continue;
                if (fr = Jo.metrics, mr = Ji !== 8203 ? zr : 0, Tt) {
                  const rc = Mr.ascender !== void 0 ? Math.abs(Mr.ascender) : 0, cu = Mr.descender !== void 0 ? Math.abs(Mr.descender) : 0, uu = (rc + cu) * mi;
                  Xi < uu && (Xi = uu, Qi = (rc - cu) / 2 * mi), kr = -rc * mi;
                } else kr = Nf + (Zt - mi) * zr;
              }
              Sr ? (oe.verticalizable = !0, Di.push({ glyph: Ji, imageName: pn, x: yt, y: at + kr, vertical: Sr, scale: mi, localGlyph: fr.localGlyph, fontStack: vr.fontStack, sectionIndex: pr, metrics: fr, rect: Ri }), yt += mr * mi + Je) : (Di.push({ glyph: Ji, imageName: pn, x: yt, y: at + kr, vertical: Sr, scale: mi, localGlyph: fr.localGlyph, fontStack: vr.fontStack, sectionIndex: pr, metrics: fr, rect: Ri }), yt += fr.advance * mi + Je);
            }
            Di.length !== 0 && (Ut = Math.max(yt - Je, Ut), Tt ? Zf(Di, Ye, Ii, Qi, Ae * Zt / 2) : Zf(Di, Ye, Ii, 0, Ae / 2)), yt = 0;
            const dr = Ae * Zt + Ii;
            ki.lineOffset = Math.max(Ii, Ai), at += dr, ++Nt;
          }
          var hi;
          const jt = at, { horizontalAlign: At, verticalAlign: Bi } = Td(Fe);
          (function($t, Zt, Ai, ki, Di, Ii) {
            const Xi = (Zt - Ai) * Di, Qi = -Ii * ki;
            for (const dr of $t) for (const Pi of dr.positionedGlyphs) Pi.x += Xi, Pi.y += Qi;
          })(oe.positionedLines, Ye, At, Bi, Ut, jt), oe.top += -Bi * jt, oe.bottom = oe.top + jt, oe.left += -At * Ut, oe.right = oe.left + Ut, oe.hasBaseline = Tt;
        }(ae, e, i, n, U, h, p, m, w, _, T, A), !function(oe) {
          for (const Se of oe) if (Se.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(te) && ae;
      }
      const th = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Ly = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };
      function jf(t, e, i, n, a, c) {
        if (e.imageName) {
          const h = n[e.imageName];
          return h ? h.displaySize[0] * e.scale * zr / c + a : 0;
        }
        {
          const h = i[e.fontStack], p = h && h.glyphs[t];
          return p ? p.metrics.advance * e.scale + a : 0;
        }
      }
      function Vf(t, e, i, n) {
        const a = Math.pow(t - e, 2);
        return n ? t < e ? a / 2 : 2 * a : a + Math.abs(i) * i;
      }
      function zy(t, e, i) {
        let n = 0;
        return t === 10 && (n -= 1e4), i && (n += 150), t !== 40 && t !== 65288 || (n += 50), e !== 41 && e !== 65289 || (n += 50), n;
      }
      function Gf(t, e, i, n, a, c) {
        let h = null, p = Vf(e, i, a, c);
        for (const m of n) {
          const _ = Vf(e - m.x, i, a, c) + m.badness;
          _ <= p && (h = m, p = _);
        }
        return { index: t, x: e, priorBreak: h, badness: p };
      }
      function $f(t) {
        return t ? $f(t.priorBreak).concat(t.index) : [];
      }
      function Td(t) {
        let e = 0.5, i = 0.5;
        switch (t) {
          case "right":
          case "top-right":
          case "bottom-right":
            e = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e = 0;
        }
        switch (t) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            i = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            i = 0;
        }
        return { horizontalAlign: e, verticalAlign: i };
      }
      function Zf(t, e, i, n, a) {
        if (!(e || i || n || a)) return;
        const c = t.length - 1, h = t[c], p = (h.x + h.metrics.advance * h.scale) * e;
        for (let m = 0; m <= c; m++) t[m].x -= p, t[m].y += i + n + a;
      }
      function ky(t, e, i) {
        const { horizontalAlign: n, verticalAlign: a } = Td(i), c = e[0] - t.displaySize[0] * n, h = e[1] - t.displaySize[1] * a;
        return { image: t, top: h, bottom: h + t.displaySize[1], left: c, right: c + t.displaySize[0] };
      }
      function qf(t, e, i, n, a, c) {
        const h = t.image;
        let p;
        if (h.content) {
          const U = h.content, q = h.pixelRatio || 1;
          p = [U[0] / q, U[1] / q, h.displaySize[0] - U[2] / q, h.displaySize[1] - U[3] / q];
        }
        const m = e.left * c, _ = e.right * c;
        let v, w, T, C;
        i === "width" || i === "both" ? (C = a[0] + m - n[3], w = a[0] + _ + n[1]) : (C = a[0] + (m + _ - h.displaySize[0]) / 2, w = C + h.displaySize[0]);
        const A = e.top * c, z = e.bottom * c;
        return i === "height" || i === "both" ? (v = a[1] + A - n[0], T = a[1] + z + n[2]) : (v = a[1] + (A + z - h.displaySize[1]) / 2, T = v + h.displaySize[1]), { image: h, top: v, right: w, bottom: T, left: C, collisionPadding: p };
      }
      class Ws extends et {
        constructor(e, i, n, a, c) {
          super(e, i), this.angle = a, this.z = n, c !== void 0 && (this.segment = c);
        }
        clone() {
          return new Ws(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function Wf(t, e, i, n, a) {
        if (e.segment === void 0) return !0;
        let c = e, h = e.segment + 1, p = 0;
        for (; p > -i / 2; ) {
          if (h--, h < 0) return !1;
          p -= t[h].dist(c), c = t[h];
        }
        p += t[h].dist(t[h + 1]), h++;
        const m = [];
        let _ = 0;
        for (; p < i / 2; ) {
          const v = t[h], w = t[h + 1];
          if (!w) return !1;
          let T = t[h - 1].angleTo(v) - v.angleTo(w);
          for (T = Math.abs((T + 3 * Math.PI) % (2 * Math.PI) - Math.PI), m.push({ distance: p, angleDelta: T }), _ += T; p - m[0].distance > n; ) _ -= m.shift().angleDelta;
          if (_ > a) return !1;
          h++, p += v.dist(w);
        }
        return !0;
      }
      function Xf(t) {
        let e = 0;
        for (let i = 0; i < t.length - 1; i++) e += t[i].dist(t[i + 1]);
        return e;
      }
      function Hf(t, e, i) {
        return t ? 0.6 * e * i : 0;
      }
      function Kf(t, e) {
        return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);
      }
      function Dy(t, e, i, n, a, c) {
        const h = Hf(i, a, c), p = Kf(i, n) * c;
        let m = 0;
        const _ = Xf(t) / 2;
        for (let v = 0; v < t.length - 1; v++) {
          const w = t[v], T = t[v + 1], C = w.dist(T);
          if (m + C > _) {
            const A = (_ - m) / C, z = Kt(w.x, T.x, A), U = Kt(w.y, T.y, A), q = new Ws(z, U, 0, T.angleTo(w), v);
            return !h || Wf(t, q, p, h, e) ? q : void 0;
          }
          m += C;
        }
      }
      function Ry(t, e, i, n, a, c, h, p, m) {
        const _ = Hf(n, c, h), v = Kf(n, a), w = v * h, T = t[0].x === 0 || t[0].x === m || t[0].y === 0 || t[0].y === m;
        return e - w < e / 4 && (e = w + e / 4), Jf(t, T ? e / 2 * p % e : (v / 2 + 2 * c) * h * p % e, e, _, i, w, T, !1, m);
      }
      function Jf(t, e, i, n, a, c, h, p, m) {
        const _ = c / 2, v = Xf(t);
        let w = 0, T = e - i, C = [];
        for (let A = 0; A < t.length - 1; A++) {
          const z = t[A], U = t[A + 1], q = z.dist(U), ie = U.angleTo(z);
          for (; T + i < w + q; ) {
            T += i;
            const W = (T - w) / q, te = Kt(z.x, U.x, W), ae = Kt(z.y, U.y, W);
            if (te >= 0 && te < m && ae >= 0 && ae < m && T - _ >= 0 && T + _ <= v) {
              const oe = new Ws(te, ae, 0, ie, A);
              oe._round(), n && !Wf(t, oe, c, n, a) || C.push(oe);
            }
          }
          w += q;
        }
        return p || C.length || h || (C = Jf(t, w / 2, i, n, a, c, h, !0, m)), C;
      }
      function Yf(t, e, i, n, a) {
        const c = [];
        for (let h = 0; h < t.length; h++) {
          const p = t[h];
          let m;
          for (let _ = 0; _ < p.length - 1; _++) {
            let v = p[_], w = p[_ + 1];
            v.x < e && w.x < e || (v.x < e ? v = new et(e, v.y + (e - v.x) / (w.x - v.x) * (w.y - v.y))._round() : w.x < e && (w = new et(e, v.y + (e - v.x) / (w.x - v.x) * (w.y - v.y))._round()), v.y < i && w.y < i || (v.y < i ? v = new et(v.x + (i - v.y) / (w.y - v.y) * (w.x - v.x), i)._round() : w.y < i && (w = new et(v.x + (i - v.y) / (w.y - v.y) * (w.x - v.x), i)._round()), v.x >= n && w.x >= n || (v.x >= n ? v = new et(n, v.y + (n - v.x) / (w.x - v.x) * (w.y - v.y))._round() : w.x >= n && (w = new et(n, v.y + (n - v.x) / (w.x - v.x) * (w.y - v.y))._round()), v.y >= a && w.y >= a || (v.y >= a ? v = new et(v.x + (a - v.y) / (w.y - v.y) * (w.x - v.x), a)._round() : w.y >= a && (w = new et(v.x + (a - v.y) / (w.y - v.y) * (w.x - v.x), a)._round()), m && v.equals(m[m.length - 1]) || (m = [v], c.push(m)), m.push(w)))));
          }
        }
        return c;
      }
      _t(Ws, "Anchor");
      const eu = 1e20;
      function Qf(t, e, i, n, a, c, h, p, m) {
        for (let _ = e; _ < e + n; _++) em(t, i * c + _, c, a, h, p, m);
        for (let _ = i; _ < i + a; _++) em(t, _ * c + e, 1, n, h, p, m);
      }
      function em(t, e, i, n, a, c, h) {
        c[0] = 0, h[0] = -eu, h[1] = eu, a[0] = t[e];
        for (let p = 1, m = 0, _ = 0; p < n; p++) {
          a[p] = t[e + p * i];
          const v = p * p;
          do {
            const w = c[m];
            _ = (a[p] - a[w] + v - w * w) / (p - w) / 2;
          } while (_ <= h[m] && --m > -1);
          m++, c[m] = p, h[m] = _, h[m + 1] = eu;
        }
        for (let p = 0, m = 0; p < n; p++) {
          for (; h[m + 1] < p; ) m++;
          const _ = c[m], v = p - _;
          t[e + p * i] = a[_] + v * v;
        }
      }
      const Ho = 2, Ed = { none: 0, ideographs: 1, all: 2 };
      class Jl {
        constructor(e, i, n) {
          this.requestManager = e, this.localGlyphMode = i, this.localFontFamily = n, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(e) {
          this.url = e;
        }
        getGlyphs(e, i) {
          const n = [];
          for (const a in e) for (const c of e[a]) n.push({ stack: a, id: c });
          er(n, ({ stack: a, id: c }, h) => {
            let p = this.entries[a];
            p || (p = this.entries[a] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let m = p.glyphs[c];
            if (m !== void 0) return void h(null, { stack: a, id: c, glyph: m });
            if (m = this._tinySDF(p, a, c), m) return p.glyphs[c] = m, void h(null, { stack: a, id: c, glyph: m });
            const _ = Math.floor(c / 256);
            if (256 * _ > 65535) return void h(new Error("glyphs > 65535 not supported"));
            if (p.ranges[_]) return void h(null, { stack: a, id: c, glyph: m });
            let v = p.requests[_];
            v || (v = p.requests[_] = [], Jl.loadGlyphRange(a, _, this.url, this.requestManager, (w, T) => {
              if (T) {
                p.ascender = T.ascender, p.descender = T.descender;
                for (const C in T.glyphs) this._doesCharSupportLocalGlyph(+C) || (p.glyphs[+C] = T.glyphs[+C]);
                p.ranges[_] = !0;
              }
              for (const C of v) C(w, T);
              delete p.requests[_];
            })), v.push((w, T) => {
              w ? h(w) : T && h(null, { stack: a, id: c, glyph: T.glyphs[c] || null });
            });
          }, (a, c) => {
            if (a) i(a);
            else if (c) {
              const h = {};
              for (const { stack: p, id: m, glyph: _ } of c) h[p] === void 0 && (h[p] = {}), h[p].glyphs === void 0 && (h[p].glyphs = {}), h[p].glyphs[m] = _ && { id: _.id, bitmap: _.bitmap.clone(), metrics: _.metrics }, h[p].ascender = this.entries[p].ascender, h[p].descender = this.entries[p].descender;
              i(null, h);
            }
          });
        }
        _doesCharSupportLocalGlyph(e) {
          return this.localGlyphMode !== Ed.none && (this.localGlyphMode === Ed.all ? !!this.localFontFamily : !!this.localFontFamily && (ct["CJK Unified Ideographs"](e) || ct["Hangul Syllables"](e) || ct.Hiragana(e) || ct.Katakana(e) || ct["CJK Symbols and Punctuation"](e)));
        }
        _tinySDF(e, i, n) {
          const a = this.localFontFamily;
          if (!a || !this._doesCharSupportLocalGlyph(n)) return;
          let c = e.tinySDF;
          if (!c) {
            let z = "400";
            /bold/i.test(i) ? z = "900" : /medium/i.test(i) ? z = "500" : /light/i.test(i) && (z = "200"), c = e.tinySDF = new Jl.TinySDF({ fontFamily: a, fontWeight: z, fontSize: 24 * Ho, buffer: 3 * Ho, radius: 8 * Ho }), c.fontWeight = z;
          }
          if (this.localGlyphs[c.fontWeight][n]) return this.localGlyphs[c.fontWeight][n];
          const h = String.fromCharCode(n), { data: p, width: m, height: _, glyphWidth: v, glyphHeight: w, glyphLeft: T, glyphTop: C, glyphAdvance: A } = c.draw(h);
          return this.localGlyphs[c.fontWeight][n] = { id: n, bitmap: new Zs({ width: m, height: _ }, p), metrics: { width: v / Ho, height: w / Ho, left: T / Ho, top: C / Ho - 27, advance: A / Ho, localGlyph: !0 } };
        }
      }
      Jl.loadGlyphRange = function(t, e, i, n, a) {
        const c = 256 * e, h = c + 255, p = n.transformRequest(n.normalizeGlyphsURL(i).replace("{fontstack}", t).replace("{range}", `${c}-${h}`), An.Glyphs);
        es(p, (m, _) => {
          if (m) a(m);
          else if (_) {
            const v = {}, w = function(T) {
              return new eh(T).readFields(Ay, {});
            }(_);
            for (const T of w.glyphs) v[T.id] = T;
            a(null, { glyphs: v, ascender: w.ascender, descender: w.descender });
          }
        });
      }, Jl.TinySDF = class {
        constructor({ fontSize: t = 24, buffer: e = 3, radius: i = 8, cutoff: n = 0.25, fontFamily: a = "sans-serif", fontWeight: c = "normal", fontStyle: h = "normal" } = {}) {
          this.buffer = e, this.cutoff = n, this.radius = i;
          const p = this.size = t + 4 * e, m = this._createCanvas(p), _ = this.ctx = m.getContext("2d", { willReadFrequently: !0 });
          _.font = `${h} ${c} ${t}px ${a}`, _.textBaseline = "alphabetic", _.textAlign = "left", _.fillStyle = "black", this.gridOuter = new Float64Array(p * p), this.gridInner = new Float64Array(p * p), this.f = new Float64Array(p), this.z = new Float64Array(p + 1), this.v = new Uint16Array(p);
        }
        _createCanvas(t) {
          const e = document.createElement("canvas");
          return e.width = e.height = t, e;
        }
        draw(t) {
          const { width: e, actualBoundingBoxAscent: i, actualBoundingBoxDescent: n, actualBoundingBoxLeft: a, actualBoundingBoxRight: c } = this.ctx.measureText(t), h = Math.ceil(i), p = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(c - a))), m = Math.min(this.size - this.buffer, h + Math.ceil(n)), _ = p + 2 * this.buffer, v = m + 2 * this.buffer, w = Math.max(_ * v, 0), T = new Uint8ClampedArray(w), C = { data: T, width: _, height: v, glyphWidth: p, glyphHeight: m, glyphTop: h, glyphLeft: 0, glyphAdvance: e };
          if (p === 0 || m === 0) return C;
          const { ctx: A, buffer: z, gridInner: U, gridOuter: q } = this;
          A.clearRect(z, z, p, m), A.fillText(t, z, z + h);
          const ie = A.getImageData(z, z, p, m);
          q.fill(eu, 0, w), U.fill(0, 0, w);
          for (let W = 0; W < m; W++) for (let te = 0; te < p; te++) {
            const ae = ie.data[4 * (W * p + te) + 3] / 255;
            if (ae === 0) continue;
            const oe = (W + z) * _ + te + z;
            if (ae === 1) q[oe] = 0, U[oe] = eu;
            else {
              const Se = 0.5 - ae;
              q[oe] = Se > 0 ? Se * Se : 0, U[oe] = Se < 0 ? Se * Se : 0;
            }
          }
          Qf(q, 0, 0, _, v, _, this.f, this.v, this.z), Qf(U, z, z, p, m, _, this.f, this.v, this.z);
          for (let W = 0; W < w; W++) {
            const te = Math.sqrt(q[W]) - Math.sqrt(U[W]);
            T[W] = Math.round(255 - 255 * (te / this.radius + this.cutoff));
          }
          return C;
        }
      };
      const Yl = Tn;
      function tm(t, e, i, n) {
        const a = [], c = t.image, h = c.pixelRatio, p = c.paddedRect.w - 2 * Yl, m = c.paddedRect.h - 2 * Yl, _ = t.right - t.left, v = t.bottom - t.top, w = c.stretchX || [[0, p]], T = c.stretchY || [[0, m]], C = (Ae, Fe) => Ae + Fe[1] - Fe[0], A = w.reduce(C, 0), z = T.reduce(C, 0), U = p - A, q = m - z;
        let ie = 0, W = A, te = 0, ae = z, oe = 0, Se = U, we = 0, ke = q;
        if (c.content && n) {
          const Ae = c.content;
          ie = ih(w, 0, Ae[0]), te = ih(T, 0, Ae[1]), W = ih(w, Ae[0], Ae[2]), ae = ih(T, Ae[1], Ae[3]), oe = Ae[0] - ie, we = Ae[1] - te, Se = Ae[2] - Ae[0] - W, ke = Ae[3] - Ae[1] - ae;
        }
        const $e = (Ae, Fe, Ue, je) => {
          const Je = rh(Ae.stretch - ie, W, _, t.left), Le = nh(Ae.fixed - oe, Se, Ae.stretch, A), ot = rh(Fe.stretch - te, ae, v, t.top), yt = nh(Fe.fixed - we, ke, Fe.stretch, z), at = rh(Ue.stretch - ie, W, _, t.left), Ut = nh(Ue.fixed - oe, Se, Ue.stretch, A), Ye = rh(je.stretch - te, ae, v, t.top), Tt = nh(je.fixed - we, ke, je.stretch, z), Nt = new et(Je, ot), hi = new et(at, ot), jt = new et(at, Ye), At = new et(Je, Ye), Bi = new et(Le / h, yt / h), $t = new et(Ut / h, Tt / h), Zt = e * Math.PI / 180;
          if (Zt) {
            const Di = Math.sin(Zt), Ii = Math.cos(Zt), Xi = [Ii, -Di, Di, Ii];
            Nt._matMult(Xi), hi._matMult(Xi), At._matMult(Xi), jt._matMult(Xi);
          }
          const Ai = Ae.stretch + Ae.fixed, ki = Fe.stretch + Fe.fixed;
          return { tl: Nt, tr: hi, bl: At, br: jt, tex: { x: c.paddedRect.x + Yl + Ai, y: c.paddedRect.y + Yl + ki, w: Ue.stretch + Ue.fixed - Ai, h: je.stretch + je.fixed - ki }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Bi, pixelOffsetBR: $t, minFontScaleX: Se / h / _, minFontScaleY: ke / h / v, isSDF: i };
        };
        if (n && (c.stretchX || c.stretchY)) {
          const Ae = im(w, U, A), Fe = im(T, q, z);
          for (let Ue = 0; Ue < Ae.length - 1; Ue++) {
            const je = Ae[Ue], Je = Ae[Ue + 1];
            for (let Le = 0; Le < Fe.length - 1; Le++) a.push($e(je, Fe[Le], Je, Fe[Le + 1]));
          }
        } else a.push($e({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: p + 1 }, { fixed: 0, stretch: m + 1 }));
        return a;
      }
      function ih(t, e, i) {
        let n = 0;
        for (const a of t) n += Math.max(e, Math.min(i, a[1])) - Math.max(e, Math.min(i, a[0]));
        return n;
      }
      function im(t, e, i) {
        const n = [{ fixed: -Yl, stretch: 0 }];
        for (const [a, c] of t) {
          const h = n[n.length - 1];
          n.push({ fixed: a - h.stretch, stretch: h.stretch }), n.push({ fixed: a - h.stretch, stretch: h.stretch + (c - a) });
        }
        return n.push({ fixed: e + Yl, stretch: i }), n;
      }
      function rh(t, e, i, n) {
        return t / e * i + n;
      }
      function nh(t, e, i, n) {
        return t - e * i / n;
      }
      function Oy(t, e, i, n) {
        const a = e + t.positionedLines[n].lineOffset;
        return n === 0 ? i + a / 2 : i + (a + (e + t.positionedLines[n - 1].lineOffset)) / 2;
      }
      class By {
        constructor(e = [], i = Fy) {
          if (this.data = e, this.length = this.data.length, this.compare = i, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
        }
        push(e) {
          this.data.push(e), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (this.length === 0) return;
          const e = this.data[0], i = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = i, this._down(0)), e;
        }
        peek() {
          return this.data[0];
        }
        _up(e) {
          const { data: i, compare: n } = this, a = i[e];
          for (; e > 0; ) {
            const c = e - 1 >> 1, h = i[c];
            if (n(a, h) >= 0) break;
            i[e] = h, e = c;
          }
          i[e] = a;
        }
        _down(e) {
          const { data: i, compare: n } = this, a = this.length >> 1, c = i[e];
          for (; e < a; ) {
            let h = 1 + (e << 1), p = i[h];
            const m = h + 1;
            if (m < this.length && n(i[m], p) < 0 && (h = m, p = i[m]), n(p, c) >= 0) break;
            i[e] = p, e = h;
          }
          i[e] = c;
        }
      }
      function Fy(t, e) {
        return t < e ? -1 : t > e ? 1 : 0;
      }
      function Uy(t, e = 1, i = !1) {
        let n = 1 / 0, a = 1 / 0, c = -1 / 0, h = -1 / 0;
        const p = t[0];
        for (let C = 0; C < p.length; C++) {
          const A = p[C];
          (!C || A.x < n) && (n = A.x), (!C || A.y < a) && (a = A.y), (!C || A.x > c) && (c = A.x), (!C || A.y > h) && (h = A.y);
        }
        const m = Math.min(c - n, h - a);
        let _ = m / 2;
        const v = new By([], Ny);
        if (m === 0) return new et(n, a);
        for (let C = n; C < c; C += m) for (let A = a; A < h; A += m) v.push(new Ql(C + _, A + _, _, t));
        let w = function(C) {
          let A = 0, z = 0, U = 0;
          const q = C[0];
          for (let ie = 0, W = q.length, te = W - 1; ie < W; te = ie++) {
            const ae = q[ie], oe = q[te], Se = ae.x * oe.y - oe.x * ae.y;
            z += (ae.x + oe.x) * Se, U += (ae.y + oe.y) * Se, A += 3 * Se;
          }
          return new Ql(z / A, U / A, 0, C);
        }(t), T = v.length;
        for (; v.length; ) {
          const C = v.pop();
          (C.d > w.d || !w.d) && (w = C, i && console.log("found best %d after %d probes", Math.round(1e4 * C.d) / 1e4, T)), C.max - w.d <= e || (_ = C.h / 2, v.push(new Ql(C.p.x - _, C.p.y - _, _, t)), v.push(new Ql(C.p.x + _, C.p.y - _, _, t)), v.push(new Ql(C.p.x - _, C.p.y + _, _, t)), v.push(new Ql(C.p.x + _, C.p.y + _, _, t)), T += 4);
        }
        return i && (console.log(`num probes: ${T}`), console.log(`best distance: ${w.d}`)), w.p;
      }
      function Ny(t, e) {
        return e.max - t.max;
      }
      class Ql {
        constructor(e, i, n, a) {
          this.p = new et(e, i), this.h = n, this.d = function(c, h) {
            let p = !1, m = 1 / 0;
            for (let _ = 0; _ < h.length; _++) {
              const v = h[_];
              for (let w = 0, T = v.length, C = T - 1; w < T; C = w++) {
                const A = v[w], z = v[C];
                A.y > c.y != z.y > c.y && c.x < (z.x - A.x) * (c.y - A.y) / (z.y - A.y) + A.x && (p = !p), m = Math.min(m, Kp(c, A, z));
              }
            }
            return (p ? 1 : -1) * Math.sqrt(m);
          }(this.p, a), this.max = this.d + this.h * Math.SQRT2;
        }
      }
      const ec = 7, Sd = Number.POSITIVE_INFINITY, jy = Math.sqrt(2);
      function rm(t, [e, i]) {
        let n = 0, a = 0;
        if (i === Sd) {
          e < 0 && (e = 0);
          const c = e / jy;
          switch (t) {
            case "top-right":
            case "top-left":
              a = c - ec;
              break;
            case "bottom-right":
            case "bottom-left":
              a = -c + ec;
              break;
            case "bottom":
              a = -e + ec;
              break;
            case "top":
              a = e - ec;
          }
          switch (t) {
            case "top-right":
            case "bottom-right":
              n = -c;
              break;
            case "top-left":
            case "bottom-left":
              n = c;
              break;
            case "left":
              n = e;
              break;
            case "right":
              n = -e;
          }
        } else {
          switch (e = Math.abs(e), i = Math.abs(i), t) {
            case "top-right":
            case "top-left":
            case "top":
              a = i - ec;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              a = -i + ec;
          }
          switch (t) {
            case "top-right":
            case "bottom-right":
            case "right":
              n = -e;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n = e;
          }
        }
        return [n, a];
      }
      function Vy(t, e, i, n, a, c, h, p, m, _) {
        t.createArrays(), t.tilePixelRatio = Et / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;
        const v = t.layers[0].layout, w = t.layers[0]._unevaluatedLayout._values, T = {};
        if (t.textSizeData.kind === "composite") {
          const { minZoom: z, maxZoom: U } = t.textSizeData;
          T.compositeTextSizes = [w["text-size"].possiblyEvaluate(new b(z), p), w["text-size"].possiblyEvaluate(new b(U), p)];
        }
        if (t.iconSizeData.kind === "composite") {
          const { minZoom: z, maxZoom: U } = t.iconSizeData;
          T.compositeIconSizes = [w["icon-size"].possiblyEvaluate(new b(z), p), w["icon-size"].possiblyEvaluate(new b(U), p)];
        }
        T.layoutTextSize = w["text-size"].possiblyEvaluate(new b(m + 1), p), T.layoutIconSize = w["icon-size"].possiblyEvaluate(new b(m + 1), p), T.textMaxSize = w["text-size"].possiblyEvaluate(new b(18), p);
        const C = v.get("text-rotation-alignment") === "map" && v.get("symbol-placement") !== "point", A = v.get("text-size");
        for (const z of t.features) {
          const U = v.get("text-font").evaluate(z, {}, p).join(","), q = A.evaluate(z, {}, p), ie = T.layoutTextSize.evaluate(z, {}, p), W = (T.layoutIconSize.evaluate(z, {}, p), { horizontal: {}, vertical: void 0 }), te = z.text;
          let ae, oe = [0, 0];
          if (te) {
            const ke = te.toString(), $e = v.get("text-letter-spacing").evaluate(z, {}, p) * zr, Ae = v.get("text-line-height").evaluate(z, {}, p) * zr, Fe = Dh(ke) ? $e : 0, Ue = v.get("text-anchor").evaluate(z, {}, p), je = v.get("text-variable-anchor");
            if (!je) {
              const at = v.get("text-radial-offset").evaluate(z, {}, p);
              oe = at ? rm(Ue, [at * zr, Sd]) : v.get("text-offset").evaluate(z, {}, p).map((Ut) => Ut * zr);
            }
            let Je = C ? "center" : v.get("text-justify").evaluate(z, {}, p);
            const Le = v.get("symbol-placement") === "point", ot = Le ? v.get("text-max-width").evaluate(z, {}, p) * zr : 1 / 0, yt = (at) => {
              t.allowVerticalPlacement && Sc(ke) && (W.vertical = wd(te, e, i, a, U, ot, Ae, Ue, at, Fe, oe, oo.vertical, !0, ie, q));
            };
            if (!C && je) {
              const at = Je === "auto" ? je.map((Ye) => Md(Ye)) : [Je];
              let Ut = !1;
              for (let Ye = 0; Ye < at.length; Ye++) {
                const Tt = at[Ye];
                if (!W.horizontal[Tt]) if (Ut) W.horizontal[Tt] = W.horizontal[0];
                else {
                  const Nt = wd(te, e, i, a, U, ot, Ae, "center", Tt, Fe, oe, oo.horizontal, !1, ie, q);
                  Nt && (W.horizontal[Tt] = Nt, Ut = Nt.positionedLines.length === 1);
                }
              }
              yt("left");
            } else {
              if (Je === "auto" && (Je = Md(Ue)), Le || v.get("text-writing-mode").indexOf("horizontal") >= 0 || !Sc(ke)) {
                const at = wd(te, e, i, a, U, ot, Ae, Ue, Je, Fe, oe, oo.horizontal, !1, ie, q);
                at && (W.horizontal[Je] = at);
              }
              yt(Le ? "left" : Je);
            }
          }
          let Se = !1;
          if (z.icon && z.icon.name) {
            const ke = n[z.icon.name];
            ke && (ae = ky(a[z.icon.name], v.get("icon-offset").evaluate(z, {}, p), v.get("icon-anchor").evaluate(z, {}, p)), Se = ke.sdf, t.sdfIcons === void 0 ? t.sdfIcons = ke.sdf : t.sdfIcons !== ke.sdf && Ui("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ke.pixelRatio !== t.pixelRatio || v.get("icon-rotate").constantOr(1) !== 0) && (t.iconsNeedLinear = !0));
          }
          const we = om(W.horizontal) || W.vertical;
          t.iconsInText || (t.iconsInText = !!we && we.iconsInText), (we || ae) && Gy(t, z, W, ae, n, T, ie, 0, oe, Se, h, p, _);
        }
        c && t.generateCollisionDebugBuffers(m, t.collisionBoxArray);
      }
      function Md(t) {
        switch (t) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Gy(t, e, i, n, a, c, h, p, m, _, v, w, T) {
        let C = c.textMaxSize.evaluate(e, {}, w);
        C === void 0 && (C = h);
        const A = t.layers[0].layout, z = A.get("icon-offset").evaluate(e, {}, w), U = om(i.horizontal) || i.vertical, q = T.name === "globe", ie = zr, W = h / ie, te = t.tilePixelRatio * C / ie, ae = (Ue = t.overscaling, t.zoom > 18 && Ue > 2 && (Ue >>= 1), Math.max(Et / (512 * Ue), 1) * A.get("symbol-spacing")), oe = A.get("text-padding") * t.tilePixelRatio, Se = A.get("icon-padding") * t.tilePixelRatio, we = Pt(A.get("text-max-angle")), ke = A.get("text-rotation-alignment") === "map" && A.get("symbol-placement") !== "point", $e = A.get("icon-rotation-alignment") === "map" && A.get("symbol-placement") !== "point", Ae = A.get("symbol-placement"), Fe = ae / 2;
        var Ue;
        const je = A.get("icon-text-fit");
        let Je;
        n && je !== "none" && (t.allowVerticalPlacement && i.vertical && (Je = qf(n, i.vertical, je, A.get("icon-text-fit-padding"), z, W)), U && (n = qf(n, U, je, A.get("icon-text-fit-padding"), z, W)));
        const Le = (ot, yt, at) => {
          if (yt.x < 0 || yt.x >= Et || yt.y < 0 || yt.y >= Et) return;
          let Ut = null;
          if (q) {
            const { x: Ye, y: Tt, z: Nt } = T.projectTilePoint(yt.x, yt.y, at);
            Ut = { anchor: new Ws(Ye, Tt, Nt, 0, void 0), up: T.upVector(at, yt.x, yt.y) };
          }
          (function(Ye, Tt, Nt, hi, jt, At, Bi, $t, Zt, Ai, ki, Di, Ii, Xi, Qi, dr, Pi, vr, pr, Ji, mi, fr, Ri, pn, mr) {
            const kr = Ye.addToLineVertexArray(Tt, hi);
            let Sr, fn, Mr, Jo, rc, cu, uu, Fm = 0, Um = 0, Nm = 0, jm = 0, jd = -1, Vd = -1;
            const bs = {};
            let Vm = Bh("");
            const ul = Nt ? Nt.anchor : Tt;
            let Gd = 0, $d = 0;
            if (Zt._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [Gd, $d] = Zt.layout.get("text-offset").evaluate(mi, {}, mr).map((On) => On * zr) : (Gd = Zt.layout.get("text-radial-offset").evaluate(mi, {}, mr) * zr, $d = Sd), Ye.allowVerticalPlacement && jt.vertical) {
              const On = jt.vertical;
              if (Qi) cu = Cd(On), $t && (uu = Cd($t));
              else {
                const Bn = Zt.layout.get("text-rotate").evaluate(mi, {}, mr) + 90;
                Mr = oh(Ai, ul, Tt, ki, Di, Ii, On, Xi, Bn, dr), $t && (Jo = oh(Ai, ul, Tt, ki, Di, Ii, $t, vr, Bn));
              }
            }
            if (At) {
              const On = Zt.layout.get("icon-rotate").evaluate(mi, {}, mr), Bn = Zt.layout.get("icon-text-fit") !== "none", hu = tm(At, On, Ri, Bn), qd = $t ? tm($t, On, Ri, Bn) : void 0;
              fn = oh(Ai, ul, Tt, ki, Di, Ii, At, vr, On), Fm = 4 * hu.length;
              const Gm = Ye.iconSizeData;
              let hl = null;
              Gm.kind === "source" ? (hl = [Xo * Zt.layout.get("icon-size").evaluate(mi, {}, mr)], hl[0] > ya && Ui(`${Ye.layerIds[0]}: Value for "icon-size" is >= ${tu}. Reduce your "icon-size".`)) : Gm.kind === "composite" && (hl = [Xo * fr.compositeIconSizes[0].evaluate(mi, {}, mr), Xo * fr.compositeIconSizes[1].evaluate(mi, {}, mr)], (hl[0] > ya || hl[1] > ya) && Ui(`${Ye.layerIds[0]}: Value for "icon-size" is >= ${tu}. Reduce your "icon-size".`)), Ye.addSymbols(Ye.icon, hu, hl, Ji, pr, mi, !1, Nt, Tt, kr.lineStartIndex, kr.lineLength, -1, pn, mr), jd = Ye.icon.placedSymbolArray.length - 1, qd && (Um = 4 * qd.length, Ye.addSymbols(Ye.icon, qd, hl, Ji, pr, mi, oo.vertical, Nt, Tt, kr.lineStartIndex, kr.lineLength, -1, pn, mr), Vd = Ye.icon.placedSymbolArray.length - 1);
            }
            for (const On in jt.horizontal) {
              const Bn = jt.horizontal[On];
              Sr || (Vm = Bh(Bn.text), Qi ? rc = Cd(Bn) : Sr = oh(Ai, ul, Tt, ki, Di, Ii, Bn, Xi, Zt.layout.get("text-rotate").evaluate(mi, {}, mr), dr));
              const hu = Bn.positionedLines.length === 1;
              if (Nm += nm(Ye, Nt, Tt, Bn, Bi, Zt, Qi, mi, dr, kr, jt.vertical ? oo.horizontal : oo.horizontalOnly, hu ? Object.keys(jt.horizontal) : [On], bs, jd, fr, pn, mr), hu) break;
            }
            jt.vertical && (jm += nm(Ye, Nt, Tt, jt.vertical, Bi, Zt, Qi, mi, dr, kr, oo.vertical, ["vertical"], bs, Vd, fr, pn, mr));
            let Ea = -1;
            const Zd = (On, Bn) => On ? Math.max(On, Bn) : Bn;
            Ea = Zd(rc, Ea), Ea = Zd(cu, Ea), Ea = Zd(uu, Ea);
            const gx = Ea > -1 ? 1 : 0;
            Ye.glyphOffsetArray.length >= va.MAX_GLYPHS && Ui("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), mi.sortKey !== void 0 && Ye.addToSortKeyRanges(Ye.symbolInstances.length, mi.sortKey), Ye.symbolInstances.emplaceBack(ul.x, ul.y, ul.z, Tt.x, Tt.y, bs.right >= 0 ? bs.right : -1, bs.center >= 0 ? bs.center : -1, bs.left >= 0 ? bs.left : -1, bs.vertical >= 0 ? bs.vertical : -1, jd, Vd, Vm, Sr !== void 0 ? Sr : Ye.collisionBoxArray.length, Sr !== void 0 ? Sr + 1 : Ye.collisionBoxArray.length, Mr !== void 0 ? Mr : Ye.collisionBoxArray.length, Mr !== void 0 ? Mr + 1 : Ye.collisionBoxArray.length, fn !== void 0 ? fn : Ye.collisionBoxArray.length, fn !== void 0 ? fn + 1 : Ye.collisionBoxArray.length, Jo || Ye.collisionBoxArray.length, Jo ? Jo + 1 : Ye.collisionBoxArray.length, ki, Nm, jm, Fm, Um, gx, 0, Gd, $d, Ea);
          })(t, yt, Ut, ot, i, n, a, Je, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, oe, ke, m, 0, Se, $e, z, e, c, _, v, w);
        };
        if (Ae === "line") for (const ot of Yf(e.geometry, 0, 0, Et, Et)) {
          const yt = Ry(ot, ae, we, i.vertical || U, n, ie, te, t.overscaling, Et);
          for (const at of yt) U && $y(t, U.text, Fe, at) || Le(ot, at, w);
        }
        else if (Ae === "line-center") {
          for (const ot of e.geometry) if (ot.length > 1) {
            const yt = Dy(ot, we, i.vertical || U, n, ie, te);
            yt && Le(ot, yt, w);
          }
        } else if (e.type === "Polygon") for (const ot of pd(e.geometry, 0)) {
          const yt = Uy(ot, 16);
          Le(ot[0], new Ws(yt.x, yt.y, 0, 0, void 0), w);
        }
        else if (e.type === "LineString") for (const ot of e.geometry) Le(ot, new Ws(ot[0].x, ot[0].y, 0, 0, void 0), w);
        else if (e.type === "Point") for (const ot of e.geometry) for (const yt of ot) Le([yt], new Ws(yt.x, yt.y, 0, 0, void 0), w);
      }
      const tu = 255, ya = tu * Xo;
      function nm(t, e, i, n, a, c, h, p, m, _, v, w, T, C, A, z, U) {
        const q = function(te, ae, oe, Se, we, ke, $e, Ae) {
          const Fe = [];
          if (ae.positionedLines.length === 0) return Fe;
          const Ue = Se.layout.get("text-rotate").evaluate(ke, {}) * Math.PI / 180, je = function(at) {
            const Ut = at[0], Ye = at[1], Tt = Ut * Ye;
            return Tt > 0 ? [Ut, -Ye] : Tt < 0 ? [-Ut, Ye] : Ut === 0 ? [Ye, Ut] : [Ye, -Ut];
          }(oe);
          let Je = Math.abs(ae.top - ae.bottom);
          for (const at of ae.positionedLines) Je -= at.lineOffset;
          const Le = ae.positionedLines.length, ot = Je / Le;
          let yt = ae.top - oe[1];
          for (let at = 0; at < Le; ++at) {
            const Ut = ae.positionedLines[at];
            yt = Oy(ae, ot, yt, at);
            for (const Ye of Ut.positionedGlyphs) {
              if (!Ye.rect) continue;
              const Tt = Ye.rect || {};
              let Nt = Ff + 1, hi = !0, jt = 1, At = 0;
              if (Ye.imageName) {
                const Ri = $e[Ye.imageName];
                if (!Ri) continue;
                if (Ri.sdf) {
                  Ui("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                hi = !1, jt = Ri.pixelRatio, Nt = Tn / jt;
              }
              const Bi = (we || Ae) && Ye.vertical, $t = Ye.metrics.advance * Ye.scale / 2, Zt = Ye.metrics, Ai = Ye.rect;
              if (Ai === null) continue;
              Ae && ae.verticalizable && (At = Ye.imageName ? $t - Ye.metrics.width * Ye.scale / 2 : 0);
              const ki = we ? [Ye.x + $t, Ye.y] : [0, 0];
              let Di = [0, 0], Ii = [0, 0], Xi = !1;
              we || (Bi ? (Ii = [Ye.x + $t + je[0], Ye.y + je[1] - At], Xi = !0) : Di = [Ye.x + $t + oe[0], Ye.y + oe[1] - At]);
              const Qi = Ai.w * Ye.scale / (jt * (Ye.localGlyph ? Ho : 1)), dr = Ai.h * Ye.scale / (jt * (Ye.localGlyph ? Ho : 1));
              let Pi, vr, pr, Ji;
              if (Bi) {
                const Ri = Ye.y - yt, pn = new et(-$t, $t - Ri), mr = -Math.PI / 2, kr = new et(...Ii);
                Pi = new et(-$t + Di[0], Di[1]), Pi._rotateAround(mr, pn)._add(kr), Pi.x += -Ri + $t, Pi.y -= (Zt.left - Nt) * Ye.scale;
                const Sr = Ye.imageName ? Zt.advance * Ye.scale : zr * Ye.scale, fn = String.fromCharCode(Ye.glyph);
                gy(fn) ? Pi.x += (1 - Nt) * Ye.scale : yy(fn) ? Pi.x += Sr - Zt.height * Ye.scale + (-Nt - 1) * Ye.scale : Pi.x += Ye.imageName || Zt.width + 2 * Nt === Ai.w && Zt.height + 2 * Nt === Ai.h ? (Sr - dr) / 2 : (Sr - (Zt.height + 2 * Nt) * Ye.scale) / 2, vr = new et(Pi.x, Pi.y - Qi), pr = new et(Pi.x + dr, Pi.y), Ji = new et(Pi.x + dr, Pi.y - Qi);
              } else {
                const Ri = (Zt.left - Nt) * Ye.scale - $t + Di[0], pn = (-Zt.top - Nt) * Ye.scale + Di[1], mr = Ri + Qi, kr = pn + dr;
                Pi = new et(Ri, pn), vr = new et(mr, pn), pr = new et(Ri, kr), Ji = new et(mr, kr);
              }
              if (Ue) {
                let Ri;
                Ri = we ? new et(0, 0) : Xi ? new et(je[0], je[1]) : new et(oe[0], oe[1]), Pi._rotateAround(Ue, Ri), vr._rotateAround(Ue, Ri), pr._rotateAround(Ue, Ri), Ji._rotateAround(Ue, Ri);
              }
              const mi = new et(0, 0), fr = new et(0, 0);
              Fe.push({ tl: Pi, tr: vr, bl: pr, br: Ji, tex: Tt, writingMode: ae.writingMode, glyphOffset: ki, sectionIndex: Ye.sectionIndex, isSDF: hi, pixelOffsetTL: mi, pixelOffsetBR: fr, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return Fe;
        }(0, n, m, c, h, p, a, t.allowVerticalPlacement), ie = t.textSizeData;
        let W = null;
        ie.kind === "source" ? (W = [Xo * c.layout.get("text-size").evaluate(p, {}, U)], W[0] > ya && Ui(`${t.layerIds[0]}: Value for "text-size" is >= ${tu}. Reduce your "text-size".`)) : ie.kind === "composite" && (W = [Xo * A.compositeTextSizes[0].evaluate(p, {}, U), Xo * A.compositeTextSizes[1].evaluate(p, {}, U)], (W[0] > ya || W[1] > ya) && Ui(`${t.layerIds[0]}: Value for "text-size" is >= ${tu}. Reduce your "text-size".`)), t.addSymbols(t.text, q, W, m, h, p, v, e, i, _.lineStartIndex, _.lineLength, C, z, U);
        for (const te of w) T[te] = t.text.placedSymbolArray.length - 1;
        return 4 * q.length;
      }
      function om(t) {
        for (const e in t) return t[e];
        return null;
      }
      function oh(t, e, i, n, a, c, h, p, m, _) {
        let v = h.top, w = h.bottom, T = h.left, C = h.right;
        const A = h.collisionPadding;
        if (A && (T -= A[0], v -= A[1], C += A[2], w += A[3]), m) {
          const z = new et(T, v), U = new et(C, v), q = new et(T, w), ie = new et(C, w), W = Pt(m);
          let te = new et(0, 0);
          _ && (te = new et(_[0], _[1])), z._rotateAround(W, te), U._rotateAround(W, te), q._rotateAround(W, te), ie._rotateAround(W, te), T = Math.min(z.x, U.x, q.x, ie.x), C = Math.max(z.x, U.x, q.x, ie.x), v = Math.min(z.y, U.y, q.y, ie.y), w = Math.max(z.y, U.y, q.y, ie.y);
        }
        return t.emplaceBack(e.x, e.y, e.z, i.x, i.y, T, v, C, w, p, n, a, c), t.length - 1;
      }
      function Cd(t) {
        t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);
        const e = t.bottom - t.top;
        return e > 0 ? Math.max(10, e) : null;
      }
      function $y(t, e, i, n) {
        const a = t.compareText;
        if (e in a) {
          const c = a[e];
          for (let h = c.length - 1; h >= 0; h--) if (n.dist(c[h]) < i) return !0;
        } else a[e] = [];
        return a[e].push(n), !1;
      }
      function sm(t, e) {
        const i = t.fovAboveCenter, n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0, a = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch), c = Math.sin(i) * a / Math.sin(Math.max(Math.PI / 2 - t._pitch - i, 0.01)), h = Math.sin(t._pitch) * c + a;
        return Math.min(1.01 * h, a * (1 / t._horizonShift));
      }
      function ll(t, e) {
        if (!e.isReprojectedInTileSpace) return { scale: 1 << t.z, x: t.x, y: t.y, x2: t.x + 1, y2: t.y + 1, projection: e };
        const i = Math.pow(2, -t.z), n = t.x * i, a = (t.x + 1) * i, c = t.y * i, h = (t.y + 1) * i, p = no(n), m = no(a), _ = Gr(c), v = Gr(h), w = e.project(p, _), T = e.project(m, _), C = e.project(m, v), A = e.project(p, v);
        let z = Math.min(w.x, T.x, C.x, A.x), U = Math.min(w.y, T.y, C.y, A.y), q = Math.max(w.x, T.x, C.x, A.x), ie = Math.max(w.y, T.y, C.y, A.y);
        const W = i / 16;
        function te(oe, Se, we, ke, $e, Ae) {
          const Fe = (we + $e) / 2, Ue = (ke + Ae) / 2, je = e.project(no(Fe), Gr(Ue)), Je = Math.max(0, z - je.x, U - je.y, je.x - q, je.y - ie);
          z = Math.min(z, je.x), q = Math.max(q, je.x), U = Math.min(U, je.y), ie = Math.max(ie, je.y), Je > W && (te(oe, je, we, ke, Fe, Ue), te(je, Se, Fe, Ue, $e, Ae));
        }
        te(w, T, n, c, a, c), te(T, C, a, c, a, h), te(C, A, a, h, n, h), te(A, w, n, h, n, c), z -= W, U -= W, q += W, ie += W;
        const ae = 1 / Math.max(q - z, ie - U);
        return { scale: ae, x: z * ae, y: U * ae, x2: q * ae, y2: ie * ae, projection: e };
      }
      const Zy = Zo(new Float32Array(16));
      class xa {
        constructor(e) {
          this.spec = e, this.name = e.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(e, i) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(e, i) {
          return new Ci(0, 0);
        }
        projectTilePoint(e, i, n) {
          return { x: e, y: i, z: 0 };
        }
        locationPoint(e, i, n = !0) {
          return e._coordinatePoint(e.locationCoordinate(i), n);
        }
        pixelsPerMeter(e, i) {
          return Wo(1, e) * i;
        }
        pixelSpaceConversion(e, i, n) {
          return 1;
        }
        farthestPixelDistance(e) {
          return sm(e, e.pixelsPerMeter);
        }
        pointCoordinate(e, i, n, a) {
          const c = e.horizonLineFromTop(!1), h = new et(i, Math.max(c, n));
          return e.rayIntersectionCoordinate(e.pointRayIntersection(h, a));
        }
        pointCoordinate3D(e, i, n) {
          const a = new et(i, n);
          if (e.elevation) return e.elevation.pointCoordinate(a);
          {
            const c = this.pointCoordinate(e, a.x, a.y, 0);
            return [c.x, c.y, c.z];
          }
        }
        isPointAboveHorizon(e, i) {
          if (e.elevation) return !this.pointCoordinate3D(e, i.x, i.y);
          const n = e.horizonLineFromTop();
          return i.y < n;
        }
        createInversionMatrix(e, i) {
          return Zy;
        }
        createTileMatrix(e, i, n) {
          let a, c, h;
          const p = n.canonical, m = Zo(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const _ = ll(p, this);
            a = 1, c = _.x + n.wrap * _.scale, h = _.y, tl(m, m, [a / _.scale, a / _.scale, e.pixelsPerMeter / i]);
          } else a = i / e.zoomScale(p.z), c = (p.x + Math.pow(2, p.z) * n.wrap) * a, h = p.y * a;
          return zc(m, m, [c, h, 0]), tl(m, m, [a / Et, a / Et, 1]), m;
        }
        upVector(e, i, n) {
          return [0, 0, 1];
        }
        upVectorScale(e, i, n) {
          return { metersToTile: 1 };
        }
      }
      class qy extends xa {
        constructor(e) {
          super(e), this.range = [4, 7], this.center = e.center || [-96, 37.5];
          const [i, n] = this.parallels = e.parallels || [29.5, 45.5], a = Math.sin(Pt(i));
          this.n = (a + Math.sin(Pt(n))) / 2, this.c = 1 + a * (2 * this.n - a), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(e, i) {
          const { n, c: a, r0: c } = this, h = Pt(e - this.center[0]), p = Pt(i), m = Math.sqrt(a - 2 * n * Math.sin(p)) / n;
          return { x: m * Math.sin(h * n), y: m * Math.cos(h * n) - c, z: 0 };
        }
        unproject(e, i) {
          const { n, c: a, r0: c } = this, h = c + i;
          let p = Math.atan2(e, Math.abs(h)) * Math.sign(h);
          h * n < 0 && (p -= Math.PI * Math.sign(e) * Math.sign(h));
          const m = Pt(this.center[0]) * n;
          p = Zi(p, -Math.PI - m, Math.PI - m);
          const _ = Vt(Fi(p / n) + this.center[0], -180, 180), v = Math.asin(Vt((a - (e * e + h * h) * n * n) / (2 * n), -1, 1)), w = Vt(Fi(v), -$r, $r);
          return new Ci(_, w);
        }
      }
      const iu = 1.340264, ru = -0.081106, nu = 893e-6, ou = 3796e-6, sh = Math.sqrt(3) / 2;
      class Wy extends xa {
        project(e, i) {
          i = i / 180 * Math.PI, e = e / 180 * Math.PI;
          const n = Math.asin(sh * Math.sin(i)), a = n * n, c = a * a * a;
          return { x: 0.5 * (e * Math.cos(n) / (sh * (iu + 3 * ru * a + c * (7 * nu + 9 * ou * a))) / Math.PI + 0.5), y: 1 - 0.5 * (n * (iu + ru * a + c * (nu + ou * a)) / Math.PI + 1), z: 0 };
        }
        unproject(e, i) {
          e = (2 * e - 0.5) * Math.PI;
          let n = i = (2 * (1 - i) - 1) * Math.PI, a = n * n, c = a * a * a;
          for (let v, w, T, C = 0; C < 12 && (w = n * (iu + ru * a + c * (nu + ou * a)) - i, T = iu + 3 * ru * a + c * (7 * nu + 9 * ou * a), v = w / T, n = Vt(n - v, -Math.PI / 3, Math.PI / 3), a = n * n, c = a * a * a, !(Math.abs(v) < 1e-12)); ++C) ;
          const h = sh * e * (iu + 3 * ru * a + c * (7 * nu + 9 * ou * a)) / Math.cos(n), p = Math.asin(Math.sin(n) / sh), m = Vt(180 * h / Math.PI, -180, 180), _ = Vt(180 * p / Math.PI, -$r, $r);
          return new Ci(m, _);
        }
      }
      class Xy extends xa {
        constructor(e) {
          super(e), this.wrap = !0, this.supportsWorldCopies = !0;
        }
        project(e, i) {
          return { x: 0.5 + e / 360, y: 0.5 - i / 360, z: 0 };
        }
        unproject(e, i) {
          const n = 360 * (e - 0.5), a = Vt(360 * (0.5 - i), -$r, $r);
          return new Ci(n, a);
        }
      }
      const tc = Math.PI / 2;
      function ah(t) {
        return Math.tan((tc + t) / 2);
      }
      class Hy extends xa {
        constructor(e) {
          super(e), this.center = e.center || [0, 30];
          const [i, n] = this.parallels = e.parallels || [30, 30];
          let a = Pt(i), c = Pt(n);
          this.southernCenter = a + c < 0, this.southernCenter && (a = -a, c = -c);
          const h = Math.cos(a), p = ah(a);
          this.n = a === c ? Math.sin(a) : Math.log(h / Math.cos(c)) / Math.log(ah(c) / p), this.f = h * Math.pow(ah(a), this.n) / this.n;
        }
        project(e, i) {
          i = Pt(i), this.southernCenter && (i = -i), e = Pt(e - this.center[0]);
          const n = 1e-6, { n: a, f: c } = this;
          c > 0 ? i < -tc + n && (i = -tc + n) : i > tc - n && (i = tc - n);
          const h = c / Math.pow(ah(i), a);
          let p = h * Math.sin(a * e), m = c - h * Math.cos(a * e);
          return p = 0.5 * (p / Math.PI + 0.5), m = 0.5 * (m / Math.PI + 0.5), { x: p, y: this.southernCenter ? m : 1 - m, z: 0 };
        }
        unproject(e, i) {
          e = (2 * e - 0.5) * Math.PI, this.southernCenter && (i = 1 - i), i = (2 * (1 - i) - 0.5) * Math.PI;
          const { n, f: a } = this, c = a - i, h = Math.sign(c), p = Math.sign(n) * Math.sqrt(e * e + c * c);
          let m = Math.atan2(e, Math.abs(c)) * h;
          c * n < 0 && (m -= Math.PI * Math.sign(e) * h);
          const _ = Vt(Fi(m / n) + this.center[0], -180, 180), v = Vt(Fi(2 * Math.atan(Math.pow(a / p, 1 / n)) - tc), -$r, $r);
          return new Ci(_, this.southernCenter ? -v : v);
        }
      }
      class am extends xa {
        constructor(e) {
          super(e), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
        }
        project(e, i) {
          return { x: _s(e), y: gs(i), z: 0 };
        }
        unproject(e, i) {
          const n = no(e), a = Gr(i);
          return new Ci(n, a);
        }
      }
      const lm = Pt($r);
      class Ky extends xa {
        project(e, i) {
          const n = (i = Pt(i)) * i, a = n * n;
          return { x: 0.5 * ((e = Pt(e)) * (0.8707 - 0.131979 * n + a * (a * (3971e-6 * n - 1529e-6 * a) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (i * (1.007226 + n * (0.015085 + a * (0.028874 * n - 0.044475 - 5916e-6 * a))) / Math.PI + 1), z: 0 };
        }
        unproject(e, i) {
          e = (2 * e - 0.5) * Math.PI;
          let n = i = (2 * (1 - i) - 1) * Math.PI, a = 25, c = 0, h = n * n;
          do {
            h = n * n;
            const _ = h * h;
            c = (n * (1.007226 + h * (0.015085 + _ * (0.028874 * h - 0.044475 - 5916e-6 * _))) - i) / (1.007226 + h * (0.045255 + _ * (0.259866 * h - 0.311325 - 5916e-6 * 11 * _))), n = Vt(n - c, -lm, lm);
          } while (Math.abs(c) > 1e-6 && --a > 0);
          h = n * n;
          const p = Vt(Fi(e / (0.8707 + h * (h * (h * h * h * (3971e-6 - 1529e-6 * h) - 0.013791) - 0.131979))), -180, 180), m = Fi(n);
          return new Ci(p, m);
        }
      }
      const cm = Pt($r);
      class Jy extends xa {
        project(e, i) {
          i = Pt(i), e = Pt(e);
          const n = Math.cos(i), a = 2 / Math.PI, c = Math.acos(n * Math.cos(e / 2)), h = Math.sin(c) / c, p = 0.5 * (e * a + 2 * n * Math.sin(e / 2) / h) || 0, m = 0.5 * (i + Math.sin(i) / h) || 0;
          return { x: 0.5 * (p / Math.PI + 0.5), y: 1 - 0.5 * (m / Math.PI + 1), z: 0 };
        }
        unproject(e, i) {
          let n = e = (2 * e - 0.5) * Math.PI, a = i = (2 * (1 - i) - 1) * Math.PI, c = 25;
          const h = 1e-6;
          let p = 0, m = 0;
          do {
            const _ = Math.cos(a), v = Math.sin(a), w = 2 * v * _, T = v * v, C = _ * _, A = Math.cos(n / 2), z = Math.sin(n / 2), U = 2 * A * z, q = z * z, ie = 1 - C * A * A, W = ie ? 1 / ie : 0, te = ie ? Math.acos(_ * A) * Math.sqrt(1 / ie) : 0, ae = 0.5 * (2 * te * _ * z + 2 * n / Math.PI) - e, oe = 0.5 * (te * v + a) - i, Se = 0.5 * W * (C * q + te * _ * A * T) + 1 / Math.PI, we = W * (U * w / 4 - te * v * z), ke = 0.125 * W * (w * z - te * v * C * U), $e = 0.5 * W * (T * A + te * q * _) + 0.5, Ae = we * ke - $e * Se;
            p = (oe * we - ae * $e) / Ae, m = (ae * ke - oe * Se) / Ae, n = Vt(n - p, -Math.PI, Math.PI), a = Vt(a - m, -cm, cm);
          } while ((Math.abs(p) > h || Math.abs(m) > h) && --c > 0);
          return new Ci(Fi(n), Fi(a));
        }
      }
      class um extends xa {
        constructor(e) {
          super(e), this.center = e.center || [0, 0], this.parallels = e.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(Pt(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
        }
        project(e, i) {
          const { scale: n, cosPhi: a } = this;
          return { x: Pt(e) * a * n + 0.5, y: -Math.sin(Pt(i)) / a * n + 0.5, z: 0 };
        }
        unproject(e, i) {
          const { scale: n, cosPhi: a } = this, c = -(i - 0.5) / n, h = Vt(Fi((e - 0.5) / n) / a, -180, 180), p = Math.asin(Vt(c * a, -1, 1)), m = Vt(Fi(p), -$r, $r);
          return new Ci(h, m);
        }
      }
      class Yy extends am {
        constructor(e) {
          super(e), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
        }
        projectTilePoint(e, i, n) {
          const a = Nc(e, i, n);
          return rr(a, a, jc(ms(n))), { x: a[0], y: a[1], z: a[2] };
        }
        locationPoint(e, i) {
          const n = Nl(i.lat, i.lng), a = un([], n), c = e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(i), e._centerAltitude) : e._centerAltitude;
          Oc(n, n, a, Wo(1, 0) * Et * c);
          const h = Zo(new Float64Array(16));
          return el(h, e.pixelMatrix, e.globeMatrix), rr(n, n, h), new et(n[0], n[1]);
        }
        pixelsPerMeter(e, i) {
          return Wo(1, 0) * i;
        }
        pixelSpaceConversion(e, i, n) {
          const a = Wo(1, e) * i, c = Kt(Wo(1, 45) * i, a, n);
          return this.pixelsPerMeter(e, i) / c;
        }
        createTileMatrix(e, i, n) {
          const a = Jh(ms(n.canonical));
          return el(new Float64Array(16), e.globeMatrix, a);
        }
        createInversionMatrix(e, i) {
          const { center: n } = e, a = jc(ms(i));
          return Ru(a, a, Pt(n.lng)), jh(a, a, Pt(n.lat)), tl(a, a, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]), Float32Array.from(a);
        }
        pointCoordinate(e, i, n, a) {
          return Op(e, i, n, !0) || new Vl(0, 0);
        }
        pointCoordinate3D(e, i, n) {
          const a = this.pointCoordinate(e, i, n, 0);
          return [a.x, a.y, a.z];
        }
        isPointAboveHorizon(e, i) {
          return !Op(e, i.x, i.y, !1);
        }
        farthestPixelDistance(e) {
          const i = function(a, c) {
            const h = a.cameraToCenterDistance, p = a._centerAltitude * c, m = a._camera, _ = a._camera.forward(), v = Gs([], ro([], _, -h), [0, 0, p]), w = a.worldSize / (2 * Math.PI), T = [0, 0, -w], C = a.width / a.height, A = Math.tan(a.fovAboveCenter), z = ro([], m.up(), A), U = ro([], m.right(), A * C), q = un([], Gs([], Gs([], _, z), U)), ie = [];
            let W;
            if (new Zh(v, q).closestPointOnSphere(T, w, ie)) {
              const te = Gs([], ie, T), ae = qo([], te, v);
              W = Math.cos(a.fovAboveCenter) * kc(ae);
            } else {
              const te = qo([], v, T), ae = qo([], T, v);
              un(ae, ae);
              const oe = kc(te) - w;
              W = Math.sqrt(oe * (oe + 2 * w));
              const Se = Math.acos(W / (w + oe)) - Math.acos(So(_, ae));
              W *= Math.cos(Se);
            }
            return 1.01 * W;
          }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)), n = jl(e.zoom);
          if (n > 0) {
            const a = sm(e, Wo(1, e.center.lat) * e.worldSize), c = e.worldSize / (2 * Math.PI), h = Math.max(e.width, e.height) / e.worldSize * Math.PI;
            return Kt(i, a + c * (1 - Math.cos(h)), Math.pow(n, 10));
          }
          return i;
        }
        upVector(e, i, n) {
          return Nc(i, n, e, 1);
        }
        upVectorScale(e) {
          return { metersToTile: Ou(Fu(ms(e))) };
        }
      }
      function hm(t) {
        const e = t.parallels, i = !!e && Math.abs(e[0] + e[1]) < 0.01;
        switch (t.name) {
          case "mercator":
            return new am(t);
          case "equirectangular":
            return new Xy(t);
          case "naturalEarth":
            return new Ky(t);
          case "equalEarth":
            return new Wy(t);
          case "winkelTripel":
            return new Jy(t);
          case "albers":
            return i ? new um(t) : new qy(t);
          case "lambertConformalConic":
            return i ? new um(t) : new Hy(t);
          case "globe":
            return new Yy(t);
        }
        throw new Error(`Invalid projection name: ${t.name}`);
      }
      const Qy = Xu.types, ex = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function lh(t, e, i, n, a, c, h, p, m, _, v, w, T) {
        const C = p ? Math.min(ya, Math.round(p[0])) : 0, A = p ? Math.min(ya, Math.round(p[1])) : 0;
        t.emplaceBack(e, i, Math.round(32 * n), Math.round(32 * a), c, h, (C << 1) + (m ? 1 : 0), A, 16 * _, 16 * v, 256 * w, 256 * T);
      }
      function ch(t, e, i, n, a, c, h) {
        t.emplaceBack(e, i, n, a, c, h);
      }
      function uh(t, e, i, n, a) {
        t.emplaceBack(e, i, n, a), t.emplaceBack(e, i, n, a), t.emplaceBack(e, i, n, a), t.emplaceBack(e, i, n, a);
      }
      function tx(t) {
        for (const e of t.sections) if (Oh(e.text)) return !0;
        return !1;
      }
      class Ad {
        constructor(e) {
          this.layoutVertexArray = new Ne(), this.indexArray = new vt(), this.programConfigurations = e, this.segments = new ur(), this.dynamicLayoutVertexArray = new Ve(), this.opacityVertexArray = new wt(), this.placedSymbolArray = new cr(), this.globeExtVertexArray = new He();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(e, i, n, a) {
          this.isEmpty() || (n && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, cy.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, hy.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, ex, !0), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, uy.members, !0)), this.opacityVertexBuffer.itemSize = 1), (n || a) && this.programConfigurations.upload(e));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
      }
      _t(Ad, "SymbolBuffers");
      class Id {
        constructor(e, i, n) {
          this.layoutVertexArray = new e(), this.layoutAttributes = i, this.indexArray = new n(), this.segments = new ur(), this.collisionVertexArray = new ti(), this.collisionVertexArrayExt = new Yt();
        }
        upload(e) {
          this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, dy.members, !0), this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, py.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      _t(Id, "CollisionBuffers");
      class va {
        constructor(e) {
          this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((h) => h.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Zo([]), this.placementViewportMatrix = Zo([]);
          const i = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = gd(this.zoom, i["text-size"]), this.iconSizeData = gd(this.zoom, i["icon-size"]);
          const n = this.layers[0].layout, a = n.get("symbol-sort-key"), c = n.get("symbol-z-order");
          this.canOverlap = n.get("text-allow-overlap") || n.get("icon-allow-overlap") || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = c !== "viewport-y" && a.constantOr(1) !== void 0, this.sortFeaturesByY = (c === "viewport-y" || c === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = n.get("text-writing-mode").map((h) => oo[h]), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id), this.sourceID = e.sourceID, this.projection = e.projection;
        }
        createArrays() {
          this.text = new Ad(new Qa(this.layers, this.zoom, (e) => /^text/.test(e))), this.icon = new Ad(new Qa(this.layers, this.zoom, (e) => /^icon/.test(e))), this.glyphOffsetArray = new cn(), this.lineVertexArray = new Rl(), this.symbolInstances = new ji();
        }
        calculateGlyphDependencies(e, i, n, a, c) {
          for (let h = 0; h < e.length; h++) if (i[e.charCodeAt(h)] = !0, a && c) {
            const p = Yc[e.charAt(h)];
            p && (i[p.charCodeAt(0)] = !0);
          }
        }
        populate(e, i, n, a) {
          const c = this.layers[0], h = c.layout, p = this.projection.name === "globe", m = h.get("text-font"), _ = h.get("text-field"), v = h.get("icon-image"), w = (_.value.kind !== "constant" || _.value.value instanceof yi && !_.value.value.isEmpty() || _.value.value.toString().length > 0) && (m.value.kind !== "constant" || m.value.value.length > 0), T = v.value.kind !== "constant" || !!v.value.value || Object.keys(v.parameters).length > 0, C = h.get("symbol-sort-key");
          if (this.features = [], !w && !T) return;
          const A = i.iconDependencies, z = i.glyphDependencies, U = i.availableImages, q = new b(this.zoom);
          for (const { feature: ie, id: W, index: te, sourceLayerIndex: ae } of e) {
            const oe = c._featureFilter.needGeometry, Se = ol(ie, oe);
            if (!c._featureFilter.filter(q, Se, n)) continue;
            if (oe || (Se.geometry = $s(ie, n, a)), p && ie.type !== 1 && n.z <= 5) {
              const Ae = Se.geometry, Fe = 0.98078528056, Ue = (je, Je) => So(Nc(je.x, je.y, n, 1), Nc(Je.x, Je.y, n, 1)) < Fe;
              for (let je = 0; je < Ae.length; je++) Ae[je] = hg(Ae[je], Ue);
            }
            let we, ke;
            if (w) {
              const Ae = c.getValueAndResolveTokens("text-field", Se, n, U), Fe = yi.factory(Ae);
              tx(Fe) && (this.hasRTLText = !0), (!this.hasRTLText || f() === "unavailable" || this.hasRTLText && x.isParsed()) && (we = _y(Fe, c, Se));
            }
            if (T) {
              const Ae = c.getValueAndResolveTokens("icon-image", Se, n, U);
              ke = Ae instanceof xi ? Ae : xi.fromString(Ae);
            }
            if (!we && !ke) continue;
            const $e = this.sortFeaturesByKey ? C.evaluate(Se, {}, n) : void 0;
            if (this.features.push({ id: W, text: we, icon: ke, index: te, sourceLayerIndex: ae, geometry: Se.geometry, properties: ie.properties, type: Qy[ie.type], sortKey: $e }), ke && (A[ke.name] = !0), we) {
              const Ae = m.evaluate(Se, {}, n).join(","), Fe = h.get("text-rotation-alignment") === "map" && h.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(oo.vertical) >= 0;
              for (const Ue of we.sections) if (Ue.image) A[Ue.image.name] = !0;
              else {
                const je = Sc(we.toString()), Je = Ue.fontStack || Ae, Le = z[Je] = z[Je] || {};
                this.calculateGlyphDependencies(Ue.text, Le, Fe, this.allowVerticalPlacement, je);
              }
            }
          }
          h.get("symbol-placement") === "line" && (this.features = function(ie) {
            const W = {}, te = {}, ae = [];
            let oe = 0;
            function Se(Ae) {
              ae.push(ie[Ae]), oe++;
            }
            function we(Ae, Fe, Ue) {
              const je = te[Ae];
              return delete te[Ae], te[Fe] = je, ae[je].geometry[0].pop(), ae[je].geometry[0] = ae[je].geometry[0].concat(Ue[0]), je;
            }
            function ke(Ae, Fe, Ue) {
              const je = W[Fe];
              return delete W[Fe], W[Ae] = je, ae[je].geometry[0].shift(), ae[je].geometry[0] = Ue[0].concat(ae[je].geometry[0]), je;
            }
            function $e(Ae, Fe, Ue) {
              const je = Ue ? Fe[0][Fe[0].length - 1] : Fe[0][0];
              return `${Ae}:${je.x}:${je.y}`;
            }
            for (let Ae = 0; Ae < ie.length; Ae++) {
              const Fe = ie[Ae], Ue = Fe.geometry, je = Fe.text ? Fe.text.toString() : null;
              if (!je) {
                Se(Ae);
                continue;
              }
              const Je = $e(je, Ue), Le = $e(je, Ue, !0);
              if (Je in te && Le in W && te[Je] !== W[Le]) {
                const ot = ke(Je, Le, Ue), yt = we(Je, Le, ae[ot].geometry);
                delete W[Je], delete te[Le], te[$e(je, ae[yt].geometry, !0)] = yt, ae[ot].geometry = null;
              } else Je in te ? we(Je, Le, Ue) : Le in W ? ke(Je, Le, Ue) : (Se(Ae), W[Je] = oe - 1, te[Le] = oe - 1);
            }
            return ae.filter((Ae) => Ae.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((ie, W) => ie.sortKey - W.sortKey);
        }
        update(e, i, n, a) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, i, this.layers, n, a), this.icon.programConfigurations.updatePaintArrays(e, i, this.layers, n, a));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(e) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = hm(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(e, i) {
          const n = this.lineVertexArray.length;
          if (e.segment !== void 0) for (const { x: a, y: c } of i) this.lineVertexArray.emplaceBack(a, c);
          return { lineStartIndex: n, lineLength: this.lineVertexArray.length - n };
        }
        addSymbols(e, i, n, a, c, h, p, m, _, v, w, T, C, A) {
          const z = e.indexArray, U = e.layoutVertexArray, q = e.globeExtVertexArray, ie = e.segments.prepareSegment(4 * i.length, U, z, this.canOverlap ? h.sortKey : void 0), W = this.glyphOffsetArray.length, te = ie.vertexLength, ae = this.allowVerticalPlacement && p === oo.vertical ? Math.PI / 2 : 0, oe = h.text && h.text.sections;
          for (let we = 0; we < i.length; we++) {
            const { tl: ke, tr: $e, bl: Ae, br: Fe, tex: Ue, pixelOffsetTL: je, pixelOffsetBR: Je, minFontScaleX: Le, minFontScaleY: ot, glyphOffset: yt, isSDF: at, sectionIndex: Ut } = i[we], Ye = ie.vertexLength, Tt = yt[1];
            if (lh(U, _.x, _.y, ke.x, Tt + ke.y, Ue.x, Ue.y, n, at, je.x, je.y, Le, ot), lh(U, _.x, _.y, $e.x, Tt + $e.y, Ue.x + Ue.w, Ue.y, n, at, Je.x, je.y, Le, ot), lh(U, _.x, _.y, Ae.x, Tt + Ae.y, Ue.x, Ue.y + Ue.h, n, at, je.x, Je.y, Le, ot), lh(U, _.x, _.y, Fe.x, Tt + Fe.y, Ue.x + Ue.w, Ue.y + Ue.h, n, at, Je.x, Je.y, Le, ot), m) {
              const { x: Nt, y: hi, z: jt } = m.anchor, [At, Bi, $t] = m.up;
              ch(q, Nt, hi, jt, At, Bi, $t), ch(q, Nt, hi, jt, At, Bi, $t), ch(q, Nt, hi, jt, At, Bi, $t), ch(q, Nt, hi, jt, At, Bi, $t), uh(e.dynamicLayoutVertexArray, Nt, hi, jt, ae);
            } else uh(e.dynamicLayoutVertexArray, _.x, _.y, _.z, ae);
            z.emplaceBack(Ye, Ye + 1, Ye + 2), z.emplaceBack(Ye + 1, Ye + 2, Ye + 3), ie.vertexLength += 4, ie.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(yt[0]), we !== i.length - 1 && Ut === i[we + 1].sectionIndex || e.programConfigurations.populatePaintArrays(U.length, h, h.index, {}, C, A, oe && oe[Ut]);
          }
          const Se = m ? m.anchor : _;
          e.placedSymbolArray.emplaceBack(Se.x, Se.y, Se.z, _.x, _.y, W, this.glyphOffsetArray.length - W, te, v, w, _.segment, n ? n[0] : 0, n ? n[1] : 0, a[0], a[1], p, 0, !1, 0, T, 0);
        }
        _commitLayoutVertex(e, i, n, a, c, h, p) {
          e.emplaceBack(i, n, a, c, h, Math.round(p.x), Math.round(p.y));
        }
        _addCollisionDebugVertices(e, i, n, a, c, h, p) {
          const m = n.segments.prepareSegment(4, n.layoutVertexArray, n.indexArray), _ = m.vertexLength, v = p.tileAnchorX, w = p.tileAnchorY;
          for (let C = 0; C < 4; C++) n.collisionVertexArray.emplaceBack(0, 0, 0, 0);
          n.collisionVertexArrayExt.emplaceBack(i, -e.padding, -e.padding), n.collisionVertexArrayExt.emplaceBack(i, e.padding, -e.padding), n.collisionVertexArrayExt.emplaceBack(i, e.padding, e.padding), n.collisionVertexArrayExt.emplaceBack(i, -e.padding, e.padding), this._commitLayoutVertex(n.layoutVertexArray, a, c, h, v, w, new et(e.x1, e.y1)), this._commitLayoutVertex(n.layoutVertexArray, a, c, h, v, w, new et(e.x2, e.y1)), this._commitLayoutVertex(n.layoutVertexArray, a, c, h, v, w, new et(e.x2, e.y2)), this._commitLayoutVertex(n.layoutVertexArray, a, c, h, v, w, new et(e.x1, e.y2)), m.vertexLength += 4;
          const T = n.indexArray;
          T.emplaceBack(_, _ + 1), T.emplaceBack(_ + 1, _ + 2), T.emplaceBack(_ + 2, _ + 3), T.emplaceBack(_ + 3, _), m.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(e, i, n, a, c, h) {
          for (let p = a; p < c; p++) {
            const m = n.get(p), _ = this.getSymbolInstanceTextSize(e, h, i, p);
            this._addCollisionDebugVertices(m, _, this.textCollisionBox, m.projectedAnchorX, m.projectedAnchorY, m.projectedAnchorZ, h);
          }
        }
        _addIconDebugCollisionBoxes(e, i, n, a, c, h) {
          for (let p = a; p < c; p++) {
            const m = n.get(p), _ = this.getSymbolInstanceIconSize(e, i, h.placedIconSymbolIndex);
            this._addCollisionDebugVertices(m, _, this.iconCollisionBox, m.projectedAnchorX, m.projectedAnchorY, m.projectedAnchorZ, h);
          }
        }
        generateCollisionDebugBuffers(e, i) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Id(gt, Pf.members, Er), this.iconCollisionBox = new Id(gt, Pf.members, Er);
          const n = Wl(this.iconSizeData, e), a = Wl(this.textSizeData, e);
          for (let c = 0; c < this.symbolInstances.length; c++) {
            const h = this.symbolInstances.get(c);
            this._addTextDebugCollisionBoxes(a, e, i, h.textBoxStartIndex, h.textBoxEndIndex, h), this._addTextDebugCollisionBoxes(a, e, i, h.verticalTextBoxStartIndex, h.verticalTextBoxEndIndex, h), this._addIconDebugCollisionBoxes(n, e, i, h.iconBoxStartIndex, h.iconBoxEndIndex, h), this._addIconDebugCollisionBoxes(n, e, i, h.verticalIconBoxStartIndex, h.verticalIconBoxEndIndex, h);
          }
        }
        getSymbolInstanceTextSize(e, i, n, a) {
          const c = this.text.placedSymbolArray.get(i.rightJustifiedTextSymbolIndex >= 0 ? i.rightJustifiedTextSymbolIndex : i.centerJustifiedTextSymbolIndex >= 0 ? i.centerJustifiedTextSymbolIndex : i.leftJustifiedTextSymbolIndex >= 0 ? i.leftJustifiedTextSymbolIndex : i.verticalPlacedTextSymbolIndex >= 0 ? i.verticalPlacedTextSymbolIndex : a), h = Yu(this.textSizeData, e, c) / zr;
          return this.tilePixelRatio * h;
        }
        getSymbolInstanceIconSize(e, i, n) {
          const a = this.icon.placedSymbolArray.get(n), c = Yu(this.iconSizeData, e, a);
          return this.tilePixelRatio * c;
        }
        _commitDebugCollisionVertexUpdate(e, i, n) {
          e.emplaceBack(i, -n, -n), e.emplaceBack(i, n, -n), e.emplaceBack(i, n, n), e.emplaceBack(i, -n, n);
        }
        _updateTextDebugCollisionBoxes(e, i, n, a, c, h) {
          for (let p = a; p < c; p++) {
            const m = n.get(p), _ = this.getSymbolInstanceTextSize(e, h, i, p);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, _, m.padding);
          }
        }
        _updateIconDebugCollisionBoxes(e, i, n, a, c, h) {
          for (let p = a; p < c; p++) {
            const m = n.get(p), _ = this.getSymbolInstanceIconSize(e, i, h);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, _, m.padding);
          }
        }
        updateCollisionDebugBuffers(e, i) {
          if (!this.hasDebugData()) return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const n = Wl(this.iconSizeData, e), a = Wl(this.textSizeData, e);
          for (let c = 0; c < this.symbolInstances.length; c++) {
            const h = this.symbolInstances.get(c);
            this._updateTextDebugCollisionBoxes(a, e, i, h.textBoxStartIndex, h.textBoxEndIndex, h), this._updateTextDebugCollisionBoxes(a, e, i, h.verticalTextBoxStartIndex, h.verticalTextBoxEndIndex, h), this._updateIconDebugCollisionBoxes(n, e, i, h.iconBoxStartIndex, h.iconBoxEndIndex, h.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(n, e, i, h.verticalIconBoxStartIndex, h.verticalIconBoxEndIndex, h.placedIconSymbolIndex);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(e, i, n, a, c, h, p, m, _) {
          const v = {};
          if (i < n) {
            const { x1: w, y1: T, x2: C, y2: A, padding: z, projectedAnchorX: U, projectedAnchorY: q, projectedAnchorZ: ie, tileAnchorX: W, tileAnchorY: te, featureIndex: ae } = e.get(i);
            v.textBox = { x1: w, y1: T, x2: C, y2: A, padding: z, projectedAnchorX: U, projectedAnchorY: q, projectedAnchorZ: ie, tileAnchorX: W, tileAnchorY: te }, v.textFeatureIndex = ae;
          }
          if (a < c) {
            const { x1: w, y1: T, x2: C, y2: A, padding: z, projectedAnchorX: U, projectedAnchorY: q, projectedAnchorZ: ie, tileAnchorX: W, tileAnchorY: te, featureIndex: ae } = e.get(a);
            v.verticalTextBox = { x1: w, y1: T, x2: C, y2: A, padding: z, projectedAnchorX: U, projectedAnchorY: q, projectedAnchorZ: ie, tileAnchorX: W, tileAnchorY: te }, v.verticalTextFeatureIndex = ae;
          }
          if (h < p) {
            const { x1: w, y1: T, x2: C, y2: A, padding: z, projectedAnchorX: U, projectedAnchorY: q, projectedAnchorZ: ie, tileAnchorX: W, tileAnchorY: te, featureIndex: ae } = e.get(h);
            v.iconBox = { x1: w, y1: T, x2: C, y2: A, padding: z, projectedAnchorX: U, projectedAnchorY: q, projectedAnchorZ: ie, tileAnchorX: W, tileAnchorY: te }, v.iconFeatureIndex = ae;
          }
          if (m < _) {
            const { x1: w, y1: T, x2: C, y2: A, padding: z, projectedAnchorX: U, projectedAnchorY: q, projectedAnchorZ: ie, tileAnchorX: W, tileAnchorY: te, featureIndex: ae } = e.get(m);
            v.verticalIconBox = { x1: w, y1: T, x2: C, y2: A, padding: z, projectedAnchorX: U, projectedAnchorY: q, projectedAnchorZ: ie, tileAnchorX: W, tileAnchorY: te }, v.verticalIconFeatureIndex = ae;
          }
          return v;
        }
        deserializeCollisionBoxes(e) {
          this.collisionArrays = [];
          for (let i = 0; i < this.symbolInstances.length; i++) {
            const n = this.symbolInstances.get(i);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, n.textBoxStartIndex, n.textBoxEndIndex, n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n.iconBoxStartIndex, n.iconBoxEndIndex, n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(e, i) {
          const n = e.placedSymbolArray.get(i), a = n.vertexStartIndex + 4 * n.numGlyphs;
          for (let c = n.vertexStartIndex; c < a; c += 4) e.indexArray.emplaceBack(c, c + 1, c + 2), e.indexArray.emplaceBack(c + 1, c + 2, c + 3);
        }
        getSortedSymbolIndexes(e) {
          if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const i = Math.sin(e), n = Math.cos(e), a = [], c = [], h = [];
          for (let p = 0; p < this.symbolInstances.length; ++p) {
            h.push(p);
            const m = this.symbolInstances.get(p);
            a.push(0 | Math.round(i * m.tileAnchorX + n * m.tileAnchorY)), c.push(m.featureIndex);
          }
          return h.sort((p, m) => a[p] - a[m] || c[m] - c[p]), h;
        }
        addToSortKeyRanges(e, i) {
          const n = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          n && n.sortKey === i ? n.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
        }
        sortFeatures(e) {
          if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const i of this.symbolInstanceIndexes) {
              const n = this.symbolInstances.get(i);
              this.featureSortOrder.push(n.featureIndex);
              const { rightJustifiedTextSymbolIndex: a, centerJustifiedTextSymbolIndex: c, leftJustifiedTextSymbolIndex: h, verticalPlacedTextSymbolIndex: p, placedIconSymbolIndex: m, verticalPlacedIconSymbolIndex: _ } = n;
              a >= 0 && this.addIndicesForPlacedSymbol(this.text, a), c >= 0 && c !== a && this.addIndicesForPlacedSymbol(this.text, c), h >= 0 && h !== c && h !== a && this.addIndicesForPlacedSymbol(this.text, h), p >= 0 && this.addIndicesForPlacedSymbol(this.text, p), m >= 0 && this.addIndicesForPlacedSymbol(this.icon, m), _ >= 0 && this.addIndicesForPlacedSymbol(this.icon, _);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      _t(va, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), va.MAX_GLYPHS = 65535, va.addDynamicAttributes = uh;
      const ix = new K({ "symbol-placement": new L(Pe.layout_symbol["symbol-placement"]), "symbol-spacing": new L(Pe.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new L(Pe.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new N(Pe.layout_symbol["symbol-sort-key"]), "symbol-z-order": new L(Pe.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new L(Pe.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new L(Pe.layout_symbol["icon-ignore-placement"]), "icon-optional": new L(Pe.layout_symbol["icon-optional"]), "icon-rotation-alignment": new L(Pe.layout_symbol["icon-rotation-alignment"]), "icon-size": new N(Pe.layout_symbol["icon-size"]), "icon-text-fit": new L(Pe.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new L(Pe.layout_symbol["icon-text-fit-padding"]), "icon-image": new N(Pe.layout_symbol["icon-image"]), "icon-rotate": new N(Pe.layout_symbol["icon-rotate"]), "icon-padding": new L(Pe.layout_symbol["icon-padding"]), "icon-keep-upright": new L(Pe.layout_symbol["icon-keep-upright"]), "icon-offset": new N(Pe.layout_symbol["icon-offset"]), "icon-anchor": new N(Pe.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new L(Pe.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new L(Pe.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new L(Pe.layout_symbol["text-rotation-alignment"]), "text-field": new N(Pe.layout_symbol["text-field"]), "text-font": new N(Pe.layout_symbol["text-font"]), "text-size": new N(Pe.layout_symbol["text-size"]), "text-max-width": new N(Pe.layout_symbol["text-max-width"]), "text-line-height": new N(Pe.layout_symbol["text-line-height"]), "text-letter-spacing": new N(Pe.layout_symbol["text-letter-spacing"]), "text-justify": new N(Pe.layout_symbol["text-justify"]), "text-radial-offset": new N(Pe.layout_symbol["text-radial-offset"]), "text-variable-anchor": new L(Pe.layout_symbol["text-variable-anchor"]), "text-anchor": new N(Pe.layout_symbol["text-anchor"]), "text-max-angle": new L(Pe.layout_symbol["text-max-angle"]), "text-writing-mode": new L(Pe.layout_symbol["text-writing-mode"]), "text-rotate": new N(Pe.layout_symbol["text-rotate"]), "text-padding": new L(Pe.layout_symbol["text-padding"]), "text-keep-upright": new L(Pe.layout_symbol["text-keep-upright"]), "text-transform": new N(Pe.layout_symbol["text-transform"]), "text-offset": new N(Pe.layout_symbol["text-offset"]), "text-allow-overlap": new L(Pe.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new L(Pe.layout_symbol["text-ignore-placement"]), "text-optional": new L(Pe.layout_symbol["text-optional"]) });
      var Pd = { paint: new K({ "icon-opacity": new N(Pe.paint_symbol["icon-opacity"]), "icon-color": new N(Pe.paint_symbol["icon-color"]), "icon-halo-color": new N(Pe.paint_symbol["icon-halo-color"]), "icon-halo-width": new N(Pe.paint_symbol["icon-halo-width"]), "icon-halo-blur": new N(Pe.paint_symbol["icon-halo-blur"]), "icon-translate": new L(Pe.paint_symbol["icon-translate"]), "icon-translate-anchor": new L(Pe.paint_symbol["icon-translate-anchor"]), "text-opacity": new N(Pe.paint_symbol["text-opacity"]), "text-color": new N(Pe.paint_symbol["text-color"], { runtimeType: Xr, getOverride: (t) => t.textColor, hasOverride: (t) => !!t.textColor }), "text-halo-color": new N(Pe.paint_symbol["text-halo-color"]), "text-halo-width": new N(Pe.paint_symbol["text-halo-width"]), "text-halo-blur": new N(Pe.paint_symbol["text-halo-blur"]), "text-translate": new L(Pe.paint_symbol["text-translate"]), "text-translate-anchor": new L(Pe.paint_symbol["text-translate-anchor"]) }), layout: ix };
      class dm {
        constructor(e) {
          this.type = e.property.overrides ? e.property.overrides.runtimeType : ho, this.defaultValue = e;
        }
        evaluate(e) {
          if (e.formattedSection) {
            const i = this.defaultValue.property.overrides;
            if (i && i.hasOverride(e.formattedSection)) return i.getOverride(e.formattedSection);
          }
          return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(e) {
          this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      _t(dm, "FormatSectionOverride", { omit: ["defaultValue"] });
      class hh extends $o {
        constructor(e) {
          super(e, Pd);
        }
        recalculate(e, i) {
          super.recalculate(e, i), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const n = this.layout.get("text-writing-mode");
          if (n) {
            const a = [];
            for (const c of n) a.indexOf(c) < 0 && a.push(c);
            this.layout._values["text-writing-mode"] = a;
          } else this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(e, i, n, a) {
          const c = this.layout.get(e).evaluate(i, {}, n, a), h = this._unevaluatedLayout._values[e];
          return h.isDataDriven() || eo(h.value) || !c ? c : function(p, m) {
            return m.replace(/{([^{}]+)}/g, (_, v) => v in p ? String(p[v]) : "");
          }(i.properties, c);
        }
        createBucket(e) {
          return new va(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        _setPaintOverrides() {
          for (const e of Pd.paint.overridableProperties) {
            if (!hh.hasPaintOverride(this.layout, e)) continue;
            const i = this.paint.get(e), n = new dm(i), a = new jo(n, i.property.specification);
            let c = null;
            c = i.value.kind === "constant" || i.value.kind === "source" ? new fc("source", a) : new $a("composite", a, i.value.zoomStops, i.value._interpolationType), this.paint._values[e] = new G(i.property, c, i.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(e, i, n) {
          return !(!this.layout || i.isDataDriven() || n.isDataDriven()) && hh.hasPaintOverride(this.layout, e);
        }
        static hasPaintOverride(e, i) {
          const n = e.get("text-field"), a = Pd.paint.properties[i];
          let c = !1;
          const h = (p) => {
            for (const m of p) if (a.overrides && a.overrides.hasOverride(m)) return void (c = !0);
          };
          if (n.value.kind === "constant" && n.value.value instanceof yi) h(n.value.value.sections);
          else if (n.value.kind === "source") {
            const p = (_) => {
              c || (_ instanceof Ar && Ft(_.value) === E ? h(_.value.sections) : _ instanceof Zn ? h(_.sections) : _.eachChild(p));
            }, m = n.value;
            m._styleExpression && p(m._styleExpression.expression);
          }
          return c;
        }
        getProgramConfiguration(e) {
          return new ma(this, e);
        }
      }
      var rx = { paint: new K({ "background-color": new L(Pe.paint_background["background-color"]), "background-pattern": new L(Pe.paint_background["background-pattern"]), "background-opacity": new L(Pe.paint_background["background-opacity"]) }) }, nx = { paint: new K({ "raster-opacity": new L(Pe.paint_raster["raster-opacity"]), "raster-hue-rotate": new L(Pe.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new L(Pe.paint_raster["raster-brightness-min"]), "raster-brightness-max": new L(Pe.paint_raster["raster-brightness-max"]), "raster-saturation": new L(Pe.paint_raster["raster-saturation"]), "raster-contrast": new L(Pe.paint_raster["raster-contrast"]), "raster-resampling": new L(Pe.paint_raster["raster-resampling"]), "raster-fade-duration": new L(Pe.paint_raster["raster-fade-duration"]) }) };
      class ox extends $o {
        constructor(e) {
          super(e, {}), this.implementation = e;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        isLayerDraped() {
          return this.implementation.renderToTile !== void 0;
        }
        shouldRedrape() {
          return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
        }
        onAdd(e) {
          this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl);
        }
        onRemove(e) {
          this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl);
        }
      }
      var sx = { paint: new K({ "sky-type": new L(Pe.paint_sky["sky-type"]), "sky-atmosphere-sun": new L(Pe.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new L(Pe.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new L(Pe.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new L(Pe.paint_sky["sky-gradient-radius"]), "sky-gradient": new X(Pe.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new L(Pe.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new L(Pe.paint_sky["sky-atmosphere-color"]), "sky-opacity": new L(Pe.paint_sky["sky-opacity"]) }) };
      function Ld(t, e, i) {
        const n = [0, 0, 1], a = Pp([]);
        return zp(a, a, i ? -Pt(t) + Math.PI : Pt(t)), Lp(a, a, -Pt(e)), Mp(n, n, a), un(n, n);
      }
      const ax = { circle: class extends $o {
        constructor(t) {
          super(t, yg);
        }
        createBucket(t) {
          return new rd(t);
        }
        queryRadius(t) {
          const e = t;
          return Gl("circle-radius", this, e) + Gl("circle-stroke-width", this, e) + ju(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t, e, i, n, a, c, h, p) {
          const m = ef(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), c.angle, t.pixelToTileUnitsFactor), _ = this.paint.get("circle-radius").evaluate(e, i) + this.paint.get("circle-stroke-width").evaluate(e, i);
          return tf(t, n, c, h, p, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", m, _);
        }
        getProgramIds() {
          return ["circle"];
        }
        getProgramConfiguration(t) {
          return new ma(this, t);
        }
      }, heatmap: class extends $o {
        createBucket(t) {
          return new nf(t);
        }
        constructor(t) {
          super(t, wg), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t) {
          t === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = ad({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(t) {
          return Gl("heatmap-radius", this, t);
        }
        queryIntersectsFeature(t, e, i, n, a, c, h, p) {
          const m = this.paint.get("heatmap-radius").evaluate(e, i);
          return tf(t, n, c, h, p, !0, !0, new et(0, 0), m);
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getProgramConfiguration(t) {
          return new ma(this, t);
        }
      }, hillshade: class extends $o {
        constructor(t) {
          super(t, Tg);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
      }, fill: class extends $o {
        constructor(t) {
          super(t, Ug);
        }
        getProgramIds() {
          const t = this.paint.get("fill-pattern"), e = t && t.constantOr(1), i = [e ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && i.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), i;
        }
        getProgramConfiguration(t) {
          return new ma(this, t);
        }
        recalculate(t, e) {
          super.recalculate(t, e);
          const i = this.paint._values["fill-outline-color"];
          i.value.kind === "constant" && i.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t) {
          return new qu(t);
        }
        queryRadius() {
          return ju(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t, e, i, n, a, c) {
          return !t.queryGeometry.isAboveHorizon && Hp(Qp(t.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), c.angle, t.pixelToTileUnitsFactor), n);
        }
        isTileClipped() {
          return !0;
        }
      }, "fill-extrusion": class extends $o {
        constructor(t) {
          super(t, ty);
        }
        createBucket(t) {
          return new Hc(t);
        }
        queryRadius() {
          return ju(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        getProgramConfiguration(t) {
          return new ma(this, t);
        }
        queryIntersectsFeature(t, e, i, n, a, c, h, p, m) {
          const _ = ef(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), c.angle, t.pixelToTileUnitsFactor), v = this.paint.get("fill-extrusion-height").evaluate(e, i), w = this.paint.get("fill-extrusion-base").evaluate(e, i), T = [0, 0], C = p && c.elevation, A = c.elevation ? c.elevation.exaggeration() : 1, z = t.tile.getBucket(this);
          if (C && z instanceof Hc) {
            const te = z.centroidVertexArray, ae = m + 1;
            ae < te.length && (T[0] = te.geta_centroid_pos0(ae), T[1] = te.geta_centroid_pos1(ae));
          }
          if (T[0] === 0 && T[1] === 1) return !1;
          c.projection.name === "globe" && (n = wf([n], [new et(0, 0), new et(Et, Et)], t.tileID.canonical).map((te) => te.polygon).flat());
          const U = C ? p : null, [q, ie] = function(te, ae, oe, Se, we, ke, $e, Ae, Fe, Ue, je) {
            return te.projection.name === "globe" ? function(Je, Le, ot, yt, at, Ut, Ye, Tt, Nt, hi, jt) {
              const At = [], Bi = [], $t = Je.projection.upVectorScale(jt, Je.center.lat, Je.worldSize).metersToTile, Zt = [0, 0, 0, 1], Ai = [0, 0, 0, 1], ki = (Ii, Xi, Qi, dr) => {
                Ii[0] = Xi, Ii[1] = Qi, Ii[2] = dr, Ii[3] = 1;
              }, Di = bf();
              ot > 0 && (ot += Di), yt += Di;
              for (const Ii of Le) {
                const Xi = [], Qi = [];
                for (const dr of Ii) {
                  const Pi = dr.x + at.x, vr = dr.y + at.y, pr = Je.projection.projectTilePoint(Pi, vr, jt), Ji = Je.projection.upVector(jt, dr.x, dr.y);
                  let mi = ot, fr = yt;
                  if (Ye) {
                    const Ri = Mf(Pi, vr, ot, yt, Ye, Tt, Nt, hi);
                    mi += Ri.base, fr += Ri.top;
                  }
                  ot !== 0 ? ki(Zt, pr.x + Ji[0] * $t * mi, pr.y + Ji[1] * $t * mi, pr.z + Ji[2] * $t * mi) : ki(Zt, pr.x, pr.y, pr.z), ki(Ai, pr.x + Ji[0] * $t * fr, pr.y + Ji[1] * $t * fr, pr.z + Ji[2] * $t * fr), rr(Zt, Zt, Ut), rr(Ai, Ai, Ut), Xi.push(new ql(Zt[0], Zt[1], Zt[2])), Qi.push(new ql(Ai[0], Ai[1], Ai[2]));
                }
                At.push(Xi), Bi.push(Qi);
              }
              return [At, Bi];
            }(te, ae, oe, Se, we, ke, $e, Ae, Fe, Ue, je) : $e ? function(Je, Le, ot, yt, at, Ut, Ye, Tt, Nt) {
              const hi = [], jt = [], At = [0, 0, 0, 1];
              for (const Bi of Je) {
                const $t = [], Zt = [];
                for (const Ai of Bi) {
                  const ki = Ai.x + yt.x, Di = Ai.y + yt.y, Ii = Mf(ki, Di, Le, ot, Ut, Ye, Tt, Nt);
                  At[0] = ki, At[1] = Di, At[2] = Ii.base, At[3] = 1, il(At, At, at), At[3] = Math.max(At[3], 1e-5);
                  const Xi = new ql(At[0] / At[3], At[1] / At[3], At[2] / At[3]);
                  At[0] = ki, At[1] = Di, At[2] = Ii.top, At[3] = 1, il(At, At, at), At[3] = Math.max(At[3], 1e-5);
                  const Qi = new ql(At[0] / At[3], At[1] / At[3], At[2] / At[3]);
                  $t.push(Xi), Zt.push(Qi);
                }
                hi.push($t), jt.push(Zt);
              }
              return [hi, jt];
            }(ae, oe, Se, we, ke, $e, Ae, Fe, Ue) : function(Je, Le, ot, yt, at) {
              const Ut = [], Ye = [], Tt = at[8] * Le, Nt = at[9] * Le, hi = at[10] * Le, jt = at[11] * Le, At = at[8] * ot, Bi = at[9] * ot, $t = at[10] * ot, Zt = at[11] * ot;
              for (const Ai of Je) {
                const ki = [], Di = [];
                for (const Ii of Ai) {
                  const Xi = Ii.x + yt.x, Qi = Ii.y + yt.y, dr = at[0] * Xi + at[4] * Qi + at[12], Pi = at[1] * Xi + at[5] * Qi + at[13], vr = at[2] * Xi + at[6] * Qi + at[14], pr = at[3] * Xi + at[7] * Qi + at[15], Ji = dr + Tt, mi = Pi + Nt, fr = vr + hi, Ri = Math.max(pr + jt, 1e-5), pn = dr + At, mr = Pi + Bi, kr = vr + $t, Sr = Math.max(pr + Zt, 1e-5);
                  ki.push(new ql(Ji / Ri, mi / Ri, fr / Ri)), Di.push(new ql(pn / Sr, mr / Sr, kr / Sr));
                }
                Ut.push(ki), Ye.push(Di);
              }
              return [Ut, Ye];
            }(ae, oe, Se, we, ke);
          }(c, n, w, v, _, h, U, T, A, c.center.lat, t.tileID.canonical), W = t.queryGeometry;
          return function(te, ae, oe) {
            let Se = 1 / 0;
            Hp(oe, ae) && (Se = Sf(oe, ae[0]));
            for (let we = 0; we < ae.length; we++) {
              const ke = ae[we], $e = te[we];
              for (let Ae = 0; Ae < ke.length - 1; Ae++) {
                const Fe = ke[Ae], Ue = [Fe, ke[Ae + 1], $e[Ae + 1], $e[Ae], Fe];
                Xp(oe, Ue) && (Se = Math.min(Se, Sf(oe, Ue)));
              }
            }
            return Se !== 1 / 0 && Se;
          }(q, ie, W.isPointQuery() ? W.screenBounds : W.screenGeometry);
        }
      }, line: class extends $o {
        constructor(t) {
          super(t, Cf), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(t) {
          if (t === "line-gradient") {
            const e = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof Ls, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        widthExpression() {
          return this._transitionablePaint._values["line-width"].value.expression;
        }
        recalculate(t, e) {
          super.recalculate(t, e), this.paint._values["line-floorwidth"] = Af.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
        }
        createBucket(t) {
          return new Ju(t);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getProgramConfiguration(t) {
          return new ma(this, t);
        }
        queryRadius(t) {
          const e = t, i = If(Gl("line-width", this, e), Gl("line-gap-width", this, e)), n = Gl("line-offset", this, e);
          return i / 2 + Math.abs(n) + ju(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t, e, i, n, a, c) {
          if (t.queryGeometry.isAboveHorizon) return !1;
          const h = Qp(t.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), c.angle, t.pixelToTileUnitsFactor), p = t.pixelToTileUnitsFactor / 2 * If(this.paint.get("line-width").evaluate(e, i), this.paint.get("line-gap-width").evaluate(e, i)), m = this.paint.get("line-offset").evaluate(e, i);
          return m && (n = function(_, v) {
            const w = [], T = new et(0, 0);
            for (let C = 0; C < _.length; C++) {
              const A = _[C], z = [];
              for (let U = 0; U < A.length; U++) {
                const q = A[U], ie = A[U + 1], W = U === 0 ? T : q.sub(A[U - 1])._unit()._perp(), te = U === A.length - 1 ? T : ie.sub(q)._unit()._perp(), ae = W._add(te)._unit();
                ae._mult(1 / (ae.x * te.x + ae.y * te.y)), z.push(ae._mult(v)._add(q));
              }
              w.push(z);
            }
            return w;
          }(n, m * t.pixelToTileUnitsFactor)), function(_, v, w) {
            for (let T = 0; T < v.length; T++) {
              const C = v[T];
              if (_.length >= 3) {
                for (let A = 0; A < C.length; A++) if (sl(_, C[A])) return !0;
              }
              if (fg(_, C, w)) return !0;
            }
            return !1;
          }(h, n, p);
        }
        isTileClipped() {
          return !0;
        }
      }, symbol: hh, background: class extends $o {
        constructor(t) {
          super(t, rx);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
      }, raster: class extends $o {
        constructor(t) {
          super(t, nx);
        }
        getProgramIds() {
          return ["raster"];
        }
      }, sky: class extends $o {
        constructor(t) {
          super(t, sx), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t) {
          t === "sky-gradient" ? this._updateColorRamp() : t !== "sky-atmosphere-sun" && t !== "sky-atmosphere-halo-color" && t !== "sky-atmosphere-color" && t !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = !0);
        }
        _updateColorRamp() {
          this.colorRamp = ad({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(t) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e = t.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
          }
          return !1;
        }
        getCenter(t, e) {
          if (this.paint.get("sky-type") === "atmosphere") {
            const n = this.paint.get("sky-atmosphere-sun"), a = !n, c = t.style.light, h = c.properties.get("position");
            return a && c.properties.get("anchor") === "viewport" && Ui("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), a ? Ld(h.azimuthal, 90 - h.polar, e) : Ld(n[0], 90 - n[1], e);
          }
          const i = this.paint.get("sky-gradient-center");
          return Ld(i[0], 90 - i[1], e);
        }
        is3D() {
          return !1;
        }
        isSky() {
          return !0;
        }
        markSkyboxValid(t) {
          this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return !0;
        }
        getProgramIds() {
          const t = this.paint.get("sky-type");
          return t === "atmosphere" ? ["skyboxCapture", "skybox"] : t === "gradient" ? ["skyboxGradient"] : null;
        }
      } };
      class su {
        constructor(e, i, n, a) {
          this.context = e, this.format = n, this.texture = e.gl.createTexture(), this.update(i, a);
        }
        update(e, i, n) {
          const { width: a, height: c } = e, { context: h } = this, { gl: p } = h, { HTMLImageElement: m, HTMLCanvasElement: _, HTMLVideoElement: v, ImageData: w, ImageBitmap: T } = re;
          if (p.bindTexture(p.TEXTURE_2D, this.texture), h.pixelStoreUnpackFlipY.set(!1), h.pixelStoreUnpack.set(1), h.pixelStoreUnpackPremultiplyAlpha.set(this.format === p.RGBA && (!i || i.premultiply !== !1)), n || this.size && this.size[0] === a && this.size[1] === c) {
            const { x: C, y: A } = n || { x: 0, y: 0 };
            e instanceof m || e instanceof _ || e instanceof v || e instanceof w || T && e instanceof T ? p.texSubImage2D(p.TEXTURE_2D, 0, C, A, p.RGBA, p.UNSIGNED_BYTE, e) : p.texSubImage2D(p.TEXTURE_2D, 0, C, A, a, c, p.RGBA, p.UNSIGNED_BYTE, e.data);
          } else this.size = [a, c], e instanceof m || e instanceof _ || e instanceof v || e instanceof w || T && e instanceof T ? p.texImage2D(p.TEXTURE_2D, 0, this.format, this.format, p.UNSIGNED_BYTE, e) : p.texImage2D(p.TEXTURE_2D, 0, this.format, a, c, 0, this.format, p.UNSIGNED_BYTE, e.data);
          this.useMipmap = !!(i && i.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && p.generateMipmap(p.TEXTURE_2D);
        }
        bind(e, i) {
          const { context: n } = this, { gl: a } = n;
          a.bindTexture(a.TEXTURE_2D, this.texture), e !== this.filter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, this.useMipmap ? e === a.NEAREST ? a.NEAREST_MIPMAP_NEAREST : a.LINEAR_MIPMAP_NEAREST : e), this.filter = e), i !== this.wrap && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, i), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, i), this.wrap = i);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: e } = this.context;
          e.deleteTexture(this.texture), this.texture = null;
        }
      }
      class lx {
        constructor(e) {
          this._callback = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class cx {
        constructor() {
          this.tasks = {}, this.taskQueue = [], tr(["process"], this), this.invoker = new lx(this.process), this.nextId = 0;
        }
        add(e, i) {
          const n = this.nextId++, a = function({ type: c, isSymbolTile: h, zoom: p }) {
            return p = p || 0, c === "message" ? 0 : c !== "maybePrepare" || h ? c !== "parseTile" || h ? c === "parseTile" && h ? 300 - p : c === "maybePrepare" && h ? 400 - p : 500 : 200 - p : 100 - p;
          }(i);
          if (a === 0) {
            jn();
            try {
              e();
            } finally {
            }
            return { cancel: () => {
            } };
          }
          return this.tasks[n] = { fn: e, metadata: i, priority: a, id: n }, this.taskQueue.push(n), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[n];
          } };
        }
        process() {
          jn();
          try {
            if (this.taskQueue = this.taskQueue.filter((n) => !!this.tasks[n]), !this.taskQueue.length) return;
            const e = this.pick();
            if (e === null) return;
            const i = this.tasks[e];
            if (delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), !i) return;
            i.fn();
          } finally {
          }
        }
        pick() {
          let e = null, i = 1 / 0;
          for (let a = 0; a < this.taskQueue.length; a++) {
            const c = this.tasks[this.taskQueue[a]];
            c.priority < i && (i = c.priority, e = a);
          }
          if (e === null) return null;
          const n = this.taskQueue[e];
          return this.taskQueue.splice(e, 1), n;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class pm {
        constructor(e) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let i = 0; i < e.length; i++) {
            const n = e[i];
            this._stringToNumber[n] = i, this._numberToString[i] = n;
          }
        }
        encode(e) {
          return this._stringToNumber[e];
        }
        decode(e) {
          return this._numberToString[e];
        }
      }
      const ux = ["tile", "layer", "source", "sourceLayer", "state"];
      class fm {
        constructor(e, i, n, a, c) {
          this.type = "Feature", this._vectorTileFeature = e, this._z = i, this._x = n, this._y = a, this.properties = e.properties, this.id = c;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(e) {
          this._geometry = e;
        }
        toJSON() {
          const e = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
          this.id !== void 0 && (e.id = this.id);
          for (const i of ux) this[i] !== void 0 && (e[i] = this[i]);
          return e;
        }
      }
      const Ao = 32, ys = 33, ba = new Uint16Array(8184);
      for (let t = 0; t < 2046; t++) {
        let e = t + 2, i = 0, n = 0, a = 0, c = 0, h = 0, p = 0;
        for (1 & e ? a = c = h = Ao : i = n = p = Ao; (e >>= 1) > 1; ) {
          const _ = i + a >> 1, v = n + c >> 1;
          1 & e ? (a = i, c = n, i = h, n = p) : (i = a, n = c, a = h, c = p), h = _, p = v;
        }
        const m = 4 * t;
        ba[m + 0] = i, ba[m + 1] = n, ba[m + 2] = a, ba[m + 3] = c;
      }
      const xs = new Uint16Array(2178), wa = new Uint8Array(1089), dh = new Uint16Array(1089);
      function mm(t) {
        return t === 0 ? -0.03125 : t === 32 ? 0.03125 : 0;
      }
      var _m = me([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      const gm = { type: 2, extent: Et, loadGeometry: () => [[new et(0, 0), new et(Et + 1, 0), new et(Et + 1, Et + 1), new et(0, Et + 1), new et(0, 0)]] };
      class zd {
        constructor(e, i, n, a, c) {
          this.tileID = e, this.uid = Or(), this.uses = 0, this.tileSize = i, this.tileZoom = n, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = c, this.expiredRequestCount = 0, this.state = "loading", a && a.transform && (this.projection = a.transform.projection);
        }
        registerFadeDuration(e) {
          const i = e + this.timeAdded;
          i < gn.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = ll(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(e, i, n) {
          if (this.unloadVectorData(), this.state = "loaded", e) {
            e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function(a, c) {
              const h = {};
              if (!c) return h;
              for (const p of a) {
                const m = p.layerIds.map((_) => c.getLayer(_)).filter(Boolean);
                if (m.length !== 0) {
                  p.layers = m, p.stateDependentLayerIds && (p.stateDependentLayers = p.stateDependentLayerIds.map((_) => m.filter((v) => v.id === _)[0]));
                  for (const _ of m) h[_.id] = p;
                }
              }
              return h;
            }(e.buckets, i.style), this.hasSymbolBuckets = !1;
            for (const a in this.buckets) {
              const c = this.buckets[a];
              if (c instanceof va) {
                if (this.hasSymbolBuckets = !0, !n) break;
                c.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const a in this.buckets) {
              const c = this.buckets[a];
              if (c instanceof va && c.hasRTLText) {
                this.hasRTLText = !0, x.isLoading() || x.isLoaded() || f() !== "deferred" || g();
                break;
              }
            }
            this.queryPadding = 0;
            for (const a in this.buckets) {
              const c = this.buckets[a];
              this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(a).queryRadius(c));
            }
            e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), e.lineAtlas && (this.lineAtlas = e.lineAtlas);
          } else this.collisionBoxArray = new Mi();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        getBucket(e) {
          return this.buckets[e.id];
        }
        upload(e) {
          for (const n in this.buckets) {
            const a = this.buckets[n];
            a.uploadPending() && a.upload(e);
          }
          const i = e.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new su(e, this.imageAtlas.image, i.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new su(e, this.glyphAtlasImage, i.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new su(e, this.lineAtlas.image, i.ALPHA), this.lineAtlas.uploaded = !0);
        }
        prepare(e) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
        }
        queryRenderedFeatures(e, i, n, a, c, h, p, m) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: a, pixelPosMatrix: p, transform: h, params: c, tileTransform: this.tileTransform }, e, i, n) : {};
        }
        querySourceFeatures(e, i) {
          const n = this.latestFeatureIndex;
          if (!n || !n.rawTileData) return;
          const a = n.loadVTLayers(), c = i ? i.sourceLayer : "", h = a._geojsonTileLayer || a[c];
          if (!h) return;
          const p = Ll(i && i.filter), { z: m, x: _, y: v } = this.tileID.canonical, w = { z: m, x: _, y: v };
          for (let T = 0; T < h.length; T++) {
            const C = h.feature(T);
            if (p.needGeometry) {
              const U = ol(C, !0);
              if (!p.filter(new b(this.tileID.overscaledZ), U, this.tileID.canonical)) continue;
            } else if (!p.filter(new b(this.tileID.overscaledZ), C)) continue;
            const A = n.getId(C, c), z = new fm(C, m, _, v, A);
            z.tile = w, e.push(z);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(e) {
          const i = this.expirationTime;
          if (e.cacheControl) {
            const n = Wr(e.cacheControl);
            n["max-age"] && (this.expirationTime = Date.now() + 1e3 * n["max-age"]);
          } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
          if (this.expirationTime) {
            const n = Date.now();
            let a = !1;
            if (this.expirationTime > n) a = !1;
            else if (i) if (this.expirationTime < i) a = !0;
            else {
              const c = this.expirationTime - i;
              c ? this.expirationTime = n + Math.max(c, 3e4) : a = !0;
            }
            else a = !0;
            a ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(e, i) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0 || !i) return;
          const n = this.latestFeatureIndex.loadVTLayers(), a = i.style.listImages();
          for (const c in this.buckets) {
            if (!i.style.hasLayer(c)) continue;
            const h = this.buckets[c], p = h.layers[0].sourceLayer || "_geojsonTileLayer", m = n[p], _ = e[p];
            if (!m || !_ || Object.keys(_).length === 0) continue;
            if (h.update(_, m, a, this.imageAtlas && this.imageAtlas.patternPositions || {}), h instanceof Ju || h instanceof qu) {
              const w = i.style._getSourceCache(h.layers[0].source);
              i._terrain && i._terrain.enabled && w && h.programConfigurations.needsUpload && i._terrain._clearRenderCacheForTile(w.id, this.tileID);
            }
            const v = i && i.style && i.style.getLayer(c);
            v && (this.queryPadding = Math.max(this.queryPadding, v.queryRadius(h)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < gn.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(e) {
          this.symbolFadeHoldUntil = gn.now() + e;
        }
        setTexture(e, i) {
          const n = i.context, a = n.gl;
          this.texture = this.texture || i.getTileTexture(e.width), this.texture ? this.texture.update(e, { useMipmap: !0 }) : (this.texture = new su(n, e, a.RGBA, { useMipmap: !0 }), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
        }
        setDependencies(e, i) {
          const n = {};
          for (const a of i) n[a] = !0;
          this.dependencies[e] = n;
        }
        hasDependency(e, i) {
          for (const n of e) {
            const a = this.dependencies[n];
            if (a) {
              for (const c of i) if (a[c]) return !0;
            }
          }
          return !1;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(e, i) {
          if (!i || i.name === "mercator" || this._tileDebugBuffer) return;
          const n = $s(gm, this.tileID.canonical, this.tileTransform)[0], a = new Ge(), c = new kn();
          for (let h = 0; h < n.length; h++) {
            const { x: p, y: m } = n[h];
            a.emplaceBack(p, m), c.emplaceBack(h);
          }
          c.emplaceBack(0), this._tileDebugIndexBuffer = e.createIndexBuffer(c), this._tileDebugBuffer = e.createVertexBuffer(a, Fc.members), this._tileDebugSegments = ur.simpleSegment(0, 0, a.length, c.length);
        }
        _makeTileBoundsBuffers(e, i) {
          if (this._tileBoundsBuffer || !i || i.name === "mercator") return;
          const n = $s(gm, this.tileID.canonical, this.tileTransform)[0];
          let a, c;
          if (this.isRaster) {
            const h = function(p, m) {
              const _ = ll(p, m), v = Math.pow(2, p.z);
              for (let U = 0; U < ys; U++) for (let q = 0; q < ys; q++) {
                const ie = no((p.x + (q + mm(q)) / Ao) / v), W = Gr((p.y + (U + mm(U)) / Ao) / v), te = m.project(ie, W), ae = U * ys + q;
                xs[2 * ae + 0] = Math.round((te.x * _.scale - _.x) * Et), xs[2 * ae + 1] = Math.round((te.y * _.scale - _.y) * Et);
              }
              wa.fill(0), dh.fill(0);
              for (let U = 2045; U >= 0; U--) {
                const q = 4 * U, ie = ba[q + 0], W = ba[q + 1], te = ba[q + 2], ae = ba[q + 3], oe = ie + te >> 1, Se = W + ae >> 1, we = oe + Se - W, ke = Se + ie - oe, $e = W * ys + ie, Ae = ae * ys + te, Fe = Se * ys + oe, Ue = Math.hypot((xs[2 * $e + 0] + xs[2 * Ae + 0]) / 2 - xs[2 * Fe + 0], (xs[2 * $e + 1] + xs[2 * Ae + 1]) / 2 - xs[2 * Fe + 1]) >= 16;
                wa[Fe] = wa[Fe] || (Ue ? 1 : 0), U < 1022 && (wa[Fe] = wa[Fe] || wa[(W + ke >> 1) * ys + (ie + we >> 1)] || wa[(ae + ke >> 1) * ys + (te + we >> 1)]);
              }
              const w = new Oe(), T = new vt();
              let C = 0;
              function A(U, q) {
                const ie = q * ys + U;
                return dh[ie] === 0 && (w.emplaceBack(xs[2 * ie + 0], xs[2 * ie + 1], U * Et / Ao, q * Et / Ao), dh[ie] = ++C), dh[ie] - 1;
              }
              function z(U, q, ie, W, te, ae) {
                const oe = U + ie >> 1, Se = q + W >> 1;
                if (Math.abs(U - te) + Math.abs(q - ae) > 1 && wa[Se * ys + oe]) z(te, ae, U, q, oe, Se), z(ie, W, te, ae, oe, Se);
                else {
                  const we = A(U, q), ke = A(ie, W), $e = A(te, ae);
                  T.emplaceBack(we, ke, $e);
                }
              }
              return z(0, 0, Ao, Ao, Ao, 0), z(Ao, Ao, 0, 0, 0, Ao), { vertices: w, indices: T };
            }(this.tileID.canonical, i);
            a = h.vertices, c = h.indices;
          } else {
            a = new Oe(), c = new vt();
            for (const { x: p, y: m } of n) a.emplaceBack(p, m, 0, 0);
            const h = dd(a.int16, void 0, 4);
            for (let p = 0; p < h.length; p += 3) c.emplaceBack(h[p], h[p + 1], h[p + 2]);
          }
          this._tileBoundsBuffer = e.createVertexBuffer(a, _m.members), this._tileBoundsIndexBuffer = e.createIndexBuffer(c), this._tileBoundsSegments = ur.simpleSegment(0, 0, a.length, c.length);
        }
        _makeGlobeTileDebugBuffers(e, i) {
          const n = i.projection;
          if (!n || n.name !== "globe" || i.freezeTileCoverage) return;
          const a = this.tileID.canonical, c = jc(Bp(a, i)), h = jl(i.zoom);
          let p;
          h > 0 && (p = Nh(new Float64Array(16), i.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(e, a, i, c, p, h), this._makeGlobeTileDebugTextBuffer(e, a, i, c, p, h);
        }
        _globePoint(e, i, n, a, c, h, p) {
          let m = Nc(e, i, n);
          if (h) {
            const _ = 1 << n.z, v = _s(a.center.lng), w = gs(a.center.lat), T = (n.x + 0.5) / _ - v;
            let C = 0;
            T > 0.5 ? C = -1 : T < -0.5 && (C = 1);
            let A = (e / Et + n.x) / _ + C, z = (i / Et + n.y) / _;
            A = (A - v) * a._pixelsPerMercatorPixel + v, z = (z - w) * a._pixelsPerMercatorPixel + w;
            const U = [A * a.worldSize, z * a.worldSize, 0];
            rr(U, U, h), m = nl(m, U, p);
          }
          return rr(m, m, c);
        }
        _makeGlobeTileDebugBorderBuffer(e, i, n, a, c, h) {
          const p = new Ge(), m = new kn(), _ = new be(), v = (T, C, A, z, U) => {
            const q = (A - T) / (U - 1), ie = (z - C) / (U - 1), W = p.length;
            for (let te = 0; te < U; te++) {
              const ae = T + te * q, oe = C + te * ie;
              p.emplaceBack(ae, oe);
              const Se = this._globePoint(ae, oe, i, n, a, c, h);
              _.emplaceBack(Se[0], Se[1], Se[2]), m.emplaceBack(W + te);
            }
          }, w = Et;
          v(0, 0, w, 0, 16), v(w, 0, w, w, 16), v(w, w, 0, w, 16), v(0, w, 0, 0, 16), this._tileDebugIndexBuffer = e.createIndexBuffer(m), this._tileDebugBuffer = e.createVertexBuffer(p, Fc.members), this._globeTileDebugBorderBuffer = e.createVertexBuffer(_, Dp.members), this._tileDebugSegments = ur.simpleSegment(0, 0, p.length, m.length);
        }
        _makeGlobeTileDebugTextBuffer(e, i, n, a, c, h) {
          const p = Et / 4, m = new Ge(), _ = new vt(), v = new be(), w = 25;
          _.reserve(32), m.reserve(w), v.reserve(w);
          const T = (C, A) => w * C + A;
          for (let C = 0; C < w; C++) {
            const A = C * p;
            for (let z = 0; z < w; z++) {
              const U = z * p;
              m.emplaceBack(U, A);
              const q = this._globePoint(U, A, i, n, a, c, h);
              v.emplaceBack(q[0], q[1], q[2]);
            }
          }
          for (let C = 0; C < 4; C++) for (let A = 0; A < 4; A++) {
            const z = T(C, A), U = T(C, A + 1), q = T(C + 1, A), ie = T(C + 1, A + 1);
            _.emplaceBack(z, U, q), _.emplaceBack(q, U, ie);
          }
          this._tileDebugTextIndexBuffer = e.createIndexBuffer(_), this._tileDebugTextBuffer = e.createVertexBuffer(m, Fc.members), this._globeTileDebugTextBuffer = e.createVertexBuffer(v, Dp.members), this._tileDebugTextSegments = ur.simpleSegment(0, 0, w, 32);
        }
      }
      class hx {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(e, i, n) {
          const a = String(i);
          if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][a] = this.stateChanges[e][a] || {}, si(this.stateChanges[e][a], n), this.deletedStates[e] === null) {
            this.deletedStates[e] = {};
            for (const c in this.state[e]) c !== a && (this.deletedStates[e][c] = null);
          } else if (this.deletedStates[e] && this.deletedStates[e][a] === null) {
            this.deletedStates[e][a] = {};
            for (const c in this.state[e][a]) n[c] || (this.deletedStates[e][a][c] = null);
          } else for (const c in n) this.deletedStates[e] && this.deletedStates[e][a] && this.deletedStates[e][a][c] === null && delete this.deletedStates[e][a][c];
        }
        removeFeatureState(e, i, n) {
          if (this.deletedStates[e] === null) return;
          const a = String(i);
          if (this.deletedStates[e] = this.deletedStates[e] || {}, n && i !== void 0) this.deletedStates[e][a] !== null && (this.deletedStates[e][a] = this.deletedStates[e][a] || {}, this.deletedStates[e][a][n] = null);
          else if (i !== void 0) if (this.stateChanges[e] && this.stateChanges[e][a]) for (n in this.deletedStates[e][a] = {}, this.stateChanges[e][a]) this.deletedStates[e][a][n] = null;
          else this.deletedStates[e][a] = null;
          else this.deletedStates[e] = null;
        }
        getState(e, i) {
          const n = String(i), a = si({}, (this.state[e] || {})[n], (this.stateChanges[e] || {})[n]);
          if (this.deletedStates[e] === null) return {};
          if (this.deletedStates[e]) {
            const c = this.deletedStates[e][i];
            if (c === null) return {};
            for (const h in c) delete a[h];
          }
          return a;
        }
        initializeTileState(e, i) {
          e.setFeatureState(this.state, i);
        }
        coalesceChanges(e, i) {
          const n = {};
          for (const a in this.stateChanges) {
            this.state[a] = this.state[a] || {};
            const c = {};
            for (const h in this.stateChanges[a]) this.state[a][h] || (this.state[a][h] = {}), si(this.state[a][h], this.stateChanges[a][h]), c[h] = this.state[a][h];
            n[a] = c;
          }
          for (const a in this.deletedStates) {
            this.state[a] = this.state[a] || {};
            const c = {};
            if (this.deletedStates[a] === null) for (const h in this.state[a]) c[h] = {}, this.state[a][h] = {};
            else for (const h in this.deletedStates[a]) {
              if (this.deletedStates[a][h] === null) this.state[a][h] = {};
              else if (this.state[a][h]) for (const p of Object.keys(this.deletedStates[a][h])) delete this.state[a][h][p];
              c[h] = this.state[a][h];
            }
            n[a] = n[a] || {}, si(n[a], c);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(n).length !== 0) for (const a in e) e[a].setFeatureState(n, i);
        }
      }
      class ym {
        constructor(e) {
          this.size = e, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(e, i) {
          const n = this.toIdx(e, i);
          return { min: this.minimums[n], max: this.maximums[n] };
        }
        isLeaf(e, i) {
          return this.leaves[this.toIdx(e, i)];
        }
        toIdx(e, i) {
          return i * this.size + e;
        }
      }
      function xm(t, e, i, n) {
        let a = 0, c = Number.MAX_VALUE;
        for (let h = 0; h < 3; h++) if (Math.abs(n[h]) < 1e-15) {
          if (i[h] < t[h] || i[h] > e[h]) return null;
        } else {
          const p = 1 / n[h];
          let m = (t[h] - i[h]) * p, _ = (e[h] - i[h]) * p;
          if (m > _) {
            const v = m;
            m = _, _ = v;
          }
          if (m > a && (a = m), _ < c && (c = _), a > c) return null;
        }
        return a;
      }
      function vm(t, e, i, n, a, c, h, p, m, _, v) {
        const w = n - t, T = a - e, C = c - i, A = h - t, z = p - e, U = m - i, q = v[1] * U - v[2] * z, ie = v[2] * A - v[0] * U, W = v[0] * z - v[1] * A, te = w * q + T * ie + C * W;
        if (Math.abs(te) < 1e-15) return null;
        const ae = 1 / te, oe = _[0] - t, Se = _[1] - e, we = _[2] - i, ke = (oe * q + Se * ie + we * W) * ae;
        if (ke < 0 || ke > 1) return null;
        const $e = Se * C - we * T, Ae = we * w - oe * C, Fe = oe * T - Se * w, Ue = (v[0] * $e + v[1] * Ae + v[2] * Fe) * ae;
        return Ue < 0 || ke + Ue > 1 ? null : (A * $e + z * Ae + U * Fe) * ae;
      }
      function bm(t, e, i) {
        return (t - e) / (i - e);
      }
      function wm(t, e, i, n, a, c, h, p, m) {
        const _ = 1 << i, v = c - n, w = h - a, T = (t + 1) / _ * v + n, C = (e + 0) / _ * w + a, A = (e + 1) / _ * w + a;
        p[0] = (t + 0) / _ * v + n, p[1] = C, m[0] = T, m[1] = A;
      }
      class Tm {
        constructor(e) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
          const i = function(c) {
            const h = Math.ceil(Math.log2(c.dim / 8)), p = [];
            let m = Math.ceil(Math.pow(2, h));
            const _ = 1 / m, v = (C, A, z, U, q) => {
              const ie = U ? 1 : 0, W = (C + 1) * z - ie, te = A * z, ae = (A + 1) * z - ie;
              q[0] = C * z, q[1] = te, q[2] = W, q[3] = ae;
            };
            let w = new ym(m);
            const T = [];
            for (let C = 0; C < m * m; C++) {
              v(C % m, Math.floor(C / m), _, !1, T);
              const A = Ta(T[0], T[1], c), z = Ta(T[2], T[1], c), U = Ta(T[2], T[3], c), q = Ta(T[0], T[3], c);
              w.minimums.push(Math.min(A, z, U, q)), w.maximums.push(Math.max(A, z, U, q)), w.leaves.push(1);
            }
            for (p.push(w), m /= 2; m >= 1; m /= 2) {
              const C = p[p.length - 1];
              w = new ym(m);
              for (let A = 0; A < m * m; A++) {
                v(A % m, Math.floor(A / m), 2, !0, T);
                const z = C.getElevation(T[0], T[1]), U = C.getElevation(T[2], T[1]), q = C.getElevation(T[2], T[3]), ie = C.getElevation(T[0], T[3]), W = C.isLeaf(T[0], T[1]), te = C.isLeaf(T[2], T[1]), ae = C.isLeaf(T[2], T[3]), oe = C.isLeaf(T[0], T[3]), Se = Math.min(z.min, U.min, q.min, ie.min), we = Math.max(z.max, U.max, q.max, ie.max), ke = W && te && ae && oe;
                w.maximums.push(we), w.minimums.push(Se), w.leaves.push(we - Se <= 5 && ke ? 1 : 0);
              }
              p.push(w);
            }
            return p;
          }(this.dem), n = i.length - 1, a = i[n];
          this._addNode(a.minimums[0], a.maximums[0], a.leaves[0]), this._construct(i, 0, 0, n, 0);
        }
        raycastRoot(e, i, n, a, c, h, p = 1) {
          return xm([e, i, -100], [n, a, this.maximums[0] * p], c, h);
        }
        raycast(e, i, n, a, c, h, p = 1) {
          if (!this.nodeCount) return null;
          const m = this.raycastRoot(e, i, n, a, c, h, p);
          if (m == null) return null;
          const _ = [], v = [], w = [], T = [], C = [{ idx: 0, t: m, nodex: 0, nodey: 0, depth: 0 }];
          for (; C.length > 0; ) {
            const { idx: A, t: z, nodex: U, nodey: q, depth: ie } = C.pop();
            if (this.leaves[A]) {
              wm(U, q, ie, e, i, n, a, w, T);
              const te = 1 << ie, ae = (U + 0) / te, oe = (U + 1) / te, Se = (q + 0) / te, we = (q + 1) / te, ke = Ta(ae, Se, this.dem) * p, $e = Ta(oe, Se, this.dem) * p, Ae = Ta(oe, we, this.dem) * p, Fe = Ta(ae, we, this.dem) * p, Ue = vm(w[0], w[1], ke, T[0], w[1], $e, T[0], T[1], Ae, c, h), je = vm(T[0], T[1], Ae, w[0], T[1], Fe, w[0], w[1], ke, c, h), Je = Math.min(Ue !== null ? Ue : Number.MAX_VALUE, je !== null ? je : Number.MAX_VALUE);
              if (Je !== Number.MAX_VALUE) return Je;
              {
                const Le = Oc([], c, h, z);
                if (Em(ke, $e, Fe, Ae, bm(Le[0], w[0], T[0]), bm(Le[1], w[1], T[1])) >= Le[2]) return z;
              }
              continue;
            }
            let W = 0;
            for (let te = 0; te < this._siblingOffset.length; te++) {
              wm((U << 1) + this._siblingOffset[te][0], (q << 1) + this._siblingOffset[te][1], ie + 1, e, i, n, a, w, T), w[2] = -100, T[2] = this.maximums[this.childOffsets[A] + te] * p;
              const ae = xm(w, T, c, h);
              if (ae != null) {
                const oe = ae;
                _[te] = oe;
                let Se = !1;
                for (let we = 0; we < W && !Se; we++) oe >= _[v[we]] && (v.splice(we, 0, te), Se = !0);
                Se || (v[W] = te), W++;
              }
            }
            for (let te = 0; te < W; te++) {
              const ae = v[te];
              C.push({ idx: this.childOffsets[A] + ae, t: _[ae], nodex: (U << 1) + this._siblingOffset[ae][0], nodey: (q << 1) + this._siblingOffset[ae][1], depth: ie + 1 });
            }
          }
          return null;
        }
        _addNode(e, i, n) {
          return this.minimums.push(e), this.maximums.push(i), this.leaves.push(n), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(e, i, n, a, c) {
          if (e[a].isLeaf(i, n) === 1) return;
          this.childOffsets[c] || (this.childOffsets[c] = this.nodeCount);
          const h = a - 1, p = e[h];
          let m = 0, _ = 0;
          for (let v = 0; v < this._siblingOffset.length; v++) {
            const w = 2 * i + this._siblingOffset[v][0], T = 2 * n + this._siblingOffset[v][1], C = p.getElevation(w, T), A = p.isLeaf(w, T), z = this._addNode(C.min, C.max, A);
            A && (m |= 1 << v), _ || (_ = z);
          }
          for (let v = 0; v < this._siblingOffset.length; v++) m & 1 << v || this._construct(e, 2 * i + this._siblingOffset[v][0], 2 * n + this._siblingOffset[v][1], h, _ + v);
        }
      }
      function Em(t, e, i, n, a, c) {
        return Kt(Kt(t, i, c), Kt(e, n, c), a);
      }
      function Ta(t, e, i) {
        const n = i.dim, a = Vt(t * n - 0.5, 0, n - 1), c = Vt(e * n - 0.5, 0, n - 1), h = Math.floor(a), p = Math.floor(c), m = Math.min(h + 1, n - 1), _ = Math.min(p + 1, n - 1);
        return Em(i.get(h, p), i.get(m, p), i.get(h, _), i.get(m, _), a - h, c - p);
      }
      const Sm = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      function dx(t, e, i) {
        return (256 * t * 256 + 256 * e + i) / 10 - 1e4;
      }
      function px(t, e, i) {
        return 256 * t + e + i / 256 - 32768;
      }
      class ph {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(e, i, n, a = !1, c = !1) {
          if (this.uid = e, i.height !== i.width) throw new RangeError("DEM tiles must be square");
          if (n && n !== "mapbox" && n !== "terrarium") return Ui(`"${n}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = i.height;
          const h = this.dim = i.height - 2, p = new Uint32Array(i.data.buffer);
          if (this.pixels = new Uint8Array(i.data.buffer), this.encoding = n || "mapbox", this.borderReady = a, !a) {
            for (let m = 0; m < h; m++) p[this._idx(-1, m)] = p[this._idx(0, m)], p[this._idx(h, m)] = p[this._idx(h - 1, m)], p[this._idx(m, -1)] = p[this._idx(m, 0)], p[this._idx(m, h)] = p[this._idx(m, h - 1)];
            p[this._idx(-1, -1)] = p[this._idx(0, 0)], p[this._idx(h, -1)] = p[this._idx(h - 1, 0)], p[this._idx(-1, h)] = p[this._idx(0, h - 1)], p[this._idx(h, h)] = p[this._idx(h - 1, h - 1)], c && this._buildQuadTree();
          }
        }
        _buildQuadTree() {
          this._tree = new Tm(this);
        }
        get(e, i, n = !1) {
          n && (e = Vt(e, -1, this.dim), i = Vt(i, -1, this.dim));
          const a = 4 * this._idx(e, i);
          return (this.encoding === "terrarium" ? px : dx)(this.pixels[a], this.pixels[a + 1], this.pixels[a + 2]);
        }
        static getUnpackVector(e) {
          return Sm[e];
        }
        get unpackVector() {
          return Sm[this.encoding];
        }
        _idx(e, i) {
          if (e < -1 || e >= this.dim + 1 || i < -1 || i >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (i + 1) * this.stride + (e + 1);
        }
        static pack(e, i) {
          const n = [0, 0, 0, 0], a = ph.getUnpackVector(i);
          let c = Math.floor((e + a[3]) / a[2]);
          return n[2] = c % 256, c = Math.floor(c / 256), n[1] = c % 256, c = Math.floor(c / 256), n[0] = c, n;
        }
        getPixels() {
          return new Rn({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(e, i, n) {
          if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
          let a = i * this.dim, c = i * this.dim + this.dim, h = n * this.dim, p = n * this.dim + this.dim;
          switch (i) {
            case -1:
              a = c - 1;
              break;
            case 1:
              c = a + 1;
          }
          switch (n) {
            case -1:
              h = p - 1;
              break;
            case 1:
              p = h + 1;
          }
          const m = -i * this.dim, _ = -n * this.dim;
          for (let v = h; v < p; v++) for (let w = a; w < c; w++) {
            const T = 4 * this._idx(w, v), C = 4 * this._idx(w + m, v + _);
            this.pixels[T + 0] = e.pixels[C + 0], this.pixels[T + 1] = e.pixels[C + 1], this.pixels[T + 2] = e.pixels[C + 2], this.pixels[T + 3] = e.pixels[C + 3];
          }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      _t(ph, "DEMData"), _t(Tm, "DemMinMaxQuadTree", { omit: ["dem"] });
      class fx {
        constructor(e, i) {
          this.max = e, this.onRemove = i, this.reset();
        }
        reset() {
          for (const e in this.data) for (const i of this.data[e]) i.timeout && clearTimeout(i.timeout), this.onRemove(i.value);
          return this.data = {}, this.order = [], this;
        }
        add(e, i, n) {
          const a = e.wrapped().key;
          this.data[a] === void 0 && (this.data[a] = []);
          const c = { value: i, timeout: void 0 };
          if (n !== void 0 && (c.timeout = setTimeout(() => {
            this.remove(e, c);
          }, n)), this.data[a].push(c), this.order.push(a), this.order.length > this.max) {
            const h = this._getAndRemoveByKey(this.order[0]);
            h && this.onRemove(h);
          }
          return this;
        }
        has(e) {
          return e.wrapped().key in this.data;
        }
        getAndRemove(e) {
          return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
        }
        _getAndRemoveByKey(e) {
          const i = this.data[e].shift();
          return i.timeout && clearTimeout(i.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), i.value;
        }
        getByKey(e) {
          const i = this.data[e];
          return i ? i[0].value : null;
        }
        get(e) {
          return this.has(e) ? this.data[e.wrapped().key][0].value : null;
        }
        remove(e, i) {
          if (!this.has(e)) return this;
          const n = e.wrapped().key, a = i === void 0 ? 0 : this.data[n].indexOf(i), c = this.data[n][a];
          return this.data[n].splice(a, 1), c.timeout && clearTimeout(c.timeout), this.data[n].length === 0 && delete this.data[n], this.onRemove(c.value), this.order.splice(this.order.indexOf(n), 1), this;
        }
        setMaxSize(e) {
          for (this.max = e; this.order.length > this.max; ) {
            const i = this._getAndRemoveByKey(this.order[0]);
            i && this.onRemove(i);
          }
          return this;
        }
        filter(e) {
          const i = [];
          for (const n in this.data) for (const a of this.data[n]) e(a.value) || i.push(a);
          for (const n of i) this.remove(n.value.tileID, n);
        }
      }
      class ic {
        constructor(e, i, n) {
          this.func = e, this.mask = i, this.range = n;
        }
      }
      ic.ReadOnly = !1, ic.ReadWrite = !0, ic.disabled = new ic(519, ic.ReadOnly, [0, 1]);
      const kd = 7680;
      class Dd {
        constructor(e, i, n, a, c, h) {
          this.test = e, this.ref = i, this.mask = n, this.fail = a, this.depthFail = c, this.pass = h;
        }
      }
      Dd.disabled = new Dd({ func: 519, mask: 0 }, 0, 0, kd, kd, kd);
      class vs {
        constructor(e, i, n) {
          this.blendFunction = e, this.blendColor = i, this.mask = n;
        }
      }
      vs.Replace = [1, 0], vs.disabled = new vs(vs.Replace, De.transparent, [!1, !1, !1, !1]), vs.unblended = new vs(vs.Replace, De.transparent, [!0, !0, !0, !0]), vs.alphaBlended = new vs([1, 771], De.transparent, [!0, !0, !0, !0]);
      const Rd = 1029, Od = 2305;
      class Ko {
        constructor(e, i, n) {
          this.enable = e, this.mode = i, this.frontFace = n;
        }
      }
      Ko.disabled = new Ko(!1, Rd, Od), Ko.backCCW = new Ko(!0, Rd, Od), Ko.backCW = new Ko(!0, Rd, 2304), Ko.frontCW = new Ko(!0, 1028, 2304), Ko.frontCCW = new Ko(!0, 1028, Od);
      class cl extends Fr {
        constructor(e, i, n) {
          super(), this.id = e, this._onlySymbols = n, i.on("data", (a) => {
            a.dataType === "source" && a.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && a.dataType === "source" && a.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform));
          }), i.on("error", () => {
            this._sourceErrored = !0;
          }), this._source = i, this._tiles = {}, this._cache = new fx(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = i.minTileCacheSize, this._maxTileCacheSize = i.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new hx(), this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "custom" && this._source._dataType === "raster";
        }
        onAdd(e) {
          this.map = e, this._minTileCacheSize = this._minTileCacheSize === void 0 && e ? e._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = this._maxTileCacheSize === void 0 && e ? e._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          for (const e in this._tiles) {
            const i = this._tiles[e];
            if (i.state !== "loaded" && i.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const e = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(e, i) {
          return e.isSymbolTile = this._onlySymbols, this._source.loadTile(e, i);
        }
        _unloadTile(e) {
          if (this._source.unloadTile) return this._source.unloadTile(e, () => {
          });
        }
        _abortTile(e) {
          if (this._source.abortTile) return this._source.abortTile(e, () => {
          });
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const i in this._tiles) {
            const n = this._tiles[i];
            n.upload(e), n.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Mn(this._tiles).map((e) => e.tileID).sort(Mm).map((e) => e.key);
        }
        getRenderableIds(e) {
          const i = [];
          for (const n in this._tiles) this._isIdRenderable(+n, e) && i.push(this._tiles[n]);
          return e ? i.sort((n, a) => {
            const c = n.tileID, h = a.tileID, p = new et(c.canonical.x, c.canonical.y)._rotate(this.transform.angle), m = new et(h.canonical.x, h.canonical.y)._rotate(this.transform.angle);
            return c.overscaledZ - h.overscaledZ || m.y - p.y || m.x - p.x;
          }).map((n) => n.tileID.key) : i.map((n) => n.tileID).sort(Mm).map((n) => n.key);
        }
        hasRenderableParent(e) {
          const i = this.findLoadedParent(e, 0);
          return !!i && this._isIdRenderable(i.tileID.key);
        }
        _isIdRenderable(e, i) {
          return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (i || !this._tiles[e].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const e in this._tiles) this._tiles[e].state !== "errored" && this._reloadTile(+e, "reloading");
          }
        }
        _reloadTile(e, i) {
          const n = this._tiles[e];
          n && (n.state !== "loading" && (n.state = i), this._loadTile(n, this._tileLoaded.bind(this, n, e, i)));
        }
        _tileLoaded(e, i, n, a) {
          if (a) if (e.state = "errored", a.status !== 404) this._source.fire(new wr(a, { tile: e }));
          else if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
            const c = this.map.painter.terrain;
            this.update(this.transform, c.getScaledDemTileSize(), !0), c.resetTileLookupCache(this.id);
          } else this.update(this.transform);
          else e.timeAdded = gn.now(), n === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), this._source.type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), this._source.fire(new uo("data", { dataType: "source", tile: e, coord: e.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(e) {
          const i = this.getRenderableIds();
          for (let a = 0; a < i.length; a++) {
            const c = i[a];
            if (e.neighboringTiles && e.neighboringTiles[c]) {
              const h = this.getTileByID(c);
              n(e, h), n(h, e);
            }
          }
          function n(a, c) {
            if (!a.dem || a.dem.borderReady) return;
            a.needsHillshadePrepare = !0, a.needsDEMTextureUpload = !0;
            let h = c.tileID.canonical.x - a.tileID.canonical.x;
            const p = c.tileID.canonical.y - a.tileID.canonical.y, m = Math.pow(2, a.tileID.canonical.z), _ = c.tileID.key;
            h === 0 && p === 0 || Math.abs(p) > 1 || (Math.abs(h) > 1 && (Math.abs(h + m) === 1 ? h += m : Math.abs(h - m) === 1 && (h -= m)), c.dem && a.dem && (a.dem.backfillBorder(c.dem, h, p), a.neighboringTiles && a.neighboringTiles[_] && (a.neighboringTiles[_].backfilled = !0)));
          }
        }
        getTile(e) {
          return this.getTileByID(e.key);
        }
        getTileByID(e) {
          return this._tiles[e];
        }
        _retainLoadedChildren(e, i, n, a) {
          for (const c in this._tiles) {
            let h = this._tiles[c];
            if (a[c] || !h.hasData() || h.tileID.overscaledZ <= i || h.tileID.overscaledZ > n) continue;
            let p = h.tileID;
            for (; h && h.tileID.overscaledZ > i + 1; ) {
              const _ = h.tileID.scaledTo(h.tileID.overscaledZ - 1);
              h = this._tiles[_.key], h && h.hasData() && (p = _);
            }
            let m = p;
            for (; m.overscaledZ > i; ) if (m = m.scaledTo(m.overscaledZ - 1), e[m.key]) {
              a[p.key] = p;
              break;
            }
          }
        }
        findLoadedParent(e, i) {
          if (e.key in this._loadedParentTiles) {
            const n = this._loadedParentTiles[e.key];
            return n && n.tileID.overscaledZ >= i ? n : null;
          }
          for (let n = e.overscaledZ - 1; n >= i; n--) {
            const a = e.scaledTo(n), c = this._getLoadedTile(a);
            if (c) return c;
          }
        }
        _getLoadedTile(e) {
          const i = this._tiles[e.key];
          return i && i.hasData() ? i : this._cache.getByKey(this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key);
        }
        updateCacheSize(e, i) {
          i = i || this._source.tileSize;
          const n = Math.ceil(e.width / i) + 1, a = Math.ceil(e.height / i) + 1, c = Math.floor(n * a * 5), h = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, c) : c, p = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, h) : h;
          this._cache.setMaxSize(p);
        }
        handleWrapJump(e) {
          const i = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
          if (this._prevLng = e, i) {
            const n = {};
            for (const a in this._tiles) {
              const c = this._tiles[a];
              c.tileID = c.tileID.unwrapTo(c.tileID.wrap + i), n[c.tileID.key] = c;
            }
            this._tiles = n;
            for (const a in this._timers) clearTimeout(this._timers[a]), delete this._timers[a];
            for (const a in this._tiles) this._setTileReloadTimer(+a, this._tiles[a]);
          }
        }
        update(e, i, n) {
          if (this.transform = e, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || this.usedForTerrain && !n) return;
          let a;
          this.updateCacheSize(e, i), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? a = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((p) => new dn(p.canonical.z, p.wrap, p.canonical.z, p.canonical.x, p.canonical.y)) : (a = e.coveringTiles({ tileSize: i || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !n, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (a = a.filter((p) => this._source.hasTile(p)))) : a = [];
          const c = this._updateRetainedTiles(a);
          if (Cm(this._source.type) && a.length !== 0) {
            const p = {}, m = {}, _ = Object.keys(c);
            for (const w of _) {
              const T = c[w], C = this._tiles[w];
              if (!C || C.fadeEndTime && C.fadeEndTime <= gn.now()) continue;
              const A = this.findLoadedParent(T, Math.max(T.overscaledZ - cl.maxOverzooming, this._source.minzoom));
              A && (this._addTile(A.tileID), p[A.tileID.key] = A.tileID), m[w] = T;
            }
            const v = a[a.length - 1].overscaledZ;
            for (const w in this._tiles) {
              const T = this._tiles[w];
              if (c[w] || !T.hasData()) continue;
              let C = T.tileID;
              for (; C.overscaledZ > v; ) {
                C = C.scaledTo(C.overscaledZ - 1);
                const A = this._tiles[C.key];
                if (A && A.hasData() && m[C.key]) {
                  c[w] = T.tileID;
                  break;
                }
              }
            }
            for (const w in p) c[w] || (this._coveredTiles[w] = !0, c[w] = p[w]);
          }
          for (const p in c) this._tiles[p].clearFadeHold();
          const h = function(p, m) {
            const _ = [];
            for (const v in p) v in m || _.push(v);
            return _;
          }(this._tiles, c);
          for (const p of h) {
            const m = this._tiles[p];
            m.hasSymbolBuckets && !m.holdingForFade() ? m.setHoldDuration(this.map._fadeDuration) : m.hasSymbolBuckets && !m.symbolFadeFinished() || this._removeTile(+p);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(+e);
        }
        _updateRetainedTiles(e) {
          const i = {};
          if (e.length === 0) return i;
          const n = {}, a = e.reduce((_, v) => Math.min(_, v.overscaledZ), 1 / 0), c = e[0].overscaledZ, h = Math.max(c - cl.maxOverzooming, this._source.minzoom), p = Math.max(c + cl.maxUnderzooming, this._source.minzoom), m = {};
          for (const _ of e) {
            const v = this._addTile(_);
            i[_.key] = _, v.hasData() || a < this._source.maxzoom && (m[_.key] = _);
          }
          this._retainLoadedChildren(m, a, p, i);
          for (const _ of e) {
            let v = this._tiles[_.key];
            if (v.hasData()) continue;
            if (_.canonical.z >= this._source.maxzoom) {
              const T = _.children(this._source.maxzoom)[0], C = this.getTile(T);
              if (C && C.hasData()) {
                i[T.key] = T;
                continue;
              }
            } else {
              const T = _.children(this._source.maxzoom);
              if (i[T[0].key] && i[T[1].key] && i[T[2].key] && i[T[3].key]) continue;
            }
            let w = v.wasRequested();
            for (let T = _.overscaledZ - 1; T >= h; --T) {
              const C = _.scaledTo(T);
              if (n[C.key] || (n[C.key] = !0, v = this.getTile(C), !v && w && (v = this._addTile(C)), v && (i[C.key] = C, w = v.wasRequested(), v.hasData()))) break;
            }
          }
          return i;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const e in this._tiles) {
            const i = [];
            let n, a = this._tiles[e].tileID;
            for (; a.overscaledZ > 0; ) {
              if (a.key in this._loadedParentTiles) {
                n = this._loadedParentTiles[a.key];
                break;
              }
              i.push(a.key);
              const c = a.scaledTo(a.overscaledZ - 1);
              if (n = this._getLoadedTile(c), n) break;
              a = c;
            }
            for (const c of i) this._loadedParentTiles[c] = n;
          }
        }
        _addTile(e) {
          let i = this._tiles[e.key];
          if (i) return i;
          i = this._cache.getAndRemove(e), i && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i)));
          const n = !!i;
          if (!n) {
            const a = this.map ? this.map.painter : null;
            i = new zd(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, a, this._isRaster), this._loadTile(i, this._tileLoaded.bind(this, i, e.key, i.state));
          }
          return i ? (i.uses++, this._tiles[e.key] = i, n || this._source.fire(new uo("dataloading", { tile: i, coord: i.tileID, dataType: "source" })), i) : null;
        }
        _setTileReloadTimer(e, i) {
          e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
          const n = i.getExpiryTimeout();
          n && (this._timers[e] = setTimeout(() => {
            this._reloadTile(e, "expired"), delete this._timers[e];
          }, n));
        }
        _removeTile(e) {
          const i = this._tiles[e];
          i && (i.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), i.uses > 0 || (i.hasData() && i.state !== "reloading" ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0, this._abortTile(i), this._unloadTile(i))));
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const e in this._tiles) this._removeTile(+e);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(e, i, n) {
          const a = [], c = this.transform;
          if (!c) return a;
          const h = c.projection.name === "globe", p = _s(c.center.lng);
          for (const m in this._tiles) {
            const _ = this._tiles[m];
            if (n && _.clearQueryDebugViz(), _.holdingForFade()) continue;
            let v;
            if (h) {
              const w = _.tileID.canonical;
              if (w.z === 0) {
                const T = [Math.abs(Vt(p, ...au(w, -1)) - p), Math.abs(Vt(p, ...au(w, 1)) - p)];
                v = [0, 2 * T.indexOf(Math.min(...T)) - 1];
              } else {
                const T = [Math.abs(Vt(p, ...au(w, -1)) - p), Math.abs(Vt(p, ...au(w, 0)) - p), Math.abs(Vt(p, ...au(w, 1)) - p)];
                v = [T.indexOf(Math.min(...T)) - 1];
              }
            } else v = [0];
            for (const w of v) {
              const T = e.containsTile(_, c, i, w);
              T && a.push(T);
            }
          }
          return a;
        }
        getVisibleCoordinates(e) {
          const i = this.getRenderableIds(e).map((n) => this._tiles[n].tileID);
          for (const n of i) n.projMatrix = this.transform.calculateProjMatrix(n.toUnwrapped());
          return i;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Cm(this._source.type)) for (const e in this._tiles) {
            const i = this._tiles[e];
            if (i.fadeEndTime !== void 0 && i.fadeEndTime >= gn.now()) return !0;
          }
          return !1;
        }
        setFeatureState(e, i, n) {
          this._state.updateState(e = e || "_geojsonTileLayer", i, n);
        }
        removeFeatureState(e, i, n) {
          this._state.removeFeatureState(e = e || "_geojsonTileLayer", i, n);
        }
        getFeatureState(e, i) {
          return this._state.getState(e = e || "_geojsonTileLayer", i);
        }
        setDependencies(e, i, n) {
          const a = this._tiles[e];
          a && a.setDependencies(i, n);
        }
        reloadTilesForDependencies(e, i) {
          for (const n in this._tiles) this._tiles[n].hasDependency(e, i) && this._reloadTile(+n, "reloading");
          this._cache.filter((n) => !n.hasDependency(e, i));
        }
        _preloadTiles(e, i) {
          if (!this._sourceLoaded) {
            const p = () => {
              this._sourceLoaded && (this._source.off("data", p), this._preloadTiles(e, i));
            };
            return void this._source.on("data", p);
          }
          const n = /* @__PURE__ */ new Map(), a = Array.isArray(e) ? e : [e], c = this.map.painter.terrain, h = this.usedForTerrain && c ? c.getScaledDemTileSize() : this._source.tileSize;
          for (const p of a) {
            const m = p.coveringTiles({ tileSize: h, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const _ of m) n.set(_.key, _);
            this.usedForTerrain && p.updateElevation(!1);
          }
          er(Array.from(n.values()), (p, m) => {
            const _ = new zd(p, this._source.tileSize * p.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(_, (v) => {
              this._source.type === "raster-dem" && _.dem && this._backfillDEM(_), m(v, _);
            });
          }, i);
        }
      }
      function Mm(t, e) {
        const i = Math.abs(2 * t.wrap) - +(t.wrap < 0), n = Math.abs(2 * e.wrap) - +(e.wrap < 0);
        return t.overscaledZ - e.overscaledZ || n - i || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;
      }
      function Cm(t) {
        return t === "raster" || t === "image" || t === "video" || t === "custom";
      }
      function au(t, e) {
        const i = 1 << t.z;
        return [t.x / i + e, (t.x + 1) / i + e];
      }
      cl.maxOverzooming = 10, cl.maxUnderzooming = 3;
      class fh {
        constructor(e, i, n) {
          this._demTile = e, this._dem = this._demTile.dem, this._scale = i, this._offset = n;
        }
        static create(e, i, n) {
          const a = n || e.findDEMTileFor(i);
          if (!a || !a.dem) return;
          const c = a.dem, h = a.tileID, p = 1 << i.canonical.z - h.canonical.z;
          return new fh(a, a.tileSize / Et / p, [(i.canonical.x / p - h.canonical.x) * c.dim, (i.canonical.y / p - h.canonical.y) * c.dim]);
        }
        tileCoordToPixel(e, i) {
          const n = i * this._scale + this._offset[1], a = Math.floor(e * this._scale + this._offset[0]), c = Math.floor(n);
          return new et(a, c);
        }
        getElevationAt(e, i, n, a) {
          const c = e * this._scale + this._offset[0], h = i * this._scale + this._offset[1], p = Math.floor(c), m = Math.floor(h), _ = this._dem;
          return a = !!a, n ? Kt(Kt(_.get(p, m, a), _.get(p, m + 1, a), h - m), Kt(_.get(p + 1, m, a), _.get(p + 1, m + 1, a), h - m), c - p) : _.get(p, m, a);
        }
        getElevationAtPixel(e, i, n) {
          return this._dem.get(e, i, !!n);
        }
        getMeterToDEM(e) {
          return (1 << this._demTile.tileID.canonical.z) * Wo(1, e) * this._dem.stride;
        }
      }
      class Am {
        constructor(e, i) {
          this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Bs(Et, 16, 0), this.featureIndexArray = new Ja(), this.promoteId = i;
        }
        insert(e, i, n, a, c, h = 0) {
          const p = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(n, a, c, h);
          const m = this.grid;
          for (let _ = 0; _ < i.length; _++) {
            const v = i[_], w = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let T = 0; T < v.length; T++) {
              const C = v[T];
              w[0] = Math.min(w[0], C.x), w[1] = Math.min(w[1], C.y), w[2] = Math.max(w[2], C.x), w[3] = Math.max(w[3], C.y);
            }
            w[0] < Et && w[1] < Et && w[2] >= 0 && w[3] >= 0 && m.insert(p, w[0], w[1], w[2], w[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new _d(new eh(this.rawTileData)).layers, this.sourceLayerCoder = new pm(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const e in this.vtLayers) this.vtFeatures[e] = [];
          }
          return this.vtLayers;
        }
        query(e, i, n, a) {
          this.loadVTLayers();
          const c = e.params || {}, h = Ll(c.filter), p = e.tileResult, m = e.transform, _ = p.bufferedTilespaceBounds, v = this.grid.query(_.min.x, _.min.y, _.max.x, _.max.y, (A, z, U, q) => Yp(p.bufferedTilespaceGeometry, A, z, U, q));
          v.sort(mx);
          let w = null;
          m.elevation && v.length > 0 && (w = fh.create(m.elevation, this.tileID));
          const T = {};
          let C;
          for (let A = 0; A < v.length; A++) {
            const z = v[A];
            if (z === C) continue;
            C = z;
            const U = this.featureIndexArray.get(z);
            let q = null;
            this.loadMatchingFeature(T, U, h, c.layers, c.availableImages, i, n, a, (ie, W, te, ae = 0) => (q || (q = $s(ie, this.tileID.canonical, e.tileTransform)), W.queryIntersectsFeature(p, ie, te, q, this.z, e.transform, e.pixelPosMatrix, w, ae)));
          }
          return T;
        }
        loadMatchingFeature(e, i, n, a, c, h, p, m, _) {
          const { featureIndex: v, bucketIndex: w, sourceLayerIndex: T, layoutVertexArrayOffset: C } = i, A = this.bucketLayerIDs[w];
          if (a && !function(ie, W) {
            for (let te = 0; te < ie.length; te++) if (W.indexOf(ie[te]) >= 0) return !0;
            return !1;
          }(a, A)) return;
          const z = this.sourceLayerCoder.decode(T), U = this.vtLayers[z].feature(v);
          if (n.needGeometry) {
            const ie = ol(U, !0);
            if (!n.filter(new b(this.tileID.overscaledZ), ie, this.tileID.canonical)) return;
          } else if (!n.filter(new b(this.tileID.overscaledZ), U)) return;
          const q = this.getId(U, z);
          for (let ie = 0; ie < A.length; ie++) {
            const W = A[ie];
            if (a && a.indexOf(W) < 0) continue;
            const te = h[W];
            if (!te) continue;
            let ae = {};
            q !== void 0 && m && (ae = m.getState(te.sourceLayer || "_geojsonTileLayer", q));
            const oe = si({}, p[W]);
            oe.paint = Im(oe.paint, te.paint, U, ae, c), oe.layout = Im(oe.layout, te.layout, U, ae, c);
            const Se = !_ || _(U, te, ae, C);
            if (!Se) continue;
            const we = new fm(U, this.z, this.x, this.y, q);
            we.layer = oe;
            let ke = e[W];
            ke === void 0 && (ke = e[W] = []), ke.push({ featureIndex: v, feature: we, intersectionZ: Se });
          }
        }
        lookupSymbolFeatures(e, i, n, a, c, h, p, m) {
          const _ = {};
          this.loadVTLayers();
          const v = Ll(c);
          for (const w of e) this.loadMatchingFeature(_, { bucketIndex: n, sourceLayerIndex: a, featureIndex: w, layoutVertexArrayOffset: 0 }, v, h, p, m, i);
          return _;
        }
        loadFeature(e) {
          const { featureIndex: i, sourceLayerIndex: n } = e;
          this.loadVTLayers();
          const a = this.sourceLayerCoder.decode(n), c = this.vtFeatures[a];
          if (c[i]) return c[i];
          const h = this.vtLayers[a].feature(i);
          return c[i] = h, h;
        }
        hasLayer(e) {
          for (const i of this.bucketLayerIDs) for (const n of i) if (e === n) return !0;
          return !1;
        }
        getId(e, i) {
          let n = e.id;
          if (this.promoteId) {
            const a = typeof this.promoteId == "string" ? this.promoteId : this.promoteId[i];
            a != null && (n = e.properties[a]), typeof n == "boolean" && (n = Number(n));
          }
          return n;
        }
      }
      function Im(t, e, i, n, a) {
        return ei(t, (c, h) => {
          const p = e instanceof Z ? e.get(h) : null;
          return p && p.evaluate ? p.evaluate(i, n, a) : p;
        });
      }
      function mx(t, e) {
        return e - t;
      }
      _t(Am, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
      class Pm {
        constructor(e, i) {
          this.width = e, this.height = i, this.nextRow = 0, this.image = new Zs({ width: e, height: i }), this.positions = {}, this.uploaded = !1;
        }
        getDash(e, i) {
          const n = this.getKey(e, i);
          return this.positions[n];
        }
        trim() {
          const e = this.width, i = this.height = Un(this.nextRow);
          this.image.resize({ width: e, height: i });
        }
        getKey(e, i) {
          return e.join(",") + i;
        }
        getDashRanges(e, i, n) {
          const a = [];
          let c = e.length % 2 == 1 ? -e[e.length - 1] * n : 0, h = e[0] * n, p = !0;
          a.push({ left: c, right: h, isDash: p, zeroLength: e[0] === 0 });
          let m = e[0];
          for (let _ = 1; _ < e.length; _++) {
            p = !p;
            const v = e[_];
            c = m * n, m += v, h = m * n, a.push({ left: c, right: h, isDash: p, zeroLength: v === 0 });
          }
          return a;
        }
        addRoundDash(e, i, n) {
          const a = i / 2;
          for (let c = -n; c <= n; c++) {
            const h = this.width * (this.nextRow + n + c);
            let p = 0, m = e[p];
            for (let _ = 0; _ < this.width; _++) {
              _ / m.right > 1 && (m = e[++p]);
              const v = Math.abs(_ - m.left), w = Math.abs(_ - m.right), T = Math.min(v, w);
              let C;
              const A = c / n * (a + 1);
              if (m.isDash) {
                const z = a - Math.abs(A);
                C = Math.sqrt(T * T + z * z);
              } else C = a - Math.sqrt(T * T + A * A);
              this.image.data[h + _] = Math.max(0, Math.min(255, C + 128));
            }
          }
        }
        addRegularDash(e, i) {
          for (let m = e.length - 1; m >= 0; --m) {
            const _ = e[m], v = e[m + 1];
            _.zeroLength ? e.splice(m, 1) : v && v.isDash === _.isDash && (v.left = _.left, e.splice(m, 1));
          }
          const n = e[0], a = e[e.length - 1];
          n.isDash === a.isDash && (n.left = a.left - this.width, a.right = n.right + this.width);
          const c = this.width * this.nextRow;
          let h = 0, p = e[h];
          for (let m = 0; m < this.width; m++) {
            m / p.right > 1 && (p = e[++h]);
            const _ = Math.abs(m - p.left), v = Math.abs(m - p.right), w = Math.min(_, v);
            this.image.data[c + m] = Math.max(0, Math.min(255, (p.isDash ? w : -w) + i + 128));
          }
        }
        addDash(e, i) {
          const n = this.getKey(e, i);
          if (this.positions[n]) return this.positions[n];
          const a = i === "round", c = a ? 7 : 0, h = 2 * c + 1;
          if (this.nextRow + h > this.height) return Ui("LineAtlas out of space"), null;
          e.length === 0 && e.push(1);
          let p = 0;
          for (let v = 0; v < e.length; v++) e[v] < 0 && (Ui("Negative value is found in line dasharray, replacing values with 0"), e[v] = 0), p += e[v];
          if (p !== 0) {
            const v = this.width / p, w = this.getDashRanges(e, this.width, v);
            a ? this.addRoundDash(w, v, c) : this.addRegularDash(w, i === "square" ? 0.5 * v : 0);
          }
          const m = this.nextRow + c;
          this.nextRow += h;
          const _ = { tl: [m, c], br: [p, 0] };
          return this.positions[n] = _, _;
        }
      }
      _t(Pm, "LineAtlas");
      const Lm = 1 * Ho;
      class zm {
        constructor(e) {
          const i = {}, n = [];
          for (const p in e) {
            const m = e[p], _ = i[p] = {};
            for (const v in m.glyphs) {
              const w = m.glyphs[+v];
              if (!w || w.bitmap.width === 0 || w.bitmap.height === 0) continue;
              const T = w.metrics.localGlyph ? Lm : 1, C = { x: 0, y: 0, w: w.bitmap.width + 2 * T, h: w.bitmap.height + 2 * T };
              n.push(C), _[v] = C;
            }
          }
          const { w: a, h: c } = vd(n), h = new Zs({ width: a || 1, height: c || 1 });
          for (const p in e) {
            const m = e[p];
            for (const _ in m.glyphs) {
              const v = m.glyphs[+_];
              if (!v || v.bitmap.width === 0 || v.bitmap.height === 0) continue;
              const w = i[p][_], T = v.metrics.localGlyph ? Lm : 1;
              Zs.copy(v.bitmap, h, { x: 0, y: 0 }, { x: w.x + T, y: w.y + T }, v.bitmap);
            }
          }
          this.image = h, this.positions = i;
        }
      }
      _t(zm, "GlyphAtlas");
      class _x {
        constructor(e) {
          this.tileID = new dn(e.tileID.overscaledZ, e.tileID.wrap, e.tileID.canonical.z, e.tileID.canonical.x, e.tileID.canonical.y), this.tileZoom = e.tileZoom, this.uid = e.uid, this.zoom = e.zoom, this.canonical = e.tileID.canonical, this.pixelRatio = e.pixelRatio, this.tileSize = e.tileSize, this.source = e.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = e.showCollisionBoxes, this.collectResourceTiming = !!e.collectResourceTiming, this.returnDependencies = !!e.returnDependencies, this.promoteId = e.promoteId, this.enableTerrain = !!e.enableTerrain, this.isSymbolTile = e.isSymbolTile, this.tileTransform = ll(e.tileID.canonical, e.projection), this.projection = e.projection;
        }
        parse(e, i, n, a, c) {
          this.status = "parsing", this.data = e, this.collisionBoxArray = new Mi();
          const h = new pm(Object.keys(e.layers).sort()), p = new Am(this.tileID, this.promoteId);
          p.bucketLayerIDs = [];
          const m = {}, _ = new Pm(256, 256), v = { featureIndex: p, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: _, availableImages: n }, w = i.familiesBySource[this.source];
          for (const ae in w) {
            const oe = e.layers[ae];
            if (!oe) continue;
            let Se = !1, we = !1;
            for (const Ae of w[ae]) Ae[0].type === "symbol" ? Se = !0 : we = !0;
            if (this.isSymbolTile === !0 && !Se || this.isSymbolTile === !1 && !we) continue;
            oe.version === 1 && Ui(`Vector tile source "${this.source}" layer "${ae}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const ke = h.encode(ae), $e = [];
            for (let Ae = 0; Ae < oe.length; Ae++) {
              const Fe = oe.feature(Ae), Ue = p.getId(Fe, ae);
              $e.push({ feature: Fe, id: Ue, index: Ae, sourceLayerIndex: ke });
            }
            for (const Ae of w[ae]) {
              const Fe = Ae[0];
              this.isSymbolTile !== void 0 && Fe.type === "symbol" !== this.isSymbolTile || Fe.minzoom && this.zoom < Math.floor(Fe.minzoom) || Fe.maxzoom && this.zoom >= Fe.maxzoom || Fe.visibility !== "none" && (Bd(Ae, this.zoom, n), (m[Fe.id] = Fe.createBucket({ index: p.bucketLayerIDs.length, layers: Ae, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: ke, sourceID: this.source, enableTerrain: this.enableTerrain, projection: this.projection.spec, availableImages: n })).populate($e, v, this.tileID.canonical, this.tileTransform), p.bucketLayerIDs.push(Ae.map((Ue) => Ue.id)));
            }
          }
          let T, C, A, z;
          _.trim();
          const U = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, q = () => {
            if (T) return c(T);
            if (C && A && z) {
              const ae = new zm(C), oe = new Uf(A, z);
              for (const Se in m) {
                const we = m[Se];
                we instanceof va ? (Bd(we.layers, this.zoom, n), Vy(we, C, ae.positions, A, oe.iconPositions, this.showCollisionBoxes, n, this.tileID.canonical, this.tileZoom, this.projection)) : we.hasPattern && (we instanceof Ju || we instanceof qu || we instanceof Hc) && (Bd(we.layers, this.zoom, n), we.addFeatures(v, this.tileID.canonical, oe.patternPositions, n, this.tileTransform));
              }
              this.status = "done", c(null, { buckets: Mn(m).filter((Se) => !Se.isEmpty()), featureIndex: p, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: ae.image, lineAtlas: _, imageAtlas: oe, glyphMap: this.returnDependencies ? C : null, iconMap: this.returnDependencies ? A : null, glyphPositions: this.returnDependencies ? ae.positions : null });
            }
          }, ie = ei(v.glyphDependencies, (ae) => Object.keys(ae).map(Number));
          Object.keys(ie).length ? a.send("getGlyphs", { uid: this.uid, stacks: ie }, (ae, oe) => {
            T || (T = ae, C = oe, q());
          }, void 0, !1, U) : C = {};
          const W = Object.keys(v.iconDependencies);
          W.length ? a.send("getImages", { icons: W, source: this.source, tileID: this.tileID, type: "icons" }, (ae, oe) => {
            T || (T = ae, A = oe, q());
          }, void 0, !1, U) : A = {};
          const te = Object.keys(v.patternDependencies);
          te.length ? a.send("getImages", { icons: te, source: this.source, tileID: this.tileID, type: "patterns" }, (ae, oe) => {
            T || (T = ae, z = oe, q());
          }, void 0, !1, U) : z = {}, q();
        }
      }
      function Bd(t, e, i) {
        const n = new b(e);
        for (const a of t) a.recalculate(n, i);
      }
      class km {
        constructor(e) {
          this.entries = {}, this.scheduler = e;
        }
        request(e, i, n, a) {
          const c = this.entries[e] = this.entries[e] || { callbacks: [] };
          if (c.result) {
            const [h, p] = c.result;
            return this.scheduler ? this.scheduler.add(() => {
              a(h, p);
            }, i) : a(h, p), () => {
            };
          }
          return c.callbacks.push(a), c.cancel || (c.cancel = n((h, p) => {
            c.result = [h, p];
            for (const m of c.callbacks) this.scheduler ? this.scheduler.add(() => {
              m(h, p);
            }, i) : m(h, p);
            setTimeout(() => delete this.entries[e], 3e3);
          })), () => {
            c.result || (c.callbacks = c.callbacks.filter((h) => h !== a), c.callbacks.length || (c.cancel(), delete this.entries[e]));
          };
        }
      }
      function Dm(t, e, i) {
        const n = JSON.stringify(t.request);
        return t.data && (this.deduped.entries[n] = { result: [null, t.data] }), this.deduped.request(n, { type: "parseTile", isSymbolTile: t.isSymbolTile, zoom: t.tileZoom }, (a) => {
          const c = es(t.request, (h, p, m, _) => {
            h ? a(h) : p && a(null, { vectorTile: i ? void 0 : new _d(new eh(p)), rawData: p, cacheControl: m, expires: _ });
          });
          return () => {
            c.cancel(), a();
          };
        }, e);
      }
      const Rm = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class Fd {
        static from(e) {
          if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [i, n] = new Uint8Array(e, 0, 2);
          if (i !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const a = n >> 4;
          if (a !== 1) throw new Error(`Got v${a} data when expected v1.`);
          const c = Rm[15 & n];
          if (!c) throw new Error("Unrecognized array type.");
          const [h] = new Uint16Array(e, 2, 1), [p] = new Uint32Array(e, 4, 1);
          return new Fd(p, h, c, e);
        }
        constructor(e, i = 64, n = Float64Array, a) {
          if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
          this.numItems = +e, this.nodeSize = Math.min(Math.max(+i, 2), 65535), this.ArrayType = n, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
          const c = Rm.indexOf(this.ArrayType), h = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, p = e * this.IndexArrayType.BYTES_PER_ELEMENT, m = (8 - p % 8) % 8;
          if (c < 0) throw new Error(`Unexpected typed array class: ${n}.`);
          a && a instanceof ArrayBuffer ? (this.data = a, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + p + m, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + h + p + m), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + p + m, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + c]), new Uint16Array(this.data, 2, 1)[0] = i, new Uint32Array(this.data, 4, 1)[0] = e);
        }
        add(e, i) {
          const n = this._pos >> 1;
          return this.ids[n] = n, this.coords[this._pos++] = e, this.coords[this._pos++] = i, n;
        }
        finish() {
          const e = this._pos >> 1;
          if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
          return Ud(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(e, i, n, a) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: c, coords: h, nodeSize: p } = this, m = [0, c.length - 1, 0], _ = [];
          for (; m.length; ) {
            const v = m.pop() || 0, w = m.pop() || 0, T = m.pop() || 0;
            if (w - T <= p) {
              for (let U = T; U <= w; U++) {
                const q = h[2 * U], ie = h[2 * U + 1];
                q >= e && q <= n && ie >= i && ie <= a && _.push(c[U]);
              }
              continue;
            }
            const C = T + w >> 1, A = h[2 * C], z = h[2 * C + 1];
            A >= e && A <= n && z >= i && z <= a && _.push(c[C]), (v === 0 ? e <= A : i <= z) && (m.push(T), m.push(C - 1), m.push(1 - v)), (v === 0 ? n >= A : a >= z) && (m.push(C + 1), m.push(w), m.push(1 - v));
          }
          return _;
        }
        within(e, i, n) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: a, coords: c, nodeSize: h } = this, p = [0, a.length - 1, 0], m = [], _ = n * n;
          for (; p.length; ) {
            const v = p.pop() || 0, w = p.pop() || 0, T = p.pop() || 0;
            if (w - T <= h) {
              for (let U = T; U <= w; U++) Bm(c[2 * U], c[2 * U + 1], e, i) <= _ && m.push(a[U]);
              continue;
            }
            const C = T + w >> 1, A = c[2 * C], z = c[2 * C + 1];
            Bm(A, z, e, i) <= _ && m.push(a[C]), (v === 0 ? e - n <= A : i - n <= z) && (p.push(T), p.push(C - 1), p.push(1 - v)), (v === 0 ? e + n >= A : i + n >= z) && (p.push(C + 1), p.push(w), p.push(1 - v));
          }
          return m;
        }
      }
      function Ud(t, e, i, n, a, c) {
        if (a - n <= i) return;
        const h = n + a >> 1;
        Om(t, e, h, n, a, c), Ud(t, e, i, n, h - 1, 1 - c), Ud(t, e, i, h + 1, a, 1 - c);
      }
      function Om(t, e, i, n, a, c) {
        for (; a > n; ) {
          if (a - n > 600) {
            const _ = a - n + 1, v = i - n + 1, w = Math.log(_), T = 0.5 * Math.exp(2 * w / 3), C = 0.5 * Math.sqrt(w * T * (_ - T) / _) * (v - _ / 2 < 0 ? -1 : 1);
            Om(t, e, i, Math.max(n, Math.floor(i - v * T / _ + C)), Math.min(a, Math.floor(i + (_ - v) * T / _ + C)), c);
          }
          const h = e[2 * i + c];
          let p = n, m = a;
          for (lu(t, e, n, i), e[2 * a + c] > h && lu(t, e, n, a); p < m; ) {
            for (lu(t, e, p, m), p++, m--; e[2 * p + c] < h; ) p++;
            for (; e[2 * m + c] > h; ) m--;
          }
          e[2 * n + c] === h ? lu(t, e, n, m) : (m++, lu(t, e, m, a)), m <= i && (n = m + 1), i <= m && (a = m - 1);
        }
      }
      function lu(t, e, i, n) {
        Nd(t, i, n), Nd(e, 2 * i, 2 * n), Nd(e, 2 * i + 1, 2 * n + 1);
      }
      function Nd(t, e, i) {
        const n = t[e];
        t[e] = t[i], t[i] = n;
      }
      function Bm(t, e, i, n) {
        const a = t - i, c = e - n;
        return a * a + c * c;
      }
      s.ARRAY_TYPE = Dn, s.AUTH_ERR_MSG = se, s.Aabb = hn, s.Actor = class {
        constructor(t, e, i) {
          this.target = t, this.parent = e, this.mapId = i, this.callbacks = {}, this.cancelCallbacks = {}, tr(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.globalScope = jn() ? t : re, this.scheduler = new cx();
        }
        send(t, e, i, n, a = !1, c) {
          const h = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          i && (i.metadata = c, this.callbacks[h] = i);
          const p = Qo(this.globalScope) ? void 0 : [];
          return this.target.postMessage({ id: h, type: t, hasCallback: !!i, targetMapId: n, mustQueue: a, sourceMapId: this.mapId, data: da(e, p) }, p), { cancel: () => {
            i && delete this.callbacks[h], this.target.postMessage({ id: h, type: "<cancel>", targetMapId: n, sourceMapId: this.mapId });
          } };
        }
        receive(t) {
          const e = t.data, i = e.id;
          if (i && (!e.targetMapId || this.mapId === e.targetMapId)) if (e.type === "<cancel>") {
            const n = this.cancelCallbacks[i];
            delete this.cancelCallbacks[i], n && n.cancel();
          } else if (e.mustQueue || jn()) {
            const n = this.callbacks[i];
            this.cancelCallbacks[i] = this.scheduler.add(() => this.processTask(i, e), n && n.metadata || { type: "message" });
          } else this.processTask(i, e);
        }
        processTask(t, e) {
          if (e.type === "<response>") {
            const i = this.callbacks[t];
            delete this.callbacks[t], i && (e.error ? i(Fs(e.error)) : i(null, Fs(e.data)));
          } else {
            const i = Qo(this.globalScope) ? void 0 : [], n = e.hasCallback ? (c, h) => {
              delete this.cancelCallbacks[t], this.target.postMessage({ id: t, type: "<response>", sourceMapId: this.mapId, error: c ? da(c) : null, data: da(h, i) }, i);
            } : (c) => {
            }, a = Fs(e.data);
            if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, a, n);
            else if (this.parent.getWorkerSource) {
              const c = e.type.split(".");
              this.parent.getWorkerSource(e.sourceMapId, c[0], a.source)[c[1]](a, n);
            } else n(new Error(`Could not find function ${e.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
        }
      }, s.CanonicalTileID = Ku, s.Color = De, s.ColorMode = vs, s.CullFaceMode = Ko, s.DEMData = ph, s.DataConstantProperty = L, s.DedupedRequest = km, s.DepthMode = ic, s.EXTENT = Et, s.Elevation = class {
        isDataAvailableAtPoint(t) {
          const e = this._source();
          if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1) return !1;
          const i = e.getSource().maxzoom, n = 1 << i, a = Math.floor(t.x), c = Math.floor((t.x - a) * n), h = Math.floor(t.y * n), p = this.findDEMTileFor(new dn(i, a, i, c, h));
          return !(!p || !p.dem);
        }
        getAtPointOrZero(t, e = 0) {
          return this.getAtPoint(t, e) || 0;
        }
        getAtPoint(t, e, i = !0) {
          if (this.isUsingMockSource()) return null;
          e == null && (e = null);
          const n = this._source();
          if (!n || t.y < 0 || t.y > 1) return e;
          const a = n.getSource().maxzoom, c = 1 << a, h = Math.floor(t.x), p = t.x - h, m = new dn(a, h, a, Math.floor(p * c), Math.floor(t.y * c)), _ = this.findDEMTileFor(m);
          if (!_ || !_.dem) return e;
          const v = _.dem, w = 1 << _.tileID.canonical.z, T = (p * w - _.tileID.canonical.x) * v.dim, C = (t.y * w - _.tileID.canonical.y) * v.dim, A = Math.floor(T), z = Math.floor(C);
          return (i ? this.exaggeration() : 1) * Kt(Kt(v.get(A, z), v.get(A, z + 1), C - z), Kt(v.get(A + 1, z), v.get(A + 1, z + 1), C - z), T - A);
        }
        getAtTileOffset(t, e, i) {
          const n = 1 << t.canonical.z;
          return this.getAtPointOrZero(new Vl(t.wrap + (t.canonical.x + e / Et) / n, (t.canonical.y + i / Et) / n));
        }
        getAtTileOffsetFunc(t, e, i, n) {
          return (a) => {
            const c = this.getAtTileOffset(t, a.x, a.y), h = n.upVector(t.canonical, a.x, a.y);
            return ro(h, h, c * n.upVectorScale(t.canonical, e, i).metersToTile), h;
          };
        }
        getForTilePoints(t, e, i, n) {
          if (this.isUsingMockSource()) return !1;
          const a = fh.create(this, t, n);
          return !!a && (e.forEach((c) => {
            c[2] = this.exaggeration() * a.getElevationAt(c[0], c[1], i);
          }), !0);
        }
        getMinMaxForTile(t) {
          if (this.isUsingMockSource()) return null;
          const e = this.findDEMTileFor(t);
          if (!e || !e.dem) return null;
          const i = e.dem.tree, n = e.tileID, a = 1 << t.canonical.z - n.canonical.z;
          let c = t.canonical.x / a - n.canonical.x, h = t.canonical.y / a - n.canonical.y, p = 0;
          for (let m = 0; m < t.canonical.z - n.canonical.z && !i.leaves[p]; m++) {
            c *= 2, h *= 2;
            const _ = 2 * Math.floor(h) + Math.floor(c);
            p = i.childOffsets[p] + _, c %= 1, h %= 1;
          }
          return { min: this.exaggeration() * i.minimums[p], max: this.exaggeration() * i.maximums[p] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(t, e, i) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(t) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        isUsingMockSource() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(t) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
      }, s.ErrorEvent = wr, s.EvaluationParameters = b, s.Event = uo, s.Evented = Fr, s.FillExtrusionBucket = Hc, s.Frustum = Wh, s.FrustumCorners = qh, s.GLOBE_RADIUS = fs, s.GLOBE_SCALE_MATCH_LATITUDE = 45, s.GLOBE_ZOOM_THRESHOLD_MAX = Rp, s.GLOBE_ZOOM_THRESHOLD_MIN = Xh, s.GlobeSharedBuffers = class {
        constructor(t) {
          this._createGrid(t), this._createPoles(t);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const t of this._poleSegments) t.destroy();
          for (const t of this._gridSegments) t.withSkirts.destroy(), t.withoutSkirts.destroy();
          if (this._wireframeIndexBuffer) {
            this._wireframeIndexBuffer.destroy();
            for (const t of this._wireframeSegments) t.destroy();
          }
        }
        _fillGridMeshWithLods(t, e) {
          const i = new Ge(), n = new vt(), a = [], c = t + 1 + 2, h = e[0] + 1, p = e[0] + 1 + (1 + e.length), m = (_, v, w) => {
            let T = _ === c - 1 ? _ - 2 : _ === 0 ? _ : _ - 1;
            return T += w ? 24575 : 0, [T, v];
          };
          for (let _ = 0; _ < c; ++_) i.emplaceBack(...m(_, 0, !0));
          for (let _ = 0; _ < h; ++_) for (let v = 0; v < c; ++v) i.emplaceBack(...m(v, _, (v === 0 || v === c - 1) && !0));
          for (let _ = 0; _ < e.length; ++_) {
            const v = e[_];
            for (let w = 0; w < c; ++w) i.emplaceBack(...m(w, v, !0));
          }
          for (let _ = 0; _ < e.length; ++_) {
            const v = n.length, w = e[_] + 1 + 2, T = new vt();
            for (let z = 0; z < w - 1; z++) {
              const U = z === w - 2, q = U ? c * (p - e.length + _ - z) : c;
              for (let ie = 0; ie < c - 1; ie++) {
                const W = z * c + ie;
                z === 0 || U || ie === 0 || ie === c - 2 ? (T.emplaceBack(W + 1, W, W + q), T.emplaceBack(W + q, W + q + 1, W + 1)) : (n.emplaceBack(W + 1, W, W + q), n.emplaceBack(W + q, W + q + 1, W + 1));
              }
            }
            const C = ur.simpleSegment(0, v, i.length, n.length - v);
            for (let z = 0; z < T.uint16.length; z += 3) n.emplaceBack(T.uint16[z], T.uint16[z + 1], T.uint16[z + 2]);
            const A = ur.simpleSegment(0, v, i.length, n.length - v);
            a.push({ withoutSkirts: C, withSkirts: A });
          }
          return { vertices: i, indices: n, segments: a };
        }
        _createGrid(t) {
          const e = this._fillGridMeshWithLods(rl, Uc);
          this._gridSegments = e.segments, this._gridBuffer = t.createVertexBuffer(e.vertices, Fc.members), this._gridIndexBuffer = t.createIndexBuffer(e.indices, !0);
        }
        _createPoles(t) {
          const e = new vt();
          for (let a = 0; a <= rl; a++) e.emplaceBack(0, a + 1, a + 2);
          this._poleIndexBuffer = t.createIndexBuffer(e, !0);
          const i = new Si(), n = new Si();
          this._poleSegments = [];
          for (let a = 0, c = 0; a < Xh; a++) {
            const h = 360 / (1 << a);
            i.emplaceBack(0, -fs, 0, 0.5, 0), n.emplaceBack(0, -fs, 0, 0.5, 1);
            for (let p = 0; p <= rl; p++) {
              const m = p / rl, _ = Kt(0, h, m), [v, w, T] = Ul(cg, ug, _, fs);
              i.emplaceBack(v, w, T, m, 0), n.emplaceBack(v, w, T, m, 1);
            }
            this._poleSegments.push(ur.simpleSegment(c, 0, 66, 64)), c += 66;
          }
          this._poleNorthVertexBuffer = t.createVertexBuffer(i, kp, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n, kp, !1);
        }
        getGridBuffers(t, e) {
          return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[t].withSkirts : this._gridSegments[t].withoutSkirts];
        }
        getPoleBuffers(t) {
          return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];
        }
        getWirefameBuffers(t, e) {
          if (!this._wireframeSegments) {
            const i = new Er(), n = rl, a = n + 1 + 2, c = 1;
            this._wireframeSegments = [];
            for (let h = 0, p = 0; h < Uc.length; h++) {
              const m = Uc[h];
              for (let v = c; v < m + c; v++) for (let w = c; w < n + c; w++) {
                const T = v * a + w;
                i.emplaceBack(T, T + 1), i.emplaceBack(T, T + a), i.emplaceBack(T, T + a + 1);
              }
              const _ = m * n * 3;
              this._wireframeSegments.push(ur.simpleSegment(0, p, (m + 1) * a, _)), p += _;
            }
            this._wireframeIndexBuffer = t.createIndexBuffer(i);
          }
          return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e]];
        }
      }, s.GlyphManager = Jl, s.ImagePosition = bd, s.KDBush = Fd, s.LivePerformanceUtils = hc, s.LngLat = Ci, s.LngLatBounds = _a, s.LocalGlyphMode = Ed, s.MAX_MERCATOR_LATITUDE = $r, s.MercatorCoordinate = Vl, s.ONE_EM = zr, s.OverscaledTileID = dn, s.PerformanceMarkers = is, s.Point = et, s.Properties = K, s.RGBAImage = Rn, s.Ray = Zh, s.RequestManager = class {
        constructor(t, e, i) {
          this._transformRequestFn = t, this._customAccessToken = e, this._silenceAuthErrors = !!i, this._createSkuToken();
        }
        _createSkuToken() {
          const t = function() {
            let e = "";
            for (let i = 0; i < 10; i++) e += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", Qt, e].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(t, e) {
          return this._transformRequestFn && this._transformRequestFn(t, e) || { url: t };
        }
        normalizeStyleURL(t, e) {
          if (!de(t)) return t;
          const i = it(t);
          return i.path = `/styles/v1${i.path}`, this._makeAPIURL(i, this._customAccessToken || e);
        }
        normalizeGlyphsURL(t, e) {
          if (!de(t)) return t;
          const i = it(t);
          return i.path = `/fonts/v1${i.path}`, this._makeAPIURL(i, this._customAccessToken || e);
        }
        normalizeSourceURL(t, e, i, n) {
          if (!de(t)) return t;
          const a = it(t);
          return a.path = `/v4/${a.authority}.json`, a.params.push("secure"), i && a.params.push(`language=${i}`), n && a.params.push(`worldview=${n}`), this._makeAPIURL(a, this._customAccessToken || e);
        }
        normalizeSpriteURL(t, e, i, n) {
          const a = it(t);
          return de(t) ? (a.path = `/styles/v1${a.path}/sprite${e}${i}`, this._makeAPIURL(a, this._customAccessToken || n)) : (a.path += `${e}${i}`, Ze(a));
        }
        normalizeTileURL(t, e, i) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t && !de(t)) return t;
          const n = it(t);
          n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e || i && n.authority !== "raster" && i === 512 ? "@2x" : ""}${rt.supported ? ".webp" : "$1"}`), n.authority === "raster" ? n.path = `/${Ie.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\/v4\//, "/"), n.path = `/${Ie.TILE_URL_VERSION}${n.path}`);
          const a = this._customAccessToken || function(c) {
            for (const h of c) {
              const p = h.match(/^access_token=(.*)$/);
              if (p) return p[1];
            }
            return null;
          }(n.params) || Ie.ACCESS_TOKEN;
          return Ie.REQUIRE_ACCESS_TOKEN && a && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, a);
        }
        canonicalizeTileURL(t, e) {
          const i = it(t);
          if (!i.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !i.path.match(/\.[\w]+$/)) return t;
          let n = "mapbox://";
          i.path.match(/^\/raster\/v1\//) ? n += `raster/${i.path.replace(`/${Ie.RASTER_URL_PREFIX}/`, "")}` : n += `tiles/${i.path.replace(`/${Ie.TILE_URL_VERSION}/`, "")}`;
          let a = i.params;
          return e && (a = a.filter((c) => !c.match(/^access_token=/))), a.length && (n += `?${a.join("&")}`), n;
        }
        canonicalizeTileset(t, e) {
          const i = !!e && de(e), n = [];
          for (const a of t.tiles || []) ve(a) ? n.push(this.canonicalizeTileURL(a, i)) : n.push(a);
          return n;
        }
        _makeAPIURL(t, e) {
          const i = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n = it(Ie.API_URL);
          if (t.protocol = n.protocol, t.authority = n.authority, t.protocol === "http") {
            const a = t.params.indexOf("secure");
            a >= 0 && t.params.splice(a, 1);
          }
          if (n.path !== "/" && (t.path = `${n.path}${t.path}`), !Ie.REQUIRE_ACCESS_TOKEN) return Ze(t);
          if (e = e || Ie.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!e) throw new Error(`An API access token is required to use Mapbox GL. ${i}`);
            if (e[0] === "s") throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${i}`);
          }
          return t.params = t.params.filter((a) => a.indexOf("access_token") === -1), t.params.push(`access_token=${e || ""}`), Ze(t);
        }
      }, s.ResourceType = An, s.SegmentVector = ur, s.SourceCache = cl, s.StencilMode = Dd, s.StructArrayLayout1ui2 = kn, s.StructArrayLayout2f1f2i16 = Ct, s.StructArrayLayout2i4 = Ge, s.StructArrayLayout2ui4 = Er, s.StructArrayLayout3f12 = Yt, s.StructArrayLayout3ui6 = vt, s.StructArrayLayout4i8 = Oe, s.StructArrayLayout5f20 = Si, s.Texture = su, s.Tile = zd, s.Transitionable = P, s.Uniform1f = ku, s.Uniform1i = class extends js {
        constructor(t) {
          super(t), this.current = 0;
        }
        set(t, e, i) {
          this.fetchUniformLocation(t, e) && this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
        }
      }, s.Uniform2f = class extends js {
        constructor(t) {
          super(t), this.current = [0, 0];
        }
        set(t, e, i) {
          this.fetchUniformLocation(t, e) && (i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1])));
        }
      }, s.Uniform3f = class extends js {
        constructor(t) {
          super(t), this.current = [0, 0, 0];
        }
        set(t, e, i) {
          this.fetchUniformLocation(t, e) && (i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2])));
        }
      }, s.Uniform4f = _p, s.UniformColor = gp, s.UniformMatrix2f = class extends js {
        constructor(t) {
          super(t), this.current = W_;
        }
        set(t, e, i) {
          if (this.fetchUniformLocation(t, e)) {
            for (let n = 0; n < 4; n++) if (i[n] !== this.current[n]) {
              this.current = i, this.gl.uniformMatrix2fv(this.location, !1, i);
              break;
            }
          }
        }
      }, s.UniformMatrix3f = class extends js {
        constructor(t) {
          super(t), this.current = q_;
        }
        set(t, e, i) {
          if (this.fetchUniformLocation(t, e)) {
            for (let n = 0; n < 9; n++) if (i[n] !== this.current[n]) {
              this.current = i, this.gl.uniformMatrix3fv(this.location, !1, i);
              break;
            }
          }
        }
      }, s.UniformMatrix4f = class extends js {
        constructor(t) {
          super(t), this.current = Z_;
        }
        set(t, e, i) {
          if (this.fetchUniformLocation(t, e)) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let n = 1; n < 16; n++) if (i[n] !== this.current[n]) {
              this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
              break;
            }
          }
        }
      }, s.UnwrappedTileID = Ef, s.ValidationError = pt, s.VectorTileFeature = Xu, s.VectorTileWorkerSource = class extends Fr {
        constructor(t, e, i, n, a) {
          super(), this.actor = t, this.layerIndex = e, this.availableImages = i, this.loadVectorData = a || Dm, this.loading = {}, this.loaded = {}, this.deduped = new km(t.scheduler), this.isSpriteLoaded = n, this.scheduler = t.scheduler;
        }
        loadTile(t, e) {
          const i = t.uid, n = t && t.request, a = n && n.collectResourceTiming, c = this.loading[i] = new _x(t);
          c.abort = this.loadVectorData(t, (h, p) => {
            const m = !this.loading[i];
            if (delete this.loading[i], m || h || !p) return c.status = "done", m || (this.loaded[i] = c), e(h);
            const _ = p.rawData, v = {};
            p.expires && (v.expires = p.expires), p.cacheControl && (v.cacheControl = p.cacheControl), c.vectorTile = p.vectorTile || new _d(new eh(_));
            const w = () => {
              c.parse(c.vectorTile, this.layerIndex, this.availableImages, this.actor, (T, C) => {
                if (T || !C) return e(T);
                const A = {};
                if (a) {
                  const z = Ma(n);
                  z.length > 0 && (A.resourceTiming = JSON.parse(JSON.stringify(z)));
                }
                e(null, si({ rawTileData: _.slice(0) }, C, v, A));
              });
            };
            this.isSpriteLoaded ? w() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(w, { type: "parseTile", isSymbolTile: t.isSymbolTile, zoom: t.tileZoom }) : w();
            }), this.loaded = this.loaded || {}, this.loaded[i] = c;
          });
        }
        reloadTile(t, e) {
          const i = this.loaded, n = t.uid, a = this;
          if (i && i[n]) {
            const c = i[n];
            c.showCollisionBoxes = t.showCollisionBoxes, c.enableTerrain = !!t.enableTerrain, c.projection = t.projection, c.tileTransform = ll(t.tileID.canonical, t.projection);
            const h = (p, m) => {
              const _ = c.reloadCallback;
              _ && (delete c.reloadCallback, c.parse(c.vectorTile, a.layerIndex, this.availableImages, a.actor, _)), e(p, m);
            };
            c.status === "parsing" ? c.reloadCallback = h : c.status === "done" && (c.vectorTile ? c.parse(c.vectorTile, this.layerIndex, this.availableImages, this.actor, h) : h());
          }
        }
        abortTile(t, e) {
          const i = t.uid, n = this.loading[i];
          n && (n.abort && n.abort(), delete this.loading[i]), e();
        }
        removeTile(t, e) {
          const i = this.loaded, n = t.uid;
          i && i[n] && delete i[n], e();
        }
      }, s.WritingMode = oo, s.ZoomDependentExpression = $a, s.add = Gs, s.addDynamicAttributes = uh, s.adjoint = function(t, e) {
        var i = e[0], n = e[1], a = e[2], c = e[3], h = e[4], p = e[5], m = e[6], _ = e[7], v = e[8];
        return t[0] = h * v - p * _, t[1] = a * _ - n * v, t[2] = n * p - a * h, t[3] = p * m - c * v, t[4] = i * v - a * m, t[5] = a * c - i * p, t[6] = c * _ - h * m, t[7] = n * m - i * _, t[8] = i * h - n * c, t;
      }, s.asyncAll = er, s.bezier = br, s.bindAll = tr, s.boundsAttributes = _m, s.bufferConvexPolygon = function(t, e) {
        const i = [];
        for (let n = 0; n < t.length; n++) {
          const a = Zi(n - 1, -1, t.length - 1), c = Zi(n + 1, -1, t.length - 1), h = t[n], p = t[c], m = t[a].sub(h).unit(), _ = p.sub(h).unit(), v = _.angleWithSep(m.x, m.y), w = m.add(_).unit().mult(-1 * e / Math.sin(v / 2));
          i.push(h.add(w));
        }
        return i;
      }, s.cacheEntryPossiblyAdded = function(t) {
        lo++, lo > Cn && (t.getActor().send("enforceCacheSizeLimit", Es), lo = 0);
      }, s.calculateGlobeLabelMatrix = function(t, e) {
        const { x: i, y: n } = t.point, a = Np(i, n, t.worldSize / t._pixelsPerMercatorPixel, 0, 0);
        return el(a, a, Jh(ms(e)));
      }, s.calculateGlobeMatrix = function(t) {
        const { x: e, y: i } = t.point, { lng: n, lat: a } = t._center;
        return Np(e, i, t.worldSize, n, a);
      }, s.calculateGlobeMercatorMatrix = function(t) {
        const e = t.pixelsPerMeter, i = e / Wo(1, t.center.lat), n = Zo(new Float64Array(16));
        return zc(n, n, [t.point.x, t.point.y, 0]), tl(n, n, [i, i, e]), Float32Array.from(n);
      }, s.circumferenceAtLatitude = Qh, s.clamp = Vt, s.clearTileCache = function(t) {
        if (!Po()) return;
        const e = re.caches.delete(Gn);
        t && e.catch(t).then(() => t());
      }, s.clipLine = Yf, s.clone = function(t) {
        var e = new Dn(16);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
      }, s.clone$1 = qr, s.collisionCircleLayout = fy, s.config = Ie, s.conjugate = function(t, e) {
        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
      }, s.create = function() {
        var t = new Dn(16);
        return Dn != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
      }, s.create$1 = vp, s.createExpression = ca, s.createLayout = me, s.createStyleLayer = function(t) {
        return t.type === "custom" ? new ox(t) : new ax[t.type](t);
      }, s.cross = $h, s.degToRad = Pt, s.distance = function(t, e) {
        return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2]);
      }, s.div = function(t, e, i) {
        return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t[2] = e[2] / i[2], t;
      }, s.dot = So, s.earthRadius = Vc, s.ease = ao, s.easeCubicInOut = Fn, s.ecefToLatLng = function([t, e, i]) {
        const n = Math.hypot(t, e, i), a = Math.atan2(t, i), c = 0.5 * Math.PI - Math.acos(-e / n);
        return new Ci(Fi(a), Fi(c));
      }, s.emitValidationErrors = Cu, s.endsWith = Wt, s.enforceCacheSizeLimit = function(t) {
        _n(), Br && Br.then((e) => {
          e.keys().then((i) => {
            for (let n = 0; n < i.length - t; n++) e.delete(i[n]);
          });
        });
      }, s.evaluateSizeForFeature = Yu, s.evaluateSizeForZoom = Wl, s.evaluateVariableOffset = rm, s.evented = d, s.exactEquals = function(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];
      }, s.exactEquals$1 = function(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
      }, s.exported = gn, s.exported$1 = rt, s.extend = si, s.extend$1 = Cr, s.fillExtrusionHeightLift = bf, s.filterObject = Yo, s.fromMat4 = function(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;
      }, s.fromQuat = function(t, e) {
        var i = e[0], n = e[1], a = e[2], c = e[3], h = i + i, p = n + n, m = a + a, _ = i * h, v = n * h, w = n * p, T = a * h, C = a * p, A = a * m, z = c * h, U = c * p, q = c * m;
        return t[0] = 1 - w - A, t[1] = v + q, t[2] = T - U, t[3] = 0, t[4] = v - q, t[5] = 1 - _ - A, t[6] = C + z, t[7] = 0, t[8] = T + U, t[9] = C - z, t[10] = 1 - _ - w, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, s.fromRotation = function(t, e) {
        var i = Math.sin(e), n = Math.cos(e);
        return t[0] = n, t[1] = i, t[2] = 0, t[3] = -i, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
      }, s.fromScaling = wp, s.furthestTileCorner = function(t) {
        const e = Math.round((t + 45 + 360) % 360 / 90) % 4;
        return Zr[e];
      }, s.getAABBPointSquareDist = function(t, e, i) {
        let n = 0;
        for (let a = 0; a < 2; ++a) {
          const c = i ? i[a] : 0;
          t[a] > c && (n += (t[a] - c) * (t[a] - c)), e[a] < c && (n += (c - e[a]) * (c - e[a]));
        }
        return n;
      }, s.getAnchorAlignment = Td, s.getAnchorJustification = Md, s.getBounds = function(t) {
        let e = 1 / 0, i = 1 / 0, n = -1 / 0, a = -1 / 0;
        for (const c of t) e = Math.min(e, c.x), i = Math.min(i, c.y), n = Math.max(n, c.x), a = Math.max(a, c.y);
        return { min: new et(e, i), max: new et(n, a) };
      }, s.getColumn = Vn, s.getDefaultExportFromCjs = St, s.getGridMatrix = function(t, e, i, n) {
        const a = e.getNorth(), c = e.getSouth(), h = e.getWest(), p = e.getEast(), m = 1 << t.z, _ = p - h, v = a - c, w = _ / rl, T = -v / Uc[i], C = [0, w, 0, T, 0, 0, a, h, 0];
        if (t.z > 0) {
          const A = 180 / n;
          bp(C, C, [A / _ + 1, 0, 0, 0, A / v + 1, 0, -0.5 * A / w, 0.5 * A / T, 1]);
        }
        return C[2] = m, C[5] = t.x, C[8] = t.y, C;
      }, s.getImage = H, s.getJSON = function(t, e) {
        return tn(si(t, { type: "json" }), e);
      }, s.getLatitudinalLod = function(t) {
        const e = $r - 5;
        t = Vt(t, -e, e) / e * 90;
        const i = Math.pow(Math.abs(Math.sin(Pt(t))), 3);
        return Math.round(i * (Uc.length - 1));
      }, s.getMapSessionAPI = gr, s.getPerformanceMeasurement = Ma, s.getProjection = hm, s.getRTLTextPluginStatus = f, s.getReferrer = Lo, s.getTilePoint = function(t, { x: e, y: i }, n = 0) {
        return new et(((e - n) * t.scale - t.x) * Et, (i * t.scale - t.y) * Et);
      }, s.getTileVec3 = function(t, e, i = 0) {
        return Fl(((e.x - i) * t.scale - t.x) * Et, (e.y * t.scale - t.y) * Et, $p(e.z, e.y));
      }, s.getVideo = function(t, e) {
        const i = re.document.createElement("video");
        i.muted = !0, i.onloadstart = function() {
          e(null, i);
        };
        for (let n = 0; n < t.length; n++) {
          const a = re.document.createElement("source");
          ts(t[n]) || (i.crossOrigin = "Anonymous"), a.src = t[n], i.appendChild(a);
        }
        return { cancel: () => {
        } };
      }, s.globeCenterToScreenPoint = function(t) {
        const e = [0, 0, 0], i = Zo(new Float64Array(16));
        return el(i, t.pixelMatrix, t.globeMatrix), rr(e, e, i), new et(e[0], e[1]);
      }, s.globeDenormalizeECEF = Jh, s.globeECEFOrigin = function(t, e) {
        const i = [0, 0, 0];
        return rr(i, i, jc(ms(e.canonical))), rr(i, i, t), i;
      }, s.globeMetersToEcef = Ou, s.globeNormalizeECEF = jc, s.globePixelsToTileUnits = function(t, e) {
        return Et / (512 * Math.pow(2, t)) * Fu(ms(e));
      }, s.globePoleMatrixForTile = function(t, e, i) {
        const n = Zo(new Float64Array(16)), a = (e / (1 << t) - 0.5) * Math.PI * 2;
        return Ru(n, i.globeMatrix, a), Float32Array.from(n);
      }, s.globeTileBounds = ms, s.globeTiltAtLngLat = jp, s.globeToMercatorTransition = jl, s.globeUseCustomAntiAliasing = function(t, e, i) {
        const n = jl(i.zoom), a = t.style.map._antialias, c = !!e.extStandardDerivatives, h = e.extStandardDerivativesForceOff || t.terrain && t.terrain.exaggeration() > 0;
        return n === 0 && !a && !h && c;
      }, s.identity = Zo, s.identity$1 = Pp, s.invert = Nh, s.isFullscreen = function() {
        return !!re.document.fullscreenElement || !!re.document.webkitFullscreenElement;
      }, s.isLngLatBehindGlobe = Yh, s.isMapAuthenticated = function(t) {
        return wi.has(t);
      }, s.isMapboxURL = de, s.isSafariWithAntialiasingBug = function(t) {
        const e = t.navigator ? t.navigator.userAgent : null;
        return !!Qo(t) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
      }, s.latFromMercatorY = Gr, s.latLngToECEF = Nl, s.len = ig, s.length = kc, s.length$1 = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3]);
      }, s.lngFromMercatorX = no, s.loadVectorTile = Dm, s.makeRequest = tn, s.mapValue = function(t, e, i, n, a) {
        return Vt((t - e) / (i - e) * (a - n) + n, n, a);
      }, s.mercatorScale = Zp, s.mercatorXfromLng = _s, s.mercatorYfromLat = gs, s.mercatorZfromAltitude = Wo, s.mul = eg, s.mul$1 = tg, s.multiply = el, s.multiply$1 = bp, s.multiply$2 = Sp, s.nextPowerOfTwo = Un, s.normalize = un, s.normalize$1 = rg, s.normalize$2 = Ap, s.number = Kt, s.ortho = function(t, e, i, n, a, c, h) {
        var p = 1 / (e - i), m = 1 / (n - a), _ = 1 / (c - h);
        return t[0] = -2 * p, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * m, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * _, t[11] = 0, t[12] = (e + i) * p, t[13] = (a + n) * m, t[14] = (h + c) * _, t[15] = 1, t;
      }, s.pbf = Lf, s.perspective = function(t, e, i, n, a) {
        var c, h = 1 / Math.tan(e / 2);
        return t[0] = h / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = h, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, a != null && a !== 1 / 0 ? (t[10] = (a + n) * (c = 1 / (n - a)), t[14] = 2 * a * n * c) : (t[10] = -1, t[14] = -2 * n), t;
      }, s.pick = function(t, e) {
        const i = {};
        for (let n = 0; n < e.length; n++) {
          const a = e[n];
          a in t && (i[a] = t[a]);
        }
        return i;
      }, s.plugin = x, s.pointGeometry = ui, s.polesInViewport = function(t) {
        const e = Zo(new Float64Array(16));
        el(e, t.pixelMatrix, t.globeMatrix);
        const i = [0, Mo, 0], n = [0, Co, 0];
        return rr(i, i, e), rr(n, n, e), [i[0] > 0 && i[0] <= t.width && i[1] > 0 && i[1] <= t.height && !Yh(t, new Ci(t.center.lat, 90)), n[0] > 0 && n[0] <= t.width && n[1] > 0 && n[1] <= t.height && !Yh(t, new Ci(t.center.lat, -90))];
      }, s.polygonContainsPoint = sl, s.polygonIntersectsBox = Yp, s.polygonIntersectsPolygon = Xp, s.polygonizeBounds = function(t, e, i = 0, n = !0) {
        const a = new et(i, i), c = t.sub(a), h = e.add(a), p = [c, new et(h.x, c.y), h, new et(c.x, h.y)];
        return n && p.push(c.clone()), p;
      }, s.posAttributes = Fc, s.postMapLoadEvent = Hi, s.postPerformanceEvent = qi, s.postTurnstileEvent = Xt, s.potpack = vd, s.prevPowerOfTwo = function(t) {
        return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      }, s.radToDeg = Fi, s.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], s.registerForPluginStateChange = function(t) {
        return t({ pluginStatus: l, pluginURL: r }), d.on("pluginStateChange", t), t;
      }, s.removeAuthState = function(t) {
        wi.delete(t);
      }, s.renderColorRamp = ad, s.resample = qp, s.rotateX = jh, s.rotateX$1 = Lp, s.rotateY = Ru, s.rotateY$1 = zp, s.rotateZ = function(t, e, i) {
        var n = Math.sin(i), a = Math.cos(i), c = e[0], h = e[1], p = e[2], m = e[3], _ = e[4], v = e[5], w = e[6], T = e[7];
        return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = c * a + _ * n, t[1] = h * a + v * n, t[2] = p * a + w * n, t[3] = m * a + T * n, t[4] = _ * a - c * n, t[5] = v * a - h * n, t[6] = w * a - p * n, t[7] = T * a - m * n, t;
      }, s.rotateZ$1 = function(t, e, i) {
        i *= 0.5;
        var n = e[0], a = e[1], c = e[2], h = e[3], p = Math.sin(i), m = Math.cos(i);
        return t[0] = n * m + a * p, t[1] = a * m - n * p, t[2] = c * m + h * p, t[3] = h * m - c * p, t;
      }, s.scale = tl, s.scale$1 = Cp, s.scale$2 = ro, s.scaleAndAdd = Oc, s.set = function(t, e, i, n) {
        return t[0] = e, t[1] = i, t[2] = n, t;
      }, s.setCacheLimits = function(t, e) {
        Es = t, Cn = e;
      }, s.setColumn = function(t, e, i) {
        t[4 * e + 0] = i[0], t[4 * e + 1] = i[1], t[4 * e + 2] = i[2], t[4 * e + 3] = i[3];
      }, s.setRTLTextPlugin = function(t, e, i = !1) {
        if (l === Cc || l === Ac || l === Ic) throw new Error("setRTLTextPlugin cannot be called multiple times.");
        r = gn.resolveURL(t), l = Cc, pa = e, u(), i || g();
      }, s.smoothstep = Sn, s.spec = Pe, s.squaredLength = function(t) {
        var e = t[0], i = t[1], n = t[2];
        return e * e + i * i + n * n;
      }, s.storeAuthState = function(t, e) {
        e ? wi.add(t) : wi.delete(t);
      }, s.sub = qo, s.subtract = Gh, s.symbolSize = my, s.tileAABB = function(t, e, i, n, a, c, h, p, m) {
        if (m.name === "globe") return lg(t, e, new Ku(i, n, a));
        const _ = ll({ z: i, x: n, y: a }, m);
        return new hn([(c + _.x / _.scale) * e, e * (_.y / _.scale), h], [(c + _.x2 / _.scale) * e, e * (_.y2 / _.scale), p]);
      }, s.tileCornersToBounds = Bu, s.tileTransform = ll, s.transformMat3 = function(t, e, i) {
        var n = e[0], a = e[1], c = e[2];
        return t[0] = n * i[0] + a * i[3] + c * i[6], t[1] = n * i[1] + a * i[4] + c * i[7], t[2] = n * i[2] + a * i[5] + c * i[8], t;
      }, s.transformMat4 = rr, s.transformMat4$1 = il, s.transformQuat = Mp, s.transitionTileAABBinECEF = Bp, s.translate = zc, s.transpose = function(t, e) {
        if (t === e) {
          var i = e[1], n = e[2], a = e[5];
          t[1] = e[3], t[2] = e[6], t[3] = i, t[5] = e[7], t[6] = n, t[7] = a;
        } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
        return t;
      }, s.triggerPluginCompletionEvent = o, s.uniqueId = Or, s.updateGlobeVertexNormal = function(t, e, i, n, a) {
        const c = 5 * e + 2;
        t.float32[c + 0] = i, t.float32[c + 1] = n, t.float32[c + 2] = a;
      }, s.validateCustomStyleLayer = function(t) {
        const e = [], i = t.id;
        return i === void 0 && e.push({ message: `layers.${i}: missing required property "id"` }), t.render === void 0 && e.push({ message: `layers.${i}: missing required method "render"` }), t.renderingMode && t.renderingMode !== "2d" && t.renderingMode !== "3d" && e.push({ message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"` }), e;
      }, s.validateFilter = (t) => zn(Ha(t)), s.validateFog = (t) => zn(Eu(t)), s.validateLayer = (t) => zn(vu(t)), s.validateLight = (t) => zn(Tu(t)), s.validateSource = (t) => zn(wu(t)), s.validateStyle = Mu, s.validateTerrain = (t) => zn(wc(t)), s.values = Mn, s.vectorTile = Wu, s.version = Be, s.warnOnce = Ui, s.window = re, s.wrap = Zi;
    }), ee(["./shared"], function(s) {
      function re(Q) {
        if (typeof Q == "number" || typeof Q == "boolean" || typeof Q == "string" || Q == null) return JSON.stringify(Q);
        if (Array.isArray(Q)) {
          let R = "[";
          for (const H of Q) R += `${re(H)},`;
          return `${R}]`;
        }
        let D = "{";
        for (const R of Object.keys(Q).sort()) D += `${R}:${re(Q[R])},`;
        return `${D}}`;
      }
      function Be(Q) {
        let D = "";
        for (const R of s.refProperties) D += `/${re(Q[R])}`;
        return D;
      }
      class Qe {
        constructor(D) {
          this.keyCache = {}, D && this.replace(D);
        }
        replace(D) {
          this._layerConfigs = {}, this._layers = {}, this.update(D, []);
        }
        update(D, R) {
          for (const se of D) this._layerConfigs[se.id] = se, (this._layers[se.id] = s.createStyleLayer(se)).compileFilter(), this.keyCache[se.id] && delete this.keyCache[se.id];
          for (const se of R) delete this.keyCache[se], delete this._layerConfigs[se], delete this._layers[se];
          this.familiesBySource = {};
          const H = function(se, de) {
            const ve = {};
            for (let pe = 0; pe < se.length; pe++) {
              const Me = de && de[se[pe].id] || Be(se[pe]);
              de && (de[se[pe].id] = Me);
              let Xe = ve[Me];
              Xe || (Xe = ve[Me] = []), Xe.push(se[pe]);
            }
            const xe = [];
            for (const pe in ve) xe.push(ve[pe]);
            return xe;
          }(s.values(this._layerConfigs), this.keyCache);
          for (const se of H) {
            const de = se.map((it) => this._layers[it.id]), ve = de[0];
            if (ve.visibility === "none") continue;
            const xe = ve.source || "";
            let pe = this.familiesBySource[xe];
            pe || (pe = this.familiesBySource[xe] = {});
            const Me = ve.sourceLayer || "_geojsonTileLayer";
            let Xe = pe[Me];
            Xe || (Xe = pe[Me] = []), Xe.push(de);
          }
        }
      }
      class Ie {
        loadTile(D, R) {
          const { uid: H, encoding: se, rawImageData: de, padding: ve, buildQuadTree: xe } = D, pe = s.window.ImageBitmap && de instanceof s.window.ImageBitmap ? this.getImageData(de, ve) : de;
          R(null, new s.DEMData(H, pe, se, ve < 1, xe));
        }
        getImageData(D, R) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(D.width, D.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: !0 })), this.offscreenCanvas.width = D.width, this.offscreenCanvas.height = D.height, this.offscreenCanvasContext.drawImage(D, 0, 0, D.width, D.height);
          const H = this.offscreenCanvasContext.getImageData(-R, -R, D.width + 2 * R, D.height + 2 * R);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), H;
        }
      }
      function rt(Q, D) {
        if (Q.length !== 0) {
          ut(Q[0], D);
          for (var R = 1; R < Q.length; R++) ut(Q[R], !D);
        }
      }
      function ut(Q, D) {
        for (var R = 0, H = 0, se = 0, de = Q.length, ve = de - 1; se < de; ve = se++) {
          var xe = (Q[se][0] - Q[ve][0]) * (Q[ve][1] + Q[se][1]), pe = R + xe;
          H += Math.abs(R) >= Math.abs(xe) ? R - pe + xe : xe - pe + R, R = pe;
        }
        R + H >= 0 != !!D && Q.reverse();
      }
      var lt = s.getDefaultExportFromCjs(function Q(D, R) {
        var H, se = D && D.type;
        if (se === "FeatureCollection") for (H = 0; H < D.features.length; H++) Q(D.features[H], R);
        else if (se === "GeometryCollection") for (H = 0; H < D.geometries.length; H++) Q(D.geometries[H], R);
        else if (se === "Feature") Q(D.geometry, R);
        else if (se === "Polygon") rt(D.coordinates, R);
        else if (se === "MultiPolygon") for (H = 0; H < D.coordinates.length; H++) rt(D.coordinates[H], R);
        return D;
      });
      const Ke = s.VectorTileFeature.prototype.toGeoJSON;
      var mt = { exports: {} }, kt = s.pointGeometry, Qt = s.vectorTile.VectorTileFeature, St = It;
      function It(Q, D) {
        this.options = D || {}, this.features = Q, this.length = Q.length;
      }
      function ni(Q, D) {
        this.id = typeof Q.id == "number" ? Q.id : void 0, this.type = Q.type, this.rawGeometry = Q.type === 1 ? [Q.geometry] : Q.geometry, this.properties = Q.tags, this.extent = D || 4096;
      }
      It.prototype.feature = function(Q) {
        return new ni(this.features[Q], this.options.extent);
      }, ni.prototype.loadGeometry = function() {
        var Q = this.rawGeometry;
        this.geometry = [];
        for (var D = 0; D < Q.length; D++) {
          for (var R = Q[D], H = [], se = 0; se < R.length; se++) H.push(new kt(R[se][0], R[se][1]));
          this.geometry.push(H);
        }
        return this.geometry;
      }, ni.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var Q = this.geometry, D = 1 / 0, R = -1 / 0, H = 1 / 0, se = -1 / 0, de = 0; de < Q.length; de++) for (var ve = Q[de], xe = 0; xe < ve.length; xe++) {
          var pe = ve[xe];
          D = Math.min(D, pe.x), R = Math.max(R, pe.x), H = Math.min(H, pe.y), se = Math.max(se, pe.y);
        }
        return [D, H, R, se];
      }, ni.prototype.toGeoJSON = Qt.prototype.toGeoJSON;
      var Qr = s.pbf, ui = St;
      function $i(Q) {
        var D = new Qr();
        return function(R, H) {
          for (var se in R.layers) H.writeMessage(3, et, R.layers[se]);
        }(Q, D), D.finish();
      }
      function et(Q, D) {
        var R;
        D.writeVarintField(15, Q.version || 1), D.writeStringField(1, Q.name || ""), D.writeVarintField(5, Q.extent || 4096);
        var H = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (R = 0; R < Q.length; R++) H.feature = Q.feature(R), D.writeMessage(2, Dr, H);
        var se = H.keys;
        for (R = 0; R < se.length; R++) D.writeStringField(3, se[R]);
        var de = H.values;
        for (R = 0; R < de.length; R++) D.writeMessage(4, Fn, de[R]);
      }
      function Dr(Q, D) {
        var R = Q.feature;
        R.id !== void 0 && D.writeVarintField(1, R.id), D.writeMessage(2, or, Q), D.writeVarintField(3, R.type), D.writeMessage(4, Zr, R);
      }
      function or(Q, D) {
        var R = Q.feature, H = Q.keys, se = Q.values, de = Q.keycache, ve = Q.valuecache;
        for (var xe in R.properties) {
          var pe = R.properties[xe], Me = de[xe];
          if (pe !== null) {
            Me === void 0 && (H.push(xe), de[xe] = Me = H.length - 1), D.writeVarint(Me);
            var Xe = typeof pe;
            Xe !== "string" && Xe !== "boolean" && Xe !== "number" && (pe = JSON.stringify(pe));
            var it = Xe + ":" + pe, Ze = ve[it];
            Ze === void 0 && (se.push(pe), ve[it] = Ze = se.length - 1), D.writeVarint(Ze);
          }
        }
      }
      function Pt(Q, D) {
        return (D << 3) + (7 & Q);
      }
      function Fi(Q) {
        return Q << 1 ^ Q >> 31;
      }
      function Zr(Q, D) {
        for (var R = Q.loadGeometry(), H = Q.type, se = 0, de = 0, ve = R.length, xe = 0; xe < ve; xe++) {
          var pe = R[xe], Me = 1;
          H === 1 && (Me = pe.length), D.writeVarint(Pt(1, Me));
          for (var Xe = H === 3 ? pe.length - 1 : pe.length, it = 0; it < Xe; it++) {
            it === 1 && H !== 1 && D.writeVarint(Pt(2, Xe - 1));
            var Ze = pe[it].x - se, Bt = pe[it].y - de;
            D.writeVarint(Fi(Ze)), D.writeVarint(Fi(Bt)), se += Ze, de += Bt;
          }
          H === 3 && D.writeVarint(Pt(7, 1));
        }
      }
      function Fn(Q, D) {
        var R = typeof Q;
        R === "string" ? D.writeStringField(1, Q) : R === "boolean" ? D.writeBooleanField(7, Q) : R === "number" && (Q % 1 != 0 ? D.writeDoubleField(3, Q) : Q < 0 ? D.writeSVarintField(6, Q) : D.writeVarintField(5, Q));
      }
      mt.exports = $i, mt.exports.fromVectorTileJs = $i, mt.exports.fromGeojsonVt = function(Q, D) {
        D = D || {};
        var R = {};
        for (var H in Q) R[H] = new ui(Q[H].features, D), R[H].name = H, R[H].version = D.version, R[H].extent = D.extent;
        return $i({ layers: R });
      }, mt.exports.GeoJSONWrapper = ui;
      var br = s.getDefaultExportFromCjs(mt.exports);
      const ao = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (Q) => Q }, Vt = Math.fround || (Sn = new Float32Array(1), (Q) => (Sn[0] = +Q, Sn[0]));
      var Sn;
      const Zi = 3, er = 5, Mn = 6;
      class si {
        constructor(D) {
          this.options = Object.assign(Object.create(ao), D), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(D) {
          const { log: R, minZoom: H, maxZoom: se } = this.options;
          R && console.time("total time");
          const de = `prepare ${D.length} points`;
          R && console.time(de), this.points = D;
          const ve = [];
          for (let pe = 0; pe < D.length; pe++) {
            const Me = D[pe];
            if (!Me.geometry) continue;
            const [Xe, it] = Me.geometry.coordinates, Ze = Vt(sr(Xe)), Bt = Vt(Un(it));
            ve.push(Ze, Bt, 1 / 0, pe, -1, 1), this.options.reduce && ve.push(0);
          }
          let xe = this.trees[se + 1] = this._createTree(ve);
          R && console.timeEnd(de);
          for (let pe = se; pe >= H; pe--) {
            const Me = +Date.now();
            xe = this.trees[pe] = this._createTree(this._cluster(xe, pe)), R && console.log("z%d: %d clusters in %dms", pe, xe.numItems, +Date.now() - Me);
          }
          return R && console.timeEnd("total time"), this;
        }
        getClusters(D, R) {
          let H = ((D[0] + 180) % 360 + 360) % 360 - 180;
          const se = Math.max(-90, Math.min(90, D[1]));
          let de = D[2] === 180 ? 180 : ((D[2] + 180) % 360 + 360) % 360 - 180;
          const ve = Math.max(-90, Math.min(90, D[3]));
          if (D[2] - D[0] >= 360) H = -180, de = 180;
          else if (H > de) {
            const it = this.getClusters([H, se, 180, ve], R), Ze = this.getClusters([-180, se, de, ve], R);
            return it.concat(Ze);
          }
          const xe = this.trees[this._limitZoom(R)], pe = xe.range(sr(H), Un(ve), sr(de), Un(se)), Me = xe.data, Xe = [];
          for (const it of pe) {
            const Ze = this.stride * it;
            Xe.push(Me[Ze + er] > 1 ? Rr(Me, Ze, this.clusterProps) : this.points[Me[Ze + Zi]]);
          }
          return Xe;
        }
        getChildren(D) {
          const R = this._getOriginId(D), H = this._getOriginZoom(D), se = "No cluster with the specified id.", de = this.trees[H];
          if (!de) throw new Error(se);
          const ve = de.data;
          if (R * this.stride >= ve.length) throw new Error(se);
          const xe = this.options.radius / (this.options.extent * Math.pow(2, H - 1)), pe = de.within(ve[R * this.stride], ve[R * this.stride + 1], xe), Me = [];
          for (const Xe of pe) {
            const it = Xe * this.stride;
            ve[it + 4] === D && Me.push(ve[it + er] > 1 ? Rr(ve, it, this.clusterProps) : this.points[ve[it + Zi]]);
          }
          if (Me.length === 0) throw new Error(se);
          return Me;
        }
        getLeaves(D, R, H) {
          const se = [];
          return this._appendLeaves(se, D, R = R || 10, H = H || 0, 0), se;
        }
        getTile(D, R, H) {
          const se = this.trees[this._limitZoom(D)], de = Math.pow(2, D), { extent: ve, radius: xe } = this.options, pe = xe / ve, Me = (H - pe) / de, Xe = (H + 1 + pe) / de, it = { features: [] };
          return this._addTileFeatures(se.range((R - pe) / de, Me, (R + 1 + pe) / de, Xe), se.data, R, H, de, it), R === 0 && this._addTileFeatures(se.range(1 - pe / de, Me, 1, Xe), se.data, de, H, de, it), R === de - 1 && this._addTileFeatures(se.range(0, Me, pe / de, Xe), se.data, -1, H, de, it), it.features.length ? it : null;
        }
        getClusterExpansionZoom(D) {
          let R = this._getOriginZoom(D) - 1;
          for (; R <= this.options.maxZoom; ) {
            const H = this.getChildren(D);
            if (R++, H.length !== 1) break;
            D = H[0].properties.cluster_id;
          }
          return R;
        }
        _appendLeaves(D, R, H, se, de) {
          const ve = this.getChildren(R);
          for (const xe of ve) {
            const pe = xe.properties;
            if (pe && pe.cluster ? de + pe.point_count <= se ? de += pe.point_count : de = this._appendLeaves(D, pe.cluster_id, H, se, de) : de < se ? de++ : D.push(xe), D.length === H) break;
          }
          return de;
        }
        _createTree(D) {
          const R = new s.KDBush(D.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let H = 0; H < D.length; H += this.stride) R.add(D[H], D[H + 1]);
          return R.finish(), R.data = D, R;
        }
        _addTileFeatures(D, R, H, se, de, ve) {
          for (const xe of D) {
            const pe = xe * this.stride, Me = R[pe + er] > 1;
            let Xe, it, Ze;
            if (Me) Xe = Or(R, pe, this.clusterProps), it = R[pe], Ze = R[pe + 1];
            else {
              const Rt = this.points[R[pe + Zi]];
              Xe = Rt.properties;
              const [qt, Xt] = Rt.geometry.coordinates;
              it = sr(qt), Ze = Un(Xt);
            }
            const Bt = { type: 1, geometry: [[Math.round(this.options.extent * (it * de - H)), Math.round(this.options.extent * (Ze * de - se))]], tags: Xe };
            let Lt;
            Lt = Me || this.options.generateId ? R[pe + Zi] : this.points[R[pe + Zi]].id, Lt !== void 0 && (Bt.id = Lt), ve.features.push(Bt);
          }
        }
        _limitZoom(D) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+D), this.options.maxZoom + 1));
        }
        _cluster(D, R) {
          const { radius: H, extent: se, reduce: de, minPoints: ve } = this.options, xe = H / (se * Math.pow(2, R)), pe = D.data, Me = [], Xe = this.stride;
          for (let it = 0; it < pe.length; it += Xe) {
            if (pe[it + 2] <= R) continue;
            pe[it + 2] = R;
            const Ze = pe[it], Bt = pe[it + 1], Lt = D.within(pe[it], pe[it + 1], xe), Rt = pe[it + er];
            let qt = Rt;
            for (const Xt of Lt) {
              const bi = Xt * Xe;
              pe[bi + 2] > R && (qt += pe[bi + er]);
            }
            if (qt > Rt && qt >= ve) {
              let Xt, bi = Ze * Rt, Hi = Bt * Rt, ar = -1;
              const qi = ((it / Xe | 0) << 5) + (R + 1) + this.points.length;
              for (const In of Lt) {
                const gr = In * Xe;
                if (pe[gr + 2] <= R) continue;
                pe[gr + 2] = R;
                const wi = pe[gr + er];
                bi += pe[gr] * wi, Hi += pe[gr + 1] * wi, pe[gr + 4] = qi, de && (Xt || (Xt = this._map(pe, it, !0), ar = this.clusterProps.length, this.clusterProps.push(Xt)), de(Xt, this._map(pe, gr)));
              }
              pe[it + 4] = qi, Me.push(bi / qt, Hi / qt, 1 / 0, qi, -1, qt), de && Me.push(ar);
            } else {
              for (let Xt = 0; Xt < Xe; Xt++) Me.push(pe[it + Xt]);
              if (qt > 1) for (const Xt of Lt) {
                const bi = Xt * Xe;
                if (!(pe[bi + 2] <= R)) {
                  pe[bi + 2] = R;
                  for (let Hi = 0; Hi < Xe; Hi++) Me.push(pe[bi + Hi]);
                }
              }
            }
          }
          return Me;
        }
        _getOriginId(D) {
          return D - this.points.length >> 5;
        }
        _getOriginZoom(D) {
          return (D - this.points.length) % 32;
        }
        _map(D, R, H) {
          if (D[R + er] > 1) {
            const ve = this.clusterProps[D[R + Mn]];
            return H ? Object.assign({}, ve) : ve;
          }
          const se = this.points[D[R + Zi]].properties, de = this.options.map(se);
          return H && de === se ? Object.assign({}, de) : de;
        }
      }
      function Rr(Q, D, R) {
        return { type: "Feature", id: Q[D + Zi], properties: Or(Q, D, R), geometry: { type: "Point", coordinates: [(H = Q[D], 360 * (H - 0.5)), Io(Q[D + 1])] } };
        var H;
      }
      function Or(Q, D, R) {
        const H = Q[D + er], se = H >= 1e4 ? `${Math.round(H / 1e3)}k` : H >= 1e3 ? Math.round(H / 100) / 10 + "k" : H, de = Q[D + Mn], ve = de === -1 ? {} : Object.assign({}, R[de]);
        return Object.assign(ve, { cluster: !0, cluster_id: Q[D + Zi], point_count: H, point_count_abbreviated: se });
      }
      function sr(Q) {
        return Q / 360 + 0.5;
      }
      function Un(Q) {
        const D = Math.sin(Q * Math.PI / 180), R = 0.5 - 0.25 * Math.log((1 + D) / (1 - D)) / Math.PI;
        return R < 0 ? 0 : R > 1 ? 1 : R;
      }
      function Io(Q) {
        const D = (180 - 360 * Q) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(D)) / Math.PI - 90;
      }
      function tr(Q, D, R, H) {
        for (var se, de = H, ve = R - D >> 1, xe = R - D, pe = Q[D], Me = Q[D + 1], Xe = Q[R], it = Q[R + 1], Ze = D + 3; Ze < R; Ze += 3) {
          var Bt = Wt(Q[Ze], Q[Ze + 1], pe, Me, Xe, it);
          if (Bt > de) se = Ze, de = Bt;
          else if (Bt === de) {
            var Lt = Math.abs(Ze - ve);
            Lt < xe && (se = Ze, xe = Lt);
          }
        }
        de > H && (se - D > 3 && tr(Q, D, se, H), Q[se + 2] = de, R - se > 3 && tr(Q, se, R, H));
      }
      function Wt(Q, D, R, H, se, de) {
        var ve = se - R, xe = de - H;
        if (ve !== 0 || xe !== 0) {
          var pe = ((Q - R) * ve + (D - H) * xe) / (ve * ve + xe * xe);
          pe > 1 ? (R = se, H = de) : pe > 0 && (R += ve * pe, H += xe * pe);
        }
        return (ve = Q - R) * ve + (xe = D - H) * xe;
      }
      function ei(Q, D, R, H) {
        var se = { id: Q === void 0 ? null : Q, type: D, geometry: R, tags: H, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(de) {
          var ve = de.geometry, xe = de.type;
          if (xe === "Point" || xe === "MultiPoint" || xe === "LineString") Yo(de, ve);
          else if (xe === "Polygon" || xe === "MultiLineString") for (var pe = 0; pe < ve.length; pe++) Yo(de, ve[pe]);
          else if (xe === "MultiPolygon") for (pe = 0; pe < ve.length; pe++) for (var Me = 0; Me < ve[pe].length; Me++) Yo(de, ve[pe][Me]);
        }(se), se;
      }
      function Yo(Q, D) {
        for (var R = 0; R < D.length; R += 3) Q.minX = Math.min(Q.minX, D[R]), Q.minY = Math.min(Q.minY, D[R + 1]), Q.maxX = Math.max(Q.maxX, D[R]), Q.maxY = Math.max(Q.maxY, D[R + 1]);
      }
      function qr(Q, D, R, H) {
        if (D.geometry) {
          var se = D.geometry.coordinates, de = D.geometry.type, ve = Math.pow(R.tolerance / ((1 << R.maxZoom) * R.extent), 2), xe = [], pe = D.id;
          if (R.promoteId ? pe = D.properties[R.promoteId] : R.generateId && (pe = H || 0), de === "Point") Nn(se, xe);
          else if (de === "MultiPoint") for (var Me = 0; Me < se.length; Me++) Nn(se[Me], xe);
          else if (de === "LineString") Ui(se, xe, ve, !1);
          else if (de === "MultiLineString") {
            if (R.lineMetrics) {
              for (Me = 0; Me < se.length; Me++) Ui(se[Me], xe = [], ve, !1), Q.push(ei(pe, "LineString", xe, D.properties));
              return;
            }
            oi(se, xe, ve, !1);
          } else if (de === "Polygon") oi(se, xe, ve, !0);
          else {
            if (de !== "MultiPolygon") {
              if (de === "GeometryCollection") {
                for (Me = 0; Me < D.geometry.geometries.length; Me++) qr(Q, { id: pe, geometry: D.geometry.geometries[Me], properties: D.properties }, R, H);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (Me = 0; Me < se.length; Me++) {
              var Xe = [];
              oi(se[Me], Xe, ve, !0), xe.push(Xe);
            }
          }
          Q.push(ei(pe, de, xe, D.properties));
        }
      }
      function Nn(Q, D) {
        D.push(ws(Q[0])), D.push(jn(Q[1])), D.push(0);
      }
      function Ui(Q, D, R, H) {
        for (var se, de, ve = 0, xe = 0; xe < Q.length; xe++) {
          var pe = ws(Q[xe][0]), Me = jn(Q[xe][1]);
          D.push(pe), D.push(Me), D.push(0), xe > 0 && (ve += H ? (se * Me - pe * de) / 2 : Math.sqrt(Math.pow(pe - se, 2) + Math.pow(Me - de, 2))), se = pe, de = Me;
        }
        var Xe = D.length - 3;
        D[2] = 1, tr(D, 0, Xe, R), D[Xe + 2] = 1, D.size = Math.abs(ve), D.start = 0, D.end = D.size;
      }
      function oi(Q, D, R, H) {
        for (var se = 0; se < Q.length; se++) {
          var de = [];
          Ui(Q[se], de, R, H), D.push(de);
        }
      }
      function ws(Q) {
        return Q / 360 + 0.5;
      }
      function jn(Q) {
        var D = Math.sin(Q * Math.PI / 180), R = 0.5 - 0.25 * Math.log((1 + D) / (1 - D)) / Math.PI;
        return R < 0 ? 0 : R > 1 ? 1 : R;
      }
      function Wr(Q, D, R, H, se, de, ve, xe) {
        if (H /= D, de >= (R /= D) && ve < H) return Q;
        if (ve < R || de >= H) return null;
        for (var pe = [], Me = 0; Me < Q.length; Me++) {
          var Xe = Q[Me], it = Xe.geometry, Ze = Xe.type, Bt = se === 0 ? Xe.minX : Xe.minY, Lt = se === 0 ? Xe.maxX : Xe.maxY;
          if (Bt >= R && Lt < H) pe.push(Xe);
          else if (!(Lt < R || Bt >= H)) {
            var Rt = [];
            if (Ze === "Point" || Ze === "MultiPoint") en(it, Rt, R, H, se);
            else if (Ze === "LineString") Qo(it, Rt, R, H, se, !1, xe.lineMetrics);
            else if (Ze === "MultiLineString") Vn(it, Rt, R, H, se, !1);
            else if (Ze === "Polygon") Vn(it, Rt, R, H, se, !0);
            else if (Ze === "MultiPolygon") for (var qt = 0; qt < it.length; qt++) {
              var Xt = [];
              Vn(it[qt], Xt, R, H, se, !0), Xt.length && Rt.push(Xt);
            }
            if (Rt.length) {
              if (xe.lineMetrics && Ze === "LineString") {
                for (qt = 0; qt < Rt.length; qt++) pe.push(ei(Xe.id, Ze, Rt[qt], Xe.tags));
                continue;
              }
              Ze !== "LineString" && Ze !== "MultiLineString" || (Rt.length === 1 ? (Ze = "LineString", Rt = Rt[0]) : Ze = "MultiLineString"), Ze !== "Point" && Ze !== "MultiPoint" || (Ze = Rt.length === 3 ? "Point" : "MultiPoint"), pe.push(ei(Xe.id, Ze, Rt, Xe.tags));
            }
          }
        }
        return pe.length ? pe : null;
      }
      function en(Q, D, R, H, se) {
        for (var de = 0; de < Q.length; de += 3) {
          var ve = Q[de + se];
          ve >= R && ve <= H && (D.push(Q[de]), D.push(Q[de + 1]), D.push(Q[de + 2]));
        }
      }
      function Qo(Q, D, R, H, se, de, ve) {
        for (var xe, pe, Me = Ts(Q), Xe = se === 0 ? Es : Cn, it = Q.start, Ze = 0; Ze < Q.length - 3; Ze += 3) {
          var Bt = Q[Ze], Lt = Q[Ze + 1], Rt = Q[Ze + 2], qt = Q[Ze + 3], Xt = Q[Ze + 4], bi = se === 0 ? Bt : Lt, Hi = se === 0 ? qt : Xt, ar = !1;
          ve && (xe = Math.sqrt(Math.pow(Bt - qt, 2) + Math.pow(Lt - Xt, 2))), bi < R ? Hi > R && (pe = Xe(Me, Bt, Lt, qt, Xt, R), ve && (Me.start = it + xe * pe)) : bi > H ? Hi < H && (pe = Xe(Me, Bt, Lt, qt, Xt, H), ve && (Me.start = it + xe * pe)) : Gn(Me, Bt, Lt, Rt), Hi < R && bi >= R && (pe = Xe(Me, Bt, Lt, qt, Xt, R), ar = !0), Hi > H && bi <= H && (pe = Xe(Me, Bt, Lt, qt, Xt, H), ar = !0), !de && ar && (ve && (Me.end = it + xe * pe), D.push(Me), Me = Ts(Q)), ve && (it += xe);
        }
        var qi = Q.length - 3;
        Bt = Q[qi], Lt = Q[qi + 1], Rt = Q[qi + 2], (bi = se === 0 ? Bt : Lt) >= R && bi <= H && Gn(Me, Bt, Lt, Rt), qi = Me.length - 3, de && qi >= 3 && (Me[qi] !== Me[0] || Me[qi + 1] !== Me[1]) && Gn(Me, Me[0], Me[1], Me[2]), Me.length && D.push(Me);
      }
      function Ts(Q) {
        var D = [];
        return D.size = Q.size, D.start = Q.start, D.end = Q.end, D;
      }
      function Vn(Q, D, R, H, se, de) {
        for (var ve = 0; ve < Q.length; ve++) Qo(Q[ve], D, R, H, se, de, !1);
      }
      function Gn(Q, D, R, H) {
        Q.push(D), Q.push(R), Q.push(H);
      }
      function Es(Q, D, R, H, se, de) {
        var ve = (de - D) / (H - D);
        return Q.push(de), Q.push(R + (se - R) * ve), Q.push(1), ve;
      }
      function Cn(Q, D, R, H, se, de) {
        var ve = (de - R) / (se - R);
        return Q.push(D + (H - D) * ve), Q.push(de), Q.push(1), ve;
      }
      function Br(Q, D) {
        for (var R = [], H = 0; H < Q.length; H++) {
          var se, de = Q[H], ve = de.type;
          if (ve === "Point" || ve === "MultiPoint" || ve === "LineString") se = mn(de.geometry, D);
          else if (ve === "MultiLineString" || ve === "Polygon") {
            se = [];
            for (var xe = 0; xe < de.geometry.length; xe++) se.push(mn(de.geometry[xe], D));
          } else if (ve === "MultiPolygon") for (se = [], xe = 0; xe < de.geometry.length; xe++) {
            for (var pe = [], Me = 0; Me < de.geometry[xe].length; Me++) pe.push(mn(de.geometry[xe][Me], D));
            se.push(pe);
          }
          R.push(ei(de.id, ve, se, de.tags));
        }
        return R;
      }
      function mn(Q, D) {
        var R = [];
        R.size = Q.size, Q.start !== void 0 && (R.start = Q.start, R.end = Q.end);
        for (var H = 0; H < Q.length; H += 3) R.push(Q[H] + D, Q[H + 1], Q[H + 2]);
        return R;
      }
      function Po(Q, D) {
        if (Q.transformed) return Q;
        var R, H, se, de = 1 << Q.z, ve = Q.x, xe = Q.y;
        for (R = 0; R < Q.features.length; R++) {
          var pe = Q.features[R], Me = pe.geometry, Xe = pe.type;
          if (pe.geometry = [], Xe === 1) for (H = 0; H < Me.length; H += 2) pe.geometry.push(_n(Me[H], Me[H + 1], D, de, ve, xe));
          else for (H = 0; H < Me.length; H++) {
            var it = [];
            for (se = 0; se < Me[H].length; se += 2) it.push(_n(Me[H][se], Me[H][se + 1], D, de, ve, xe));
            pe.geometry.push(it);
          }
        }
        return Q.transformed = !0, Q;
      }
      function _n(Q, D, R, H, se, de) {
        return [Math.round(R * (Q * H - se)), Math.round(R * (D * H - de))];
      }
      function $n(Q, D, R, H, se) {
        for (var de = D === se.maxZoom ? 0 : se.tolerance / ((1 << D) * se.extent), ve = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: R, y: H, z: D, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, xe = 0; xe < Q.length; xe++) {
          ve.numFeatures++, lo(ve, Q[xe], de, se);
          var pe = Q[xe].minX, Me = Q[xe].minY, Xe = Q[xe].maxX, it = Q[xe].maxY;
          pe < ve.minX && (ve.minX = pe), Me < ve.minY && (ve.minY = Me), Xe > ve.maxX && (ve.maxX = Xe), it > ve.maxY && (ve.maxY = it);
        }
        return ve;
      }
      function lo(Q, D, R, H) {
        var se = D.geometry, de = D.type, ve = [];
        if (de === "Point" || de === "MultiPoint") for (var xe = 0; xe < se.length; xe += 3) ve.push(se[xe]), ve.push(se[xe + 1]), Q.numPoints++, Q.numSimplified++;
        else if (de === "LineString") An(ve, se, Q, R, !1, !1);
        else if (de === "MultiLineString" || de === "Polygon") for (xe = 0; xe < se.length; xe++) An(ve, se[xe], Q, R, de === "Polygon", xe === 0);
        else if (de === "MultiPolygon") for (var pe = 0; pe < se.length; pe++) {
          var Me = se[pe];
          for (xe = 0; xe < Me.length; xe++) An(ve, Me[xe], Q, R, !0, xe === 0);
        }
        if (ve.length) {
          var Xe = D.tags || null;
          if (de === "LineString" && H.lineMetrics) {
            for (var it in Xe = {}, D.tags) Xe[it] = D.tags[it];
            Xe.mapbox_clip_start = se.start / se.size, Xe.mapbox_clip_end = se.end / se.size;
          }
          var Ze = { geometry: ve, type: de === "Polygon" || de === "MultiPolygon" ? 3 : de === "LineString" || de === "MultiLineString" ? 2 : 1, tags: Xe };
          D.id !== null && (Ze.id = D.id), Q.features.push(Ze);
        }
      }
      function An(Q, D, R, H, se, de) {
        var ve = H * H;
        if (H > 0 && D.size < (se ? ve : H)) R.numPoints += D.length / 3;
        else {
          for (var xe = [], pe = 0; pe < D.length; pe += 3) (H === 0 || D[pe + 2] > ve) && (R.numSimplified++, xe.push(D[pe]), xe.push(D[pe + 1])), R.numPoints++;
          se && function(Me, Xe) {
            for (var it = 0, Ze = 0, Bt = Me.length, Lt = Bt - 2; Ze < Bt; Lt = Ze, Ze += 2) it += (Me[Ze] - Me[Lt]) * (Me[Ze + 1] + Me[Lt + 1]);
            if (it > 0 === Xe) for (Ze = 0, Bt = Me.length; Ze < Bt / 2; Ze += 2) {
              var Rt = Me[Ze], qt = Me[Ze + 1];
              Me[Ze] = Me[Bt - 2 - Ze], Me[Ze + 1] = Me[Bt - 1 - Ze], Me[Bt - 2 - Ze] = Rt, Me[Bt - 1 - Ze] = qt;
            }
          }(xe, de), Q.push(xe);
        }
      }
      function co(Q, D) {
        var R = (D = this.options = function(se, de) {
          for (var ve in de) se[ve] = de[ve];
          return se;
        }(Object.create(this.options), D)).debug;
        if (R && console.time("preprocess data"), D.maxZoom < 0 || D.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
        if (D.promoteId && D.generateId) throw new Error("promoteId and generateId cannot be used together.");
        var H = function(se, de) {
          var ve = [];
          if (se.type === "FeatureCollection") for (var xe = 0; xe < se.features.length; xe++) qr(ve, se.features[xe], de, xe);
          else qr(ve, se.type === "Feature" ? se : { geometry: se }, de);
          return ve;
        }(Q, D);
        this.tiles = {}, this.tileCoords = [], R && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", D.indexMaxZoom, D.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), H = function(se, de) {
          var ve = de.buffer / de.extent, xe = se, pe = Wr(se, 1, -1 - ve, ve, 0, -1, 2, de), Me = Wr(se, 1, 1 - ve, 2 + ve, 0, -1, 2, de);
          return (pe || Me) && (xe = Wr(se, 1, -ve, 1 + ve, 0, -1, 2, de) || [], pe && (xe = Br(pe, 1).concat(xe)), Me && (xe = xe.concat(Br(Me, -1)))), xe;
        }(H, D), H.length && this.splitTile(H, 0, 0, 0), R && (H.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function Lo(Q, D, R) {
        return 32 * ((1 << Q) * R + D) + Q;
      }
      function tn(Q, D) {
        const R = Q.tileID.canonical;
        if (!this._geoJSONIndex) return D(null, null);
        const H = this._geoJSONIndex.getTile(R.z, R.x, R.y);
        if (!H) return D(null, null);
        const se = new class {
          constructor(ve) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = s.EXTENT, this.length = ve.length, this._features = ve;
          }
          feature(ve) {
            return new class {
              constructor(xe) {
                this._feature = xe, this.extent = s.EXTENT, this.type = xe.type, this.properties = xe.tags, "id" in xe && !isNaN(xe.id) && (this.id = parseInt(xe.id, 10));
              }
              loadGeometry() {
                if (this._feature.type === 1) {
                  const xe = [];
                  for (const pe of this._feature.geometry) xe.push([new s.Point(pe[0], pe[1])]);
                  return xe;
                }
                {
                  const xe = [];
                  for (const pe of this._feature.geometry) {
                    const Me = [];
                    for (const Xe of pe) Me.push(new s.Point(Xe[0], Xe[1]));
                    xe.push(Me);
                  }
                  return xe;
                }
              }
              toGeoJSON(xe, pe, Me) {
                return Ke.call(this, xe, pe, Me);
              }
            }(this._features[ve]);
          }
        }(H.features);
        let de = br(se);
        de.byteOffset === 0 && de.byteLength === de.buffer.byteLength || (de = new Uint8Array(de)), D(null, { vectorTile: se, rawData: de.buffer });
      }
      co.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, co.prototype.splitTile = function(Q, D, R, H, se, de, ve) {
        for (var xe = [Q, D, R, H], pe = this.options, Me = pe.debug; xe.length; ) {
          H = xe.pop(), R = xe.pop(), D = xe.pop(), Q = xe.pop();
          var Xe = 1 << D, it = Lo(D, R, H), Ze = this.tiles[it];
          if (!Ze && (Me > 1 && console.time("creation"), Ze = this.tiles[it] = $n(Q, D, R, H, pe), this.tileCoords.push({ z: D, x: R, y: H }), Me)) {
            Me > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", D, R, H, Ze.numFeatures, Ze.numPoints, Ze.numSimplified), console.timeEnd("creation"));
            var Bt = "z" + D;
            this.stats[Bt] = (this.stats[Bt] || 0) + 1, this.total++;
          }
          if (Ze.source = Q, se) {
            if (D === pe.maxZoom || D === se) continue;
            var Lt = 1 << se - D;
            if (R !== Math.floor(de / Lt) || H !== Math.floor(ve / Lt)) continue;
          } else if (D === pe.indexMaxZoom || Ze.numPoints <= pe.indexMaxPoints) continue;
          if (Ze.source = null, Q.length !== 0) {
            Me > 1 && console.time("clipping");
            var Rt, qt, Xt, bi, Hi, ar, qi = 0.5 * pe.buffer / pe.extent, In = 0.5 - qi, gr = 0.5 + qi, wi = 1 + qi;
            Rt = qt = Xt = bi = null, Hi = Wr(Q, Xe, R - qi, R + gr, 0, Ze.minX, Ze.maxX, pe), ar = Wr(Q, Xe, R + In, R + wi, 0, Ze.minX, Ze.maxX, pe), Q = null, Hi && (Rt = Wr(Hi, Xe, H - qi, H + gr, 1, Ze.minY, Ze.maxY, pe), qt = Wr(Hi, Xe, H + In, H + wi, 1, Ze.minY, Ze.maxY, pe), Hi = null), ar && (Xt = Wr(ar, Xe, H - qi, H + gr, 1, Ze.minY, Ze.maxY, pe), bi = Wr(ar, Xe, H + In, H + wi, 1, Ze.minY, Ze.maxY, pe), ar = null), Me > 1 && console.timeEnd("clipping"), xe.push(Rt || [], D + 1, 2 * R, 2 * H), xe.push(qt || [], D + 1, 2 * R, 2 * H + 1), xe.push(Xt || [], D + 1, 2 * R + 1, 2 * H), xe.push(bi || [], D + 1, 2 * R + 1, 2 * H + 1);
          }
        }
      }, co.prototype.getTile = function(Q, D, R) {
        var H = this.options, se = H.extent, de = H.debug;
        if (Q < 0 || Q > 24) return null;
        var ve = 1 << Q, xe = Lo(Q, D = (D % ve + ve) % ve, R);
        if (this.tiles[xe]) return Po(this.tiles[xe], se);
        de > 1 && console.log("drilling down to z%d-%d-%d", Q, D, R);
        for (var pe, Me = Q, Xe = D, it = R; !pe && Me > 0; ) Me--, Xe = Math.floor(Xe / 2), it = Math.floor(it / 2), pe = this.tiles[Lo(Me, Xe, it)];
        return pe && pe.source ? (de > 1 && console.log("found parent tile z%d-%d-%d", Me, Xe, it), de > 1 && console.time("drilling down"), this.splitTile(pe.source, Me, Xe, it, Q, D, R), de > 1 && console.timeEnd("drilling down"), this.tiles[xe] ? Po(this.tiles[xe], se) : null) : null;
      };
      class es extends s.VectorTileWorkerSource {
        constructor(D, R, H, se, de) {
          super(D, R, H, se, tn), de && (this.loadGeoJSON = de);
        }
        loadData(D, R) {
          const H = D && D.request, se = H && H.collectResourceTiming;
          this.loadGeoJSON(D, (de, ve) => {
            if (de || !ve) return R(de);
            if (typeof ve != "object") return R(new Error(`Input data given to '${D.source}' is not a valid GeoJSON object.`));
            {
              lt(ve, !0);
              try {
                if (D.filter) {
                  const pe = s.createExpression(D.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                  if (pe.result === "error") throw new Error(pe.value.map((Xe) => `${Xe.key}: ${Xe.message}`).join(", "));
                  ve = { type: "FeatureCollection", features: ve.features.filter((Xe) => pe.value.evaluate({ zoom: 0 }, Xe)) };
                }
                this._geoJSONIndex = D.cluster ? new si(function({ superclusterOptions: pe, clusterProperties: Me }) {
                  if (!Me || !pe) return pe;
                  const Xe = {}, it = {}, Ze = { accumulated: null, zoom: 0 }, Bt = { properties: null }, Lt = Object.keys(Me);
                  for (const Rt of Lt) {
                    const [qt, Xt] = Me[Rt], bi = s.createExpression(Xt), Hi = s.createExpression(typeof qt == "string" ? [qt, ["accumulated"], ["get", Rt]] : qt);
                    Xe[Rt] = bi.value, it[Rt] = Hi.value;
                  }
                  return pe.map = (Rt) => {
                    Bt.properties = Rt;
                    const qt = {};
                    for (const Xt of Lt) qt[Xt] = Xe[Xt].evaluate(Ze, Bt);
                    return qt;
                  }, pe.reduce = (Rt, qt) => {
                    Bt.properties = qt;
                    for (const Xt of Lt) Ze.accumulated = Rt[Xt], Rt[Xt] = it[Xt].evaluate(Ze, Bt);
                  }, pe;
                }(D)).load(ve.features) : function(pe, Me) {
                  return new co(pe, Me);
                }(ve, D.geojsonVtOptions);
              } catch (pe) {
                return R(pe);
              }
              this.loaded = {};
              const xe = {};
              if (se) {
                const pe = s.getPerformanceMeasurement(H);
                pe && (xe.resourceTiming = {}, xe.resourceTiming[D.source] = JSON.parse(JSON.stringify(pe)));
              }
              R(null, xe);
            }
          });
        }
        reloadTile(D, R) {
          const H = this.loaded;
          return H && H[D.uid] ? super.reloadTile(D, R) : this.loadTile(D, R);
        }
        loadGeoJSON(D, R) {
          if (D.request) s.getJSON(D.request, R);
          else {
            if (typeof D.data != "string") return R(new Error(`Input data given to '${D.source}' is not a valid GeoJSON object.`));
            try {
              return R(null, JSON.parse(D.data));
            } catch {
              return R(new Error(`Input data given to '${D.source}' is not a valid GeoJSON object.`));
            }
          }
        }
        getClusterExpansionZoom(D, R) {
          try {
            R(null, this._geoJSONIndex.getClusterExpansionZoom(D.clusterId));
          } catch (H) {
            R(H);
          }
        }
        getClusterChildren(D, R) {
          try {
            R(null, this._geoJSONIndex.getChildren(D.clusterId));
          } catch (H) {
            R(H);
          }
        }
        getClusterLeaves(D, R) {
          try {
            R(null, this._geoJSONIndex.getLeaves(D.clusterId, D.limit, D.offset));
          } catch (H) {
            R(H);
          }
        }
      }
      class ts {
        constructor(D) {
          this.self = D, this.actor = new s.Actor(D, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = s.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: s.VectorTileWorkerSource, geojson: es }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (R, H) => {
            if (this.workerSourceTypes[R]) throw new Error(`Worker source with name "${R}" already registered.`);
            this.workerSourceTypes[R] = H;
          }, this.self.registerRTLTextPlugin = (R) => {
            if (s.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
            s.plugin.applyArabicShaping = R.applyArabicShaping, s.plugin.processBidirectionalText = R.processBidirectionalText, s.plugin.processStyledBidirectionalText = R.processStyledBidirectionalText;
          };
        }
        clearCaches(D, R, H) {
          delete this.layerIndexes[D], delete this.availableImages[D], delete this.workerSources[D], delete this.demWorkerSources[D], H();
        }
        checkIfReady(D, R, H) {
          H();
        }
        setReferrer(D, R) {
          this.referrer = R;
        }
        spriteLoaded(D, R) {
          this.isSpriteLoaded[D] = R;
          for (const H in this.workerSources[D]) {
            const se = this.workerSources[D][H];
            for (const de in se) se[de] instanceof s.VectorTileWorkerSource && (se[de].isSpriteLoaded = R, se[de].fire(new s.Event("isSpriteLoaded")));
          }
        }
        setImages(D, R, H) {
          this.availableImages[D] = R;
          for (const se in this.workerSources[D]) {
            const de = this.workerSources[D][se];
            for (const ve in de) de[ve].availableImages = R;
          }
          H();
        }
        enableTerrain(D, R, H) {
          this.terrain = R, H();
        }
        setProjection(D, R) {
          this.projections[D] = s.getProjection(R);
        }
        setLayers(D, R, H) {
          this.getLayerIndex(D).replace(R), H();
        }
        updateLayers(D, R, H) {
          this.getLayerIndex(D).update(R.layers, R.removedIds), H();
        }
        loadTile(D, R, H) {
          const se = this.enableTerrain ? s.extend({ enableTerrain: this.terrain }, R) : R;
          se.projection = this.projections[D] || this.defaultProjection, this.getWorkerSource(D, R.type, R.source).loadTile(se, H);
        }
        loadDEMTile(D, R, H) {
          const se = this.enableTerrain ? s.extend({ buildQuadTree: this.terrain }, R) : R;
          this.getDEMWorkerSource(D, R.source).loadTile(se, H);
        }
        reloadTile(D, R, H) {
          const se = this.enableTerrain ? s.extend({ enableTerrain: this.terrain }, R) : R;
          se.projection = this.projections[D] || this.defaultProjection, this.getWorkerSource(D, R.type, R.source).reloadTile(se, H);
        }
        abortTile(D, R, H) {
          this.getWorkerSource(D, R.type, R.source).abortTile(R, H);
        }
        removeTile(D, R, H) {
          this.getWorkerSource(D, R.type, R.source).removeTile(R, H);
        }
        removeSource(D, R, H) {
          if (!this.workerSources[D] || !this.workerSources[D][R.type] || !this.workerSources[D][R.type][R.source]) return;
          const se = this.workerSources[D][R.type][R.source];
          delete this.workerSources[D][R.type][R.source], se.removeSource !== void 0 ? se.removeSource(R, H) : H();
        }
        loadWorkerSource(D, R, H) {
          try {
            this.self.importScripts(R.url), H();
          } catch (se) {
            H(se.toString());
          }
        }
        syncRTLPluginState(D, R, H) {
          try {
            s.plugin.setState(R);
            const se = s.plugin.getPluginURL();
            if (s.plugin.isLoaded() && !s.plugin.isParsed() && se != null) {
              this.self.importScripts(se);
              const de = s.plugin.isParsed();
              H(de ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${se}`), de);
            }
          } catch (se) {
            H(se.toString());
          }
        }
        getAvailableImages(D) {
          let R = this.availableImages[D];
          return R || (R = []), R;
        }
        getLayerIndex(D) {
          let R = this.layerIndexes[D];
          return R || (R = this.layerIndexes[D] = new Qe()), R;
        }
        getWorkerSource(D, R, H) {
          if (this.workerSources[D] || (this.workerSources[D] = {}), this.workerSources[D][R] || (this.workerSources[D][R] = {}), !this.workerSources[D][R][H]) {
            const se = { send: (de, ve, xe, pe, Me, Xe) => {
              this.actor.send(de, ve, xe, D, Me, Xe);
            }, scheduler: this.actor.scheduler };
            this.workerSources[D][R][H] = new this.workerSourceTypes[R](se, this.getLayerIndex(D), this.getAvailableImages(D), this.isSpriteLoaded[D]);
          }
          return this.workerSources[D][R][H];
        }
        getDEMWorkerSource(D, R) {
          return this.demWorkerSources[D] || (this.demWorkerSources[D] = {}), this.demWorkerSources[D][R] || (this.demWorkerSources[D][R] = new Ie()), this.demWorkerSources[D][R];
        }
        enforceCacheSizeLimit(D, R) {
          s.enforceCacheSizeLimit(R);
        }
        getWorkerPerformanceMetrics(D, R, H) {
          H(void 0, void 0);
        }
      }
      return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new ts(self)), ts;
    }), ee(["./shared"], function(s) {
      function re(l, r) {
        if (Array.isArray(l)) {
          if (!Array.isArray(r) || l.length !== r.length) return !1;
          for (let o = 0; o < l.length; o++) if (!re(l[o], r[o])) return !1;
          return !0;
        }
        if (typeof l == "object" && l !== null && r !== null) {
          if (typeof r != "object" || Object.keys(l).length !== Object.keys(r).length) return !1;
          for (const o in l) if (!re(l[o], r[o])) return !1;
          return !0;
        }
        return l === r;
      }
      var Be = Qe;
      function Qe(l) {
        return !function(r) {
          return typeof window > "u" || typeof document > "u" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
            var u, d, f = new Blob([""], { type: "text/javascript" }), g = URL.createObjectURL(f);
            try {
              d = new Worker(g), u = !0;
            } catch {
              u = !1;
            }
            return d && d.terminate(), URL.revokeObjectURL(g), u;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var u = document.createElement("canvas");
            u.width = u.height = 1;
            var d = u.getContext("2d");
            if (!d) return !1;
            var f = d.getImageData(0, 0, 1, 1);
            return f && f.width === u.width;
          }() ? (Ie[o = r && r.failIfMajorPerformanceCaveat] === void 0 && (Ie[o] = function(u) {
            var d, f = function(g) {
              var x = document.createElement("canvas"), b = Object.create(Qe.webGLContextAttributes);
              return b.failIfMajorPerformanceCaveat = g, x.getContext("webgl", b) || x.getContext("experimental-webgl", b);
            }(u);
            if (!f) return !1;
            try {
              d = f.createShader(f.VERTEX_SHADER);
            } catch {
              return !1;
            }
            return !(!d || f.isContextLost()) && (f.shaderSource(d, "void main() {}"), f.compileShader(d), f.getShaderParameter(d, f.COMPILE_STATUS) === !0);
          }(o)), Ie[o] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var o;
        }(l);
      }
      var Ie = {};
      function rt(l, r, o) {
        const u = s.window.document.createElement(l);
        return r !== void 0 && (u.className = r), o && o.appendChild(u), u;
      }
      function ut(l, r, o) {
        const u = s.window.document.createElementNS("http://www.w3.org/2000/svg", l);
        for (const d of Object.keys(r)) u.setAttributeNS(null, d, r[d]);
        return o && o.appendChild(u), u;
      }
      Qe.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
      const lt = s.window.document && s.window.document.documentElement.style, Ke = lt && lt.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
      let mt;
      function kt() {
        lt && Ke && (mt = lt[Ke], lt[Ke] = "none");
      }
      function Qt() {
        lt && Ke && (lt[Ke] = mt);
      }
      function St(l) {
        l.preventDefault(), l.stopPropagation(), s.window.removeEventListener("click", St, !0);
      }
      function It() {
        s.window.addEventListener("click", St, !0), s.window.setTimeout(() => {
          s.window.removeEventListener("click", St, !0);
        }, 0);
      }
      function ni(l, r) {
        const o = l.getBoundingClientRect();
        return $i(l, o, r);
      }
      function Qr(l, r) {
        const o = l.getBoundingClientRect(), u = [];
        for (let d = 0; d < r.length; d++) u.push($i(l, o, r[d]));
        return u;
      }
      function ui(l) {
        return s.window.InstallTrigger !== void 0 && l.button === 2 && l.ctrlKey && s.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : l.button;
      }
      function $i(l, r, o) {
        const u = l.offsetWidth === r.width ? 1 : l.offsetWidth / r.width;
        return new s.Point((o.clientX - r.left) * u, (o.clientY - r.top) * u);
      }
      function et(l, r) {
        var o = r[0], u = r[1], d = r[2], f = r[3], g = o * f - d * u;
        return g ? (l[0] = f * (g = 1 / g), l[1] = -u * g, l[2] = -d * g, l[3] = o * g, l) : null;
      }
      function Dr(l) {
        const { userImage: r } = l;
        return !!(r && r.render && r.render()) && (l.data.replace(new Uint8Array(r.data.buffer)), !0);
      }
      class or extends s.Evented {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new s.RGBAImage({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(r) {
          if (this.loaded !== r && (this.loaded = r, r)) {
            for (const { ids: o, callback: u } of this.requestors) this._notify(o, u);
            this.requestors = [];
          }
        }
        hasImage(r) {
          return !!this.getImage(r);
        }
        getImage(r) {
          return this.images[r];
        }
        addImage(r, o) {
          this._validate(r, o) && (this.images[r] = o);
        }
        _validate(r, o) {
          let u = !0;
          return this._validateStretch(o.stretchX, o.data && o.data.width) || (this.fire(new s.ErrorEvent(new Error(`Image "${r}" has invalid "stretchX" value`))), u = !1), this._validateStretch(o.stretchY, o.data && o.data.height) || (this.fire(new s.ErrorEvent(new Error(`Image "${r}" has invalid "stretchY" value`))), u = !1), this._validateContent(o.content, o) || (this.fire(new s.ErrorEvent(new Error(`Image "${r}" has invalid "content" value`))), u = !1), u;
        }
        _validateStretch(r, o) {
          if (!r) return !0;
          let u = 0;
          for (const d of r) {
            if (d[0] < u || d[1] < d[0] || o < d[1]) return !1;
            u = d[1];
          }
          return !0;
        }
        _validateContent(r, o) {
          return !(r && (r.length !== 4 || r[0] < 0 || o.data.width < r[0] || r[1] < 0 || o.data.height < r[1] || r[2] < 0 || o.data.width < r[2] || r[3] < 0 || o.data.height < r[3] || r[2] < r[0] || r[3] < r[1]));
        }
        updateImage(r, o) {
          o.version = this.images[r].version + 1, this.images[r] = o, this.updatedImages[r] = !0;
        }
        removeImage(r) {
          const o = this.images[r];
          delete this.images[r], delete this.patterns[r], o.userImage && o.userImage.onRemove && o.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(r, o) {
          let u = !0;
          if (!this.isLoaded()) for (const d of r) this.images[d] || (u = !1);
          this.isLoaded() || u ? this._notify(r, o) : this.requestors.push({ ids: r, callback: o });
        }
        _notify(r, o) {
          const u = {};
          for (const d of r) {
            this.images[d] || this.fire(new s.Event("styleimagemissing", { id: d }));
            const f = this.images[d];
            f ? u[d] = { data: f.data.clone(), pixelRatio: f.pixelRatio, sdf: f.sdf, version: f.version, stretchX: f.stretchX, stretchY: f.stretchY, content: f.content, hasRenderCallback: !!(f.userImage && f.userImage.render) } : s.warnOnce(`Image "${d}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          o(null, u);
        }
        getPixelSize() {
          const { width: r, height: o } = this.atlasImage;
          return { width: r, height: o };
        }
        getPattern(r) {
          const o = this.patterns[r], u = this.getImage(r);
          if (!u) return null;
          if (o && o.position.version === u.version) return o.position;
          if (o) o.position.version = u.version;
          else {
            const d = { w: u.data.width + 2, h: u.data.height + 2, x: 0, y: 0 }, f = new s.ImagePosition(d, u);
            this.patterns[r] = { bin: d, position: f };
          }
          return this._updatePatternAtlas(), this.patterns[r].position;
        }
        bind(r) {
          const o = r.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new s.Texture(r, this.atlasImage, o.RGBA), this.atlasTexture && this.atlasTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const r = [];
          for (const f in this.patterns) r.push(this.patterns[f].bin);
          const { w: o, h: u } = s.potpack(r), d = this.atlasImage;
          d.resize({ width: o || 1, height: u || 1 });
          for (const f in this.patterns) {
            const { bin: g } = this.patterns[f], x = g.x + 1, b = g.y + 1, M = this.images[f].data, S = M.width, P = M.height;
            s.RGBAImage.copy(M, d, { x: 0, y: 0 }, { x, y: b }, { width: S, height: P }), s.RGBAImage.copy(M, d, { x: 0, y: P - 1 }, { x, y: b - 1 }, { width: S, height: 1 }), s.RGBAImage.copy(M, d, { x: 0, y: 0 }, { x, y: b + P }, { width: S, height: 1 }), s.RGBAImage.copy(M, d, { x: S - 1, y: 0 }, { x: x - 1, y: b }, { width: 1, height: P }), s.RGBAImage.copy(M, d, { x: 0, y: 0 }, { x: x + S, y: b }, { width: 1, height: P });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(r) {
          for (const o of r) {
            if (this.callbackDispatchedThisFrame[o]) continue;
            this.callbackDispatchedThisFrame[o] = !0;
            const u = this.images[o];
            Dr(u) && this.updateImage(o, u);
          }
        }
      }
      const Pt = new s.Properties({ anchor: new s.DataConstantProperty(s.spec.light.anchor), position: new class {
        constructor() {
          this.specification = s.spec.light.position;
        }
        possiblyEvaluate(l, r) {
          return function([o, u, d]) {
            const f = s.degToRad(u + 90), g = s.degToRad(d);
            return { x: o * Math.cos(f) * Math.sin(g), y: o * Math.sin(f) * Math.sin(g), z: o * Math.cos(g), azimuthal: u, polar: d };
          }(l.expression.evaluate(r));
        }
        interpolate(l, r, o) {
          return { x: s.number(l.x, r.x, o), y: s.number(l.y, r.y, o), z: s.number(l.z, r.z, o), azimuthal: s.number(l.azimuthal, r.azimuthal, o), polar: s.number(l.polar, r.polar, o) };
        }
      }(), color: new s.DataConstantProperty(s.spec.light.color), intensity: new s.DataConstantProperty(s.spec.light.intensity) });
      class Fi extends s.Evented {
        constructor(r) {
          super(), this._transitionable = new s.Transitionable(Pt), this.setLight(r), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(r, o = {}) {
          if (!this._validate(s.validateLight, r, o)) for (const u in r) {
            const d = r[u];
            s.endsWith(u, "-transition") ? this._transitionable.setTransition(u.slice(0, -11), d) : this._transitionable.setValue(u, d);
          }
        }
        updateTransitions(r) {
          this._transitioning = this._transitionable.transitioned(r, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(r) {
          this.properties = this._transitioning.possiblyEvaluate(r);
        }
        _validate(r, o, u) {
          return (!u || u.validate !== !1) && s.emitValidationErrors(this, r.call(s.validateStyle, s.extend({ value: o, style: { glyphs: !0, sprite: !0 }, styleSpec: s.spec })));
        }
      }
      const Zr = new s.Properties({ source: new s.DataConstantProperty(s.spec.terrain.source), exaggeration: new s.DataConstantProperty(s.spec.terrain.exaggeration) });
      let Fn = class extends s.Evented {
        constructor(l, r) {
          super(), this._transitionable = new s.Transitionable(Zr), this.set(l), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = r;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(l) {
          for (const r in l) {
            const o = l[r];
            s.endsWith(r, "-transition") ? this._transitionable.setTransition(r.slice(0, -11), o) : this._transitionable.setValue(r, o);
          }
        }
        updateTransitions(l) {
          this._transitioning = this._transitionable.transitioned(l, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(l) {
          this.properties = this._transitioning.possiblyEvaluate(l);
        }
      };
      function br(l, r, o, u) {
        const d = s.smoothstep(45, 65, o), [f, g] = ao(l, u), x = s.length(r);
        let b = 1 - Math.min(1, Math.exp((x - f) / (g - f) * -6));
        return b *= b * b, b = Math.min(1, 1.00747 * b), b * d * l.alpha;
      }
      function ao(l, r) {
        const o = 0.5 / Math.tan(0.5 * r);
        return [l.range[0] + o, l.range[1] + o];
      }
      const Vt = new s.Properties({ range: new s.DataConstantProperty(s.spec.fog.range), color: new s.DataConstantProperty(s.spec.fog.color), "high-color": new s.DataConstantProperty(s.spec.fog["high-color"]), "space-color": new s.DataConstantProperty(s.spec.fog["space-color"]), "horizon-blend": new s.DataConstantProperty(s.spec.fog["horizon-blend"]), "star-intensity": new s.DataConstantProperty(s.spec.fog["star-intensity"]) });
      class Sn extends s.Evented {
        constructor(r, o) {
          super(), this._transitionable = new s.Transitionable(Vt), this.set(r), this._transitioning = this._transitionable.untransitioned(), this._transform = o;
        }
        get state() {
          const r = this._transform, o = r.projection.name === "globe", u = s.globeToMercatorTransition(r.zoom), d = this.properties.get("range"), f = [0.5, 3];
          return { range: o ? [s.number(f[0], d[0], u), s.number(f[1], d[1], u)] : d, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(r, o = {}) {
          if (!this._validate(s.validateFog, r, o)) {
            for (const u of Object.keys(s.spec.fog)) r && r[u] === void 0 && (r[u] = s.spec.fog[u].default);
            for (const u in r) {
              const d = r[u];
              s.endsWith(u, "-transition") ? this._transitionable.setTransition(u.slice(0, -11), d) : this._transitionable.setValue(u, d);
            }
          }
        }
        getOpacity(r) {
          if (!this._transform.projection.supportsFog) return 0;
          const o = this.properties && this.properties.get("color") || 1;
          return (this._transform.projection.name === "globe" ? 1 : s.smoothstep(45, 65, r)) * o.a;
        }
        getOpacityAtLatLng(r, o) {
          return this._transform.projection.supportsFog ? function(u, d, f) {
            const g = s.MercatorCoordinate.fromLngLat(d), x = f.elevation ? f.elevation.getAtPointOrZero(g) : 0, b = [g.x, g.y, x];
            return s.transformMat4(b, b, f.mercatorFogMatrix), br(u, b, f.pitch, f._fov);
          }(this.state, r, o) : 0;
        }
        getFovAdjustedRange(r) {
          return this._transform.projection.supportsFog ? ao(this.state, r) : [0, 1];
        }
        updateTransitions(r) {
          this._transitioning = this._transitionable.transitioned(r, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(r) {
          this.properties = this._transitioning.possiblyEvaluate(r);
        }
        _validate(r, o, u) {
          return (!u || u.validate !== !1) && s.emitValidationErrors(this, r.call(s.validateStyle, s.extend({ value: o, style: { glyphs: !0, sprite: !0 }, styleSpec: s.spec })));
        }
      }
      class Zi {
        constructor(r, o) {
          this.workerPool = r, this.actors = [], this.currentActor = 0, this.id = s.uniqueId();
          const u = this.workerPool.acquire(this.id);
          for (let d = 0; d < u.length; d++) {
            const f = new Zi.Actor(u[d], o, this.id);
            f.name = `Worker ${d}`, this.actors.push(f);
          }
          this.ready = !1, this.broadcast("checkIfReady", null, () => {
            this.ready = !0;
          });
        }
        broadcast(r, o, u) {
          s.asyncAll(this.actors, (d, f) => {
            d.send(r, o, f);
          }, u = u || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((r) => {
            r.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      function er(l, r, o) {
        return r * (s.EXTENT / (l.tileSize * Math.pow(2, o - l.tileID.overscaledZ)));
      }
      Zi.Actor = s.Actor;
      class Mn {
        constructor(r, o, u, d) {
          this.screenBounds = r, this.cameraPoint = o, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = u, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, d);
        }
        static createFromScreenPoints(r, o) {
          let u, d;
          if (r instanceof s.Point || typeof r[0] == "number") {
            const f = s.Point.convert(r);
            u = [f], d = o.isPointAboveHorizon(f);
          } else {
            const f = s.Point.convert(r[0]), g = s.Point.convert(r[1]);
            u = [f, g], d = s.polygonizeBounds(f, g).every((x) => o.isPointAboveHorizon(x));
          }
          return new Mn(u, o.getCameraPoint(), d, o);
        }
        isPointQuery() {
          return this.screenBounds.length === 1;
        }
        bufferedScreenGeometry(r) {
          return s.polygonizeBounds(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], r);
        }
        bufferedCameraGeometry(r) {
          const o = this.screenBounds[0], u = this.screenBounds.length === 1 ? this.screenBounds[0].add(new s.Point(1, 1)) : this.screenBounds[1], d = s.polygonizeBounds(o, u, 0, !1);
          return this.cameraPoint.y > u.y && (this.cameraPoint.x > o.x && this.cameraPoint.x < u.x ? d.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= u.x ? d[2] = this.cameraPoint : this.cameraPoint.x <= o.x && (d[3] = this.cameraPoint)), s.bufferConvexPolygon(d, r);
        }
        bufferedCameraGeometryGlobe(r) {
          const o = this.screenBounds[0], u = this.screenBounds.length === 1 ? this.screenBounds[0].add(new s.Point(1, 1)) : this.screenBounds[1], d = s.polygonizeBounds(o, u, r), f = this.cameraPoint.clone();
          switch (3 * ((f.y > o.y) + (f.y > u.y)) + ((f.x > o.x) + (f.x > u.x))) {
            case 0:
              d[0] = f, d[4] = f.clone();
              break;
            case 1:
              d.splice(1, 0, f);
              break;
            case 2:
              d[1] = f;
              break;
            case 3:
              d.splice(4, 0, f);
              break;
            case 5:
              d.splice(2, 0, f);
              break;
            case 6:
              d[3] = f;
              break;
            case 7:
              d.splice(3, 0, f);
              break;
            case 8:
              d[2] = f;
          }
          return d;
        }
        containsTile(r, o, u, d = 0) {
          const f = r.queryPadding / o._pixelsPerMercatorPixel + 1, g = u ? this._bufferedCameraMercator(f, o) : this._bufferedScreenMercator(f, o);
          let x = r.tileID.wrap + (g.unwrapped ? d : 0);
          const b = g.polygon.map((Z) => s.getTilePoint(r.tileTransform, Z, x));
          if (!s.polygonIntersectsBox(b, 0, 0, s.EXTENT, s.EXTENT)) return;
          x = r.tileID.wrap + (this.screenGeometryMercator.unwrapped ? d : 0);
          const M = this.screenGeometryMercator.polygon.map((Z) => s.getTileVec3(r.tileTransform, Z, x)), S = M.map((Z) => new s.Point(Z[0], Z[1])), P = o.getFreeCameraOptions().position || new s.MercatorCoordinate(0, 0, 0), F = s.getTileVec3(r.tileTransform, P, x), j = M.map((Z) => {
            const L = s.sub(Z, Z, F);
            return s.normalize(L, L), new s.Ray(F, L);
          }), $ = er(r, 1, o.zoom) * o._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: S, tilespaceRays: j, bufferedTilespaceGeometry: b, bufferedTilespaceBounds: (G = s.getBounds(b), G.min.x = s.clamp(G.min.x, 0, s.EXTENT), G.min.y = s.clamp(G.min.y, 0, s.EXTENT), G.max.x = s.clamp(G.max.x, 0, s.EXTENT), G.max.y = s.clamp(G.max.y, 0, s.EXTENT), G), tile: r, tileID: r.tileID, pixelToTileUnitsFactor: $ };
          var G;
        }
        _bufferedScreenMercator(r, o) {
          const u = Or(r);
          if (this._screenRaycastCache[u]) return this._screenRaycastCache[u];
          {
            let d;
            return d = o.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(r), o) : { polygon: this.bufferedScreenGeometry(r).map((f) => o.pointCoordinate3D(f)), unwrapped: !0 }, this._screenRaycastCache[u] = d, d;
          }
        }
        _bufferedCameraMercator(r, o) {
          const u = Or(r);
          if (this._cameraRaycastCache[u]) return this._cameraRaycastCache[u];
          {
            let d;
            return d = o.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(r), o) : { polygon: this.bufferedCameraGeometry(r).map((f) => o.pointCoordinate3D(f)), unwrapped: !0 }, this._cameraRaycastCache[u] = d, d;
          }
        }
        _projectAndResample(r, o) {
          const u = function(f, g) {
            const x = s.multiply([], g.pixelMatrix, g.globeMatrix), b = [0, -s.GLOBE_RADIUS, 0, 1], M = [0, s.GLOBE_RADIUS, 0, 1], S = [0, 0, 0, 1];
            s.transformMat4$1(b, b, x), s.transformMat4$1(M, M, x), s.transformMat4$1(S, S, x);
            const P = new s.Point(b[0] / b[3], b[1] / b[3]), F = new s.Point(M[0] / M[3], M[1] / M[3]), j = s.polygonContainsPoint(f, P) && b[3] < S[3], $ = s.polygonContainsPoint(f, F) && M[3] < S[3];
            if (!j && !$) return null;
            const G = function(ce, ge, me) {
              for (let Ee = 1; Ee < ce.length; Ee++) {
                const Ge = Rr(ge.pointCoordinate3D(ce[Ee - 1]).x), be = Rr(ge.pointCoordinate3D(ce[Ee]).x);
                if (me < 0) {
                  if (Ge < be) return { idx: Ee, t: -Ge / (be - 1 - Ge) };
                } else if (be < Ge) return { idx: Ee, t: (1 - Ge) / (be + 1 - Ge) };
              }
              return null;
            }(f, g, j ? -1 : 1);
            if (!G) return null;
            const { idx: Z, t: L } = G;
            let N = Z > 1 ? si(f.slice(0, Z), g) : [], X = Z < f.length ? si(f.slice(Z), g) : [];
            N = N.map((ce) => new s.Point(Rr(ce.x), ce.y)), X = X.map((ce) => new s.Point(Rr(ce.x), ce.y));
            const K = [...N];
            K.length === 0 && K.push(X[X.length - 1]);
            const le = s.number(K[K.length - 1].y, (X.length === 0 ? N[0] : X[0]).y, L);
            let ue;
            return ue = j ? [new s.Point(0, le), new s.Point(0, 0), new s.Point(1, 0), new s.Point(1, le)] : [new s.Point(1, le), new s.Point(1, 1), new s.Point(0, 1), new s.Point(0, le)], K.push(...ue), X.length === 0 ? K.push(N[0]) : K.push(...X), { polygon: K.map((ce) => new s.MercatorCoordinate(ce.x, ce.y)), unwrapped: !1 };
          }(r, o);
          if (u) return u;
          const d = function(f, g) {
            let x = !1, b = -1 / 0, M = 0;
            for (let P = 0; P < f.length - 1; P++) f[P].x > b && (b = f[P].x, M = P);
            for (let P = 0; P < f.length - 1; P++) {
              const F = (M + P) % (f.length - 1), j = f[F], $ = f[F + 1];
              Math.abs(j.x - $.x) > 0.5 && (j.x < $.x ? (j.x += 1, F === 0 && (f[f.length - 1].x += 1)) : ($.x += 1, F + 1 === f.length - 1 && (f[0].x += 1)), x = !0);
            }
            const S = s.mercatorXfromLng(g.center.lng);
            return x && S < Math.abs(S - 1) && f.forEach((P) => {
              P.x -= 1;
            }), { polygon: f, unwrapped: x };
          }(si(r, o).map((f) => new s.Point(Rr(f.x), f.y)), o);
          return { polygon: d.polygon.map((f) => new s.MercatorCoordinate(f.x, f.y)), unwrapped: d.unwrapped };
        }
      }
      function si(l, r) {
        return s.resample(l, (o) => {
          const u = r.pointCoordinate3D(o);
          o.x = u.x, o.y = u.y;
        }, 1 / 256);
      }
      function Rr(l) {
        return l < 0 ? 1 + l % 1 : l % 1;
      }
      function Or(l) {
        return 100 * l | 0;
      }
      function sr(l, r, o, u, d) {
        const f = function(g, x) {
          if (g) return d(g);
          if (x) {
            l.url && x.tiles && l.tiles && delete l.tiles;
            const b = s.pick(s.extend(x, l), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            x.vector_layers && (b.vectorLayers = x.vector_layers, b.vectorLayerIds = b.vectorLayers.map((M) => M.id)), b.tiles = r.canonicalizeTileset(b, l.url), d(null, b);
          }
        };
        return l.url ? s.getJSON(r.transformRequest(r.normalizeSourceURL(l.url, null, o, u), s.ResourceType.Source), f) : s.exported.frame(() => f(null, l));
      }
      class Un {
        constructor(r, o, u) {
          this.bounds = s.LngLatBounds.convert(this.validateBounds(r)), this.minzoom = o || 0, this.maxzoom = u || 24;
        }
        validateBounds(r) {
          return Array.isArray(r) && r.length === 4 ? [Math.max(-180, r[0]), Math.max(-90, r[1]), Math.min(180, r[2]), Math.min(90, r[3])] : [-180, -90, 180, 90];
        }
        contains(r) {
          const o = Math.pow(2, r.z), u = Math.floor(s.mercatorXfromLng(this.bounds.getWest()) * o), d = Math.floor(s.mercatorYfromLat(this.bounds.getNorth()) * o), f = Math.ceil(s.mercatorXfromLng(this.bounds.getEast()) * o), g = Math.ceil(s.mercatorYfromLat(this.bounds.getSouth()) * o);
          return r.x >= u && r.x < f && r.y >= d && r.y < g;
        }
      }
      class Io {
        constructor(r, o, u) {
          this.context = r;
          const d = r.gl;
          this.buffer = d.createBuffer(), this.dynamicDraw = !!u, this.context.unbindVAO(), r.bindElementBuffer.set(this.buffer), d.bufferData(d.ELEMENT_ARRAY_BUFFER, o.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || o.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(r) {
          const o = this.context.gl;
          this.context.unbindVAO(), this.bind(), o.bufferSubData(o.ELEMENT_ARRAY_BUFFER, 0, r.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const tr = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class Wt {
        constructor(r, o, u, d) {
          this.length = o.length, this.attributes = u, this.itemSize = o.bytesPerElement, this.dynamicDraw = d, this.context = r;
          const f = r.gl;
          this.buffer = f.createBuffer(), r.bindVertexBuffer.set(this.buffer), f.bufferData(f.ARRAY_BUFFER, o.arrayBuffer, this.dynamicDraw ? f.DYNAMIC_DRAW : f.STATIC_DRAW), this.dynamicDraw || o.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(r) {
          const o = this.context.gl;
          this.bind(), o.bufferSubData(o.ARRAY_BUFFER, 0, r.arrayBuffer);
        }
        enableAttributes(r, o) {
          for (let u = 0; u < this.attributes.length; u++) {
            const d = o.attributes[this.attributes[u].name];
            d !== void 0 && r.enableVertexAttribArray(d);
          }
        }
        setVertexAttribPointers(r, o, u) {
          for (let d = 0; d < this.attributes.length; d++) {
            const f = this.attributes[d], g = o.attributes[f.name];
            g !== void 0 && r.vertexAttribPointer(g, f.components, r[tr[f.type]], !1, this.itemSize, f.offset + this.itemSize * (u || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class ei {
        constructor(r) {
          this.gl = r.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(r) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class Yo extends ei {
        getDefault() {
          return s.Color.transparent;
        }
        set(r) {
          const o = this.current;
          (r.r !== o.r || r.g !== o.g || r.b !== o.b || r.a !== o.a || this.dirty) && (this.gl.clearColor(r.r, r.g, r.b, r.a), this.current = r, this.dirty = !1);
        }
      }
      class qr extends ei {
        getDefault() {
          return 1;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.clearDepth(r), this.current = r, this.dirty = !1);
        }
      }
      class Nn extends ei {
        getDefault() {
          return 0;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.clearStencil(r), this.current = r, this.dirty = !1);
        }
      }
      class Ui extends ei {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(r) {
          const o = this.current;
          (r[0] !== o[0] || r[1] !== o[1] || r[2] !== o[2] || r[3] !== o[3] || this.dirty) && (this.gl.colorMask(r[0], r[1], r[2], r[3]), this.current = r, this.dirty = !1);
        }
      }
      class oi extends ei {
        getDefault() {
          return !0;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.depthMask(r), this.current = r, this.dirty = !1);
        }
      }
      class ws extends ei {
        getDefault() {
          return 255;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.stencilMask(r), this.current = r, this.dirty = !1);
        }
      }
      class jn extends ei {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(r) {
          const o = this.current;
          (r.func !== o.func || r.ref !== o.ref || r.mask !== o.mask || this.dirty) && (this.gl.stencilFunc(r.func, r.ref, r.mask), this.current = r, this.dirty = !1);
        }
      }
      class Wr extends ei {
        getDefault() {
          const r = this.gl;
          return [r.KEEP, r.KEEP, r.KEEP];
        }
        set(r) {
          const o = this.current;
          (r[0] !== o[0] || r[1] !== o[1] || r[2] !== o[2] || this.dirty) && (this.gl.stencilOp(r[0], r[1], r[2]), this.current = r, this.dirty = !1);
        }
      }
      class en extends ei {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          r ? o.enable(o.STENCIL_TEST) : o.disable(o.STENCIL_TEST), this.current = r, this.dirty = !1;
        }
      }
      class Qo extends ei {
        getDefault() {
          return [0, 1];
        }
        set(r) {
          const o = this.current;
          (r[0] !== o[0] || r[1] !== o[1] || this.dirty) && (this.gl.depthRange(r[0], r[1]), this.current = r, this.dirty = !1);
        }
      }
      class Ts extends ei {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          r ? o.enable(o.DEPTH_TEST) : o.disable(o.DEPTH_TEST), this.current = r, this.dirty = !1;
        }
      }
      class Vn extends ei {
        getDefault() {
          return this.gl.LESS;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.depthFunc(r), this.current = r, this.dirty = !1);
        }
      }
      class Gn extends ei {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          r ? o.enable(o.BLEND) : o.disable(o.BLEND), this.current = r, this.dirty = !1;
        }
      }
      class Es extends ei {
        getDefault() {
          const r = this.gl;
          return [r.ONE, r.ZERO];
        }
        set(r) {
          const o = this.current;
          (r[0] !== o[0] || r[1] !== o[1] || this.dirty) && (this.gl.blendFunc(r[0], r[1]), this.current = r, this.dirty = !1);
        }
      }
      class Cn extends ei {
        getDefault() {
          return s.Color.transparent;
        }
        set(r) {
          const o = this.current;
          (r.r !== o.r || r.g !== o.g || r.b !== o.b || r.a !== o.a || this.dirty) && (this.gl.blendColor(r.r, r.g, r.b, r.a), this.current = r, this.dirty = !1);
        }
      }
      class Br extends ei {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.blendEquation(r), this.current = r, this.dirty = !1);
        }
      }
      class mn extends ei {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          r ? o.enable(o.CULL_FACE) : o.disable(o.CULL_FACE), this.current = r, this.dirty = !1;
        }
      }
      class Po extends ei {
        getDefault() {
          return this.gl.BACK;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.cullFace(r), this.current = r, this.dirty = !1);
        }
      }
      class _n extends ei {
        getDefault() {
          return this.gl.CCW;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.frontFace(r), this.current = r, this.dirty = !1);
        }
      }
      let $n, lo = class extends ei {
        getDefault() {
          return null;
        }
        set(l) {
          (l !== this.current || this.dirty) && (this.gl.useProgram(l), this.current = l, this.dirty = !1);
        }
      };
      class An extends ei {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(r) {
          (r !== this.current || this.dirty) && (this.gl.activeTexture(r), this.current = r, this.dirty = !1);
        }
      }
      class co extends ei {
        getDefault() {
          const r = this.gl;
          return [0, 0, r.drawingBufferWidth, r.drawingBufferHeight];
        }
        set(r) {
          const o = this.current;
          (r[0] !== o[0] || r[1] !== o[1] || r[2] !== o[2] || r[3] !== o[3] || this.dirty) && (this.gl.viewport(r[0], r[1], r[2], r[3]), this.current = r, this.dirty = !1);
        }
      }
      class Lo extends ei {
        getDefault() {
          return null;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          o.bindFramebuffer(o.FRAMEBUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class tn extends ei {
        getDefault() {
          return null;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          o.bindRenderbuffer(o.RENDERBUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class es extends ei {
        getDefault() {
          return null;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          o.bindTexture(o.TEXTURE_2D, r), this.current = r, this.dirty = !1;
        }
      }
      class ts extends ei {
        getDefault() {
          return null;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          o.bindBuffer(o.ARRAY_BUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class Q extends ei {
        getDefault() {
          return null;
        }
        set(r) {
          const o = this.gl;
          o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class D extends ei {
        constructor(r) {
          super(r), this.vao = r.extVertexArrayObject;
        }
        getDefault() {
          return null;
        }
        set(r) {
          this.vao && (r !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(r), this.current = r, this.dirty = !1);
        }
      }
      class R extends ei {
        getDefault() {
          return 4;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          o.pixelStorei(o.UNPACK_ALIGNMENT, r), this.current = r, this.dirty = !1;
        }
      }
      class H extends ei {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r), this.current = r, this.dirty = !1;
        }
      }
      class se extends ei {
        getDefault() {
          return !1;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          const o = this.gl;
          o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, r), this.current = r, this.dirty = !1;
        }
      }
      class de extends ei {
        constructor(r, o) {
          super(r), this.context = r, this.parent = o;
        }
        getDefault() {
          return null;
        }
      }
      class ve extends de {
        setDirty() {
          this.dirty = !0;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const o = this.gl;
          o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, r, 0), this.current = r, this.dirty = !1;
        }
      }
      class xe extends de {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(r) {
          if (r === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const o = this.gl;
          o.framebufferRenderbuffer(o.FRAMEBUFFER, this.attachment(), o.RENDERBUFFER, r), this.current = r, this.dirty = !1;
        }
      }
      class pe extends xe {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      class Me {
        constructor(r, o, u, d) {
          this.context = r, this.width = o, this.height = u;
          const f = this.framebuffer = r.gl.createFramebuffer();
          this.colorAttachment = new ve(r, f), d && (this.depthAttachment = new xe(r, f));
        }
        destroy() {
          const r = this.context.gl, o = this.colorAttachment.get();
          if (o && r.deleteTexture(o), this.depthAttachment) {
            const u = this.depthAttachment.get();
            u && r.deleteRenderbuffer(u);
          }
          r.deleteFramebuffer(this.framebuffer);
        }
      }
      class Xe {
        constructor(r, o = !1) {
          if (this.gl = r, this.isWebGL2 = o, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), o) {
            const u = r;
            this.extVertexArrayObject = { createVertexArrayOES: u.createVertexArray.bind(r), deleteVertexArrayOES: u.deleteVertexArray.bind(r), bindVertexArrayOES: u.bindVertexArray.bind(r) };
          }
          this.clearColor = new Yo(this), this.clearDepth = new qr(this), this.clearStencil = new Nn(this), this.colorMask = new Ui(this), this.depthMask = new oi(this), this.stencilMask = new ws(this), this.stencilFunc = new jn(this), this.stencilOp = new Wr(this), this.stencilTest = new en(this), this.depthRange = new Qo(this), this.depthTest = new Ts(this), this.depthFunc = new Vn(this), this.blend = new Gn(this), this.blendFunc = new Es(this), this.blendColor = new Cn(this), this.blendEquation = new Br(this), this.cullFace = new mn(this), this.cullFaceSide = new Po(this), this.frontFace = new _n(this), this.program = new lo(this), this.activeTexture = new An(this), this.viewport = new co(this), this.bindFramebuffer = new Lo(this), this.bindRenderbuffer = new tn(this), this.bindTexture = new es(this), this.bindVertexBuffer = new ts(this), this.bindElementBuffer = new Q(this), this.bindVertexArrayOES = this.extVertexArrayObject && new D(this), this.pixelStoreUnpack = new R(this), this.pixelStoreUnpackPremultiplyAlpha = new H(this), this.pixelStoreUnpackFlipY = new se(this), this.extTextureFilterAnisotropic = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = r.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extStandardDerivativesForceOff = !1, this.extDebugRendererInfo = r.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = r.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = r.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), o || (this.extTextureHalfFloat = r.getExtension("OES_texture_half_float")), (o || this.extTextureHalfFloat && r.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = r.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = o || r.getExtension("OES_standard_derivatives"), this.extTimerQuery = r.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE);
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(r, o) {
          return new Io(this, r, o);
        }
        createVertexBuffer(r, o, u) {
          return new Wt(this, r, o, u);
        }
        createRenderbuffer(r, o, u) {
          const d = this.gl, f = d.createRenderbuffer();
          return this.bindRenderbuffer.set(f), d.renderbufferStorage(d.RENDERBUFFER, r, o, u), this.bindRenderbuffer.set(null), f;
        }
        createFramebuffer(r, o, u) {
          return new Me(this, r, o, u);
        }
        clear({ color: r, depth: o, stencil: u }) {
          const d = this.gl;
          let f = 0;
          r && (f |= d.COLOR_BUFFER_BIT, this.clearColor.set(r), this.colorMask.set([!0, !0, !0, !0])), o !== void 0 && (f |= d.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(o), this.depthMask.set(!0)), u !== void 0 && (f |= d.STENCIL_BUFFER_BIT, this.clearStencil.set(u), this.stencilMask.set(255)), d.clear(f);
        }
        setCullFace(r) {
          r.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(r.mode), this.frontFace.set(r.frontFace));
        }
        setDepthMode(r) {
          r.func !== this.gl.ALWAYS || r.mask ? (this.depthTest.set(!0), this.depthFunc.set(r.func), this.depthMask.set(r.mask), this.depthRange.set(r.range)) : this.depthTest.set(!1);
        }
        setStencilMode(r) {
          r.test.func !== this.gl.ALWAYS || r.mask ? (this.stencilTest.set(!0), this.stencilMask.set(r.mask), this.stencilOp.set([r.fail, r.depthFail, r.pass]), this.stencilFunc.set({ func: r.test.func, ref: r.ref, mask: r.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(r) {
          re(r.blendFunction, s.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(r.blendFunction), this.blendColor.set(r.blendColor)), this.colorMask.set(r.mask);
        }
        unbindVAO() {
          this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
        }
      }
      class it extends s.Evented {
        constructor(r, o, u, d) {
          if (super(), this.id = r, this.dispatcher = u, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, s.extend(this, s.pick(o, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.extend({ type: "vector" }, o), this._collectResourceTiming = o.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(d), this._tileWorkers = {}, this._deduped = new s.DedupedRequest();
        }
        load(r) {
          this._loaded = !1, this.fire(new s.Event("dataloading", { dataType: "source" }));
          const o = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, u = this.map._worldview;
          this._tileJSONRequest = sr(this._options, this.map._requestManager, o, u, (d, f) => {
            this._tileJSONRequest = null, this._loaded = !0, d ? (o && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${o}`), u && u.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${u}`), this.fire(new s.ErrorEvent(d))) : f && (s.extend(this, f), f.bounds && (this.tileBounds = new Un(f.bounds, this.minzoom, this.maxzoom)), s.postTurnstileEvent(f.tiles, this.map._requestManager._customAccessToken), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "content" }))), r && r(d);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(r) {
          return !this.tileBounds || this.tileBounds.contains(r.canonical);
        }
        onAdd(r) {
          this.map = r, this.load();
        }
        reload() {
          this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
        }
        setTiles(r) {
          return this._options.tiles = r, this.reload(), this;
        }
        setUrl(r) {
          return this.url = r, this._options.url = r, this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return s.extend({}, this._options);
        }
        loadTile(r, o) {
          const u = this.map._requestManager.normalizeTileURL(r.tileID.canonical.url(this.tiles, this.scheme)), d = { request: this.map._requestManager.transformRequest(u, s.ResourceType.Tile), data: void 0, uid: r.uid, tileID: r.tileID, tileZoom: r.tileZoom, zoom: r.tileID.overscaledZ, tileSize: this.tileSize * r.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: s.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: r.isSymbolTile };
          if (d.request.collectResourceTiming = this._collectResourceTiming, r.actor && r.state !== "expired") r.state === "loading" ? r.reloadCallback = o : r.request = r.actor.send("reloadTile", d, f.bind(this));
          else if (r.actor = this._tileWorkers[u] = this._tileWorkers[u] || this.dispatcher.getActor(), this.dispatcher.ready) r.request = r.actor.send("loadTile", d, f.bind(this), void 0, !0);
          else {
            const g = s.loadVectorTile.call({ deduped: this._deduped }, d, (x, b) => {
              x || !b ? f.call(this, x) : (d.data = { cacheControl: b.cacheControl, expires: b.expires, rawData: b.rawData.slice(0) }, r.actor && r.actor.send("loadTile", d, f.bind(this), void 0, !0));
            }, !0);
            r.request = { cancel: g };
          }
          function f(g, x) {
            return delete r.request, r.aborted ? o(null) : g && g.status !== 404 ? o(g) : (x && x.resourceTiming && (r.resourceTiming = x.resourceTiming), this.map._refreshExpiredTiles && x && r.setExpiryData(x), r.loadVectorData(x, this.map.painter), s.cacheEntryPossiblyAdded(this.dispatcher), o(null), void (r.reloadCallback && (this.loadTile(r, r.reloadCallback), r.reloadCallback = null)));
          }
        }
        abortTile(r) {
          r.request && (r.request.cancel(), delete r.request), r.actor && r.actor.send("abortTile", { uid: r.uid, type: this.type, source: this.id });
        }
        unloadTile(r) {
          r.unloadVectorData(), r.actor && r.actor.send("removeTile", { uid: r.uid, type: this.type, source: this.id });
        }
        hasTransition() {
          return !1;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class Ze extends s.Evented {
        constructor(r, o, u, d) {
          super(), this.id = r, this.dispatcher = u, this.setEventedParent(d), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = s.extend({ type: "raster" }, o), s.extend(this, s.pick(o, ["url", "scheme", "tileSize"]));
        }
        load(r) {
          this._loaded = !1, this.fire(new s.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = sr(this._options, this.map._requestManager, null, null, (o, u) => {
            this._tileJSONRequest = null, this._loaded = !0, o ? this.fire(new s.ErrorEvent(o)) : u && (s.extend(this, u), u.bounds && (this.tileBounds = new Un(u.bounds, this.minzoom, this.maxzoom)), s.postTurnstileEvent(u.tiles), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "content" }))), r && r(o);
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(r) {
          this.map = r, this.load();
        }
        reload() {
          this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
        }
        setTiles(r) {
          return this._options.tiles = r, this.reload(), this;
        }
        setUrl(r) {
          return this.url = r, this._options.url = r, this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return s.extend({}, this._options);
        }
        hasTile(r) {
          return !this.tileBounds || this.tileBounds.contains(r.canonical);
        }
        loadTile(r, o) {
          const u = s.exported.devicePixelRatio >= 2, d = this.map._requestManager.normalizeTileURL(r.tileID.canonical.url(this.tiles, this.scheme), u, this.tileSize);
          r.request = s.getImage(this.map._requestManager.transformRequest(d, s.ResourceType.Tile), (f, g, x, b) => (delete r.request, r.aborted ? (r.state = "unloaded", o(null)) : f ? (r.state = "errored", o(f)) : g ? (this.map._refreshExpiredTiles && r.setExpiryData({ cacheControl: x, expires: b }), r.setTexture(g, this.map.painter), r.state = "loaded", s.cacheEntryPossiblyAdded(this.dispatcher), void o(null)) : o(null)));
        }
        static loadTileData(r, o, u) {
          r.setTexture(o, u);
        }
        static unloadTileData(r, o) {
          r.texture && o.saveTileTexture(r.texture);
        }
        abortTile(r, o) {
          r.request && (r.request.cancel(), delete r.request), o();
        }
        unloadTile(r, o) {
          r.texture && this.map.painter.saveTileTexture(r.texture), o();
        }
        hasTransition() {
          return !1;
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      function Bt(l, r, o, u, d, f, g, x) {
        const b = [l, o, d, r, u, f, 1, 1, 1], M = [g, x, 1], S = s.adjoint([], b), [P, F, j] = s.transformMat3(M, M, s.transpose(S, S));
        return s.multiply$1(b, [P, 0, 0, 0, F, 0, 0, 0, j], b);
      }
      class Lt extends s.Evented {
        constructor(r, o, u, d) {
          super(), this.id = r, this.dispatcher = u, this.coordinates = o.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(d), this.options = o, this._dirty = !1;
        }
        load(r, o) {
          this._loaded = o || !1, this.fire(new s.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._imageRequest = s.getImage(this.map._requestManager.transformRequest(this.url, s.ResourceType.Image), (u, d) => {
            if (this._imageRequest = null, this._loaded = !0, u) this.fire(new s.ErrorEvent(u));
            else if (d) {
              const { HTMLImageElement: f } = s.window;
              this.image = d instanceof f ? s.exported.getImageData(d) : d, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, r && (this.coordinates = r), this._finishLoading();
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(r) {
          return this.image && r.url ? (this._imageRequest && r.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = r.url, this.load(r.coordinates, this._loaded), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(r) {
          this.map = r, this.load();
        }
        onRemove() {
          this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
        }
        setCoordinates(r) {
          this.coordinates = r, this._boundsArray = void 0;
          const o = r.map(s.MercatorCoordinate.fromLngLat);
          return this.tileID = function(u) {
            let d = 1 / 0, f = 1 / 0, g = -1 / 0, x = -1 / 0;
            for (const P of u) d = Math.min(d, P.x), f = Math.min(f, P.y), g = Math.max(g, P.x), x = Math.max(x, P.y);
            const b = Math.max(g - d, x - f), M = Math.max(0, Math.floor(-Math.log(b) / Math.LN2)), S = Math.pow(2, M);
            return new s.CanonicalTileID(M, Math.floor((d + g) / 2 * S), Math.floor((f + x) / 2 * S));
          }(o), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new s.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0;
        }
        _prepareData(r) {
          for (const b in this.tiles) {
            const M = this.tiles[b];
            M.state !== "loaded" && (M.state = "loaded", M.texture = this.texture);
          }
          if (this._boundsArray) return;
          const o = s.tileTransform(this.tileID, this.map.transform.projection), [u, d, f, g] = this.coordinates.map((b) => {
            const M = o.projection.project(b[0], b[1]);
            return s.getTilePoint(o, M)._round();
          });
          this.perspectiveTransform = function(b, M, S, P, F, j, $, G, Z, L) {
            const N = Bt(0, 0, b, 0, 0, M, b, M), X = Bt(S, P, F, j, $, G, Z, L);
            return s.multiply$1(X, s.adjoint(N, N), X), [X[6] / X[8] * b / s.EXTENT, X[7] / X[8] * M / s.EXTENT];
          }(this.width, this.height, u.x, u.y, d.x, d.y, g.x, g.y, f.x, f.y);
          const x = this._boundsArray = new s.StructArrayLayout4i8();
          x.emplaceBack(u.x, u.y, 0, 0), x.emplaceBack(d.x, d.y, s.EXTENT, 0), x.emplaceBack(g.x, g.y, 0, s.EXTENT), x.emplaceBack(f.x, f.y, s.EXTENT, s.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = r.createVertexBuffer(x, s.boundsAttributes.members), this.boundsSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2);
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const r = this.map.painter.context, o = r.gl;
          this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new s.Texture(r, this.image, o.RGBA), this.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE)), this._dirty = !1), this._prepareData(r);
        }
        loadTile(r, o) {
          this.tileID && this.tileID.equals(r.tileID.canonical) ? (this.tiles[String(r.tileID.wrap)] = r, r.buckets = {}, o(null)) : (r.state = "errored", o(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      const Rt = { vector: it, raster: Ze, "raster-dem": class extends Ze {
        constructor(l, r, o, u) {
          super(l, r, o, u), this.type = "raster-dem", this.maxzoom = 22, this._options = s.extend({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox";
        }
        loadTile(l, r) {
          const o = this.map._requestManager.normalizeTileURL(l.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
          function u(d, f) {
            d && (l.state = "errored", r(d)), f && (l.dem = f, l.dem.onDeserialize(), l.needsHillshadePrepare = !0, l.needsDEMTextureUpload = !0, l.state = "loaded", r(null));
          }
          l.request = s.getImage(this.map._requestManager.transformRequest(o, s.ResourceType.Tile), (function(d, f, g, x) {
            if (delete l.request, l.aborted) l.state = "unloaded", r(null);
            else if (d) l.state = "errored", r(d);
            else if (f) {
              this.map._refreshExpiredTiles && l.setExpiryData({ cacheControl: g, expires: x });
              const b = s.window.ImageBitmap && f instanceof s.window.ImageBitmap && ($n == null && ($n = s.window.OffscreenCanvas && new s.window.OffscreenCanvas(1, 1).getContext("2d") && typeof s.window.createImageBitmap == "function"), $n), M = 1 - (f.width - s.prevPowerOfTwo(f.width)) / 2;
              M < 1 || l.neighboringTiles || (l.neighboringTiles = this._getNeighboringTiles(l.tileID));
              const S = b ? f : s.exported.getImageData(f, M), P = { uid: l.uid, coord: l.tileID, source: this.id, rawImageData: S, encoding: this.encoding, padding: M };
              l.actor && l.state !== "expired" || (l.actor = this.dispatcher.getActor(), l.actor.send("loadDEMTile", P, u.bind(this), void 0, !0));
            }
          }).bind(this));
        }
        _getNeighboringTiles(l) {
          const r = l.canonical, o = Math.pow(2, r.z), u = (r.x - 1 + o) % o, d = r.x === 0 ? l.wrap - 1 : l.wrap, f = (r.x + 1 + o) % o, g = r.x + 1 === o ? l.wrap + 1 : l.wrap, x = {};
          return x[new s.OverscaledTileID(l.overscaledZ, d, r.z, u, r.y).key] = { backfilled: !1 }, x[new s.OverscaledTileID(l.overscaledZ, g, r.z, f, r.y).key] = { backfilled: !1 }, r.y > 0 && (x[new s.OverscaledTileID(l.overscaledZ, d, r.z, u, r.y - 1).key] = { backfilled: !1 }, x[new s.OverscaledTileID(l.overscaledZ, l.wrap, r.z, r.x, r.y - 1).key] = { backfilled: !1 }, x[new s.OverscaledTileID(l.overscaledZ, g, r.z, f, r.y - 1).key] = { backfilled: !1 }), r.y + 1 < o && (x[new s.OverscaledTileID(l.overscaledZ, d, r.z, u, r.y + 1).key] = { backfilled: !1 }, x[new s.OverscaledTileID(l.overscaledZ, l.wrap, r.z, r.x, r.y + 1).key] = { backfilled: !1 }, x[new s.OverscaledTileID(l.overscaledZ, g, r.z, f, r.y + 1).key] = { backfilled: !1 }), x;
        }
        unloadTile(l) {
          l.demTexture && this.map.painter.saveTileTexture(l.demTexture), l.fbo && (l.fbo.destroy(), delete l.fbo), l.dem && delete l.dem, delete l.neighboringTiles, l.state = "unloaded";
        }
      }, geojson: class extends s.Evented {
        constructor(l, r, o, u) {
          super(), this.id = l, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(u), this._data = r.data, this._options = s.extend({}, r), this._collectResourceTiming = r.collectResourceTiming, r.maxzoom !== void 0 && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId;
          const d = s.EXTENT / this.tileSize;
          this.workerOptions = s.extend({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: (r.buffer !== void 0 ? r.buffer : 128) * d, tolerance: (r.tolerance !== void 0 ? r.tolerance : 0.375) * d, extent: s.EXTENT, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: r.clusterMaxZoom !== void 0 ? r.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, r.clusterMinPoints || 2), extent: s.EXTENT, radius: (r.clusterRadius !== void 0 ? r.clusterRadius : 50) * d, log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions);
        }
        onAdd(l) {
          this.map = l, this.setData(this._data);
        }
        setData(l) {
          return this._data = l, this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(l, r) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: l, source: this.id }, r), this;
        }
        getClusterChildren(l, r) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: l, source: this.id }, r), this;
        }
        getClusterLeaves(l, r, o, u) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: l, limit: r, offset: o }, u), this;
        }
        _updateWorkerData() {
          if (this._pendingLoad) return void (this._coalesce = !0);
          this.fire(new s.Event("dataloading", { dataType: "source" })), this._loaded = !1;
          const l = s.extend({}, this.workerOptions), r = this._data;
          typeof r == "string" ? (l.request = this.map._requestManager.transformRequest(s.exported.resolveURL(r), s.ResourceType.Source), l.request.collectResourceTiming = this._collectResourceTiming) : l.data = JSON.stringify(r), this._pendingLoad = this.actor.send(`${this.type}.loadData`, l, (o, u) => {
            if (this._loaded = !0, this._pendingLoad = null, o) this.fire(new s.ErrorEvent(o));
            else {
              const d = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && u && u.resourceTiming && u.resourceTiming[this.id] && (d.resourceTiming = u.resourceTiming[this.id]), this.fire(new s.Event("data", d)), this._metadataFired = !0;
            }
            this._coalesce && (this._updateWorkerData(), this._coalesce = !1);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(l, r) {
          const o = l.actor ? "reloadTile" : "loadTile";
          l.actor = this.actor, l.request = this.actor.send(o, { type: this.type, uid: l.uid, tileID: l.tileID, tileZoom: l.tileZoom, zoom: l.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: s.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (u, d) => (delete l.request, l.unloadVectorData(), l.aborted ? r(null) : u ? r(u) : (l.loadVectorData(d, this.map.painter, o === "reloadTile"), r(null))), void 0, o === "loadTile");
        }
        abortTile(l) {
          l.request && (l.request.cancel(), delete l.request), l.aborted = !0;
        }
        unloadTile(l) {
          l.unloadVectorData(), this.actor.send("removeTile", { uid: l.uid, type: this.type, source: this.id });
        }
        onRemove() {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return s.extend({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }, video: class extends Lt {
        constructor(l, r, o, u) {
          super(l, r, o, u), this.roundZoom = !0, this.type = "video", this.options = r;
        }
        load() {
          this._loaded = !1;
          const l = this.options;
          this.urls = [];
          for (const r of l.urls) this.urls.push(this.map._requestManager.transformRequest(r, s.ResourceType.Source).url);
          s.getVideo(this.urls, (r, o) => {
            this._loaded = !0, r ? this.fire(new s.ErrorEvent(r)) : o && (this.video = o, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(l) {
          if (this.video) {
            const r = this.video.seekable;
            l < r.start(0) || l > r.end(0) ? this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = l;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(l) {
          this.map || (this.map = l, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const l = this.map.painter.context, r = l.gl;
          this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new s.Texture(l, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(l);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: Lt, canvas: class extends Lt {
        constructor(l, r, o, u) {
          super(l, r, o, u), r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some((d) => !Array.isArray(d) || d.length !== 2 || d.some((f) => typeof f != "number")) || this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${l}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${l}`, null, 'missing required property "coordinates"'))), r.animate && typeof r.animate != "boolean" && this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${l}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? typeof r.canvas == "string" || r.canvas instanceof s.window.HTMLCanvasElement || this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${l}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${l}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = r.animate === void 0 || r.animate;
        }
        load() {
          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof s.window.HTMLCanvasElement ? this.options.canvas : s.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = !0, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = !1);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(l) {
          this.map = l, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let l = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, l = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, l = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const r = this.map.painter.context;
          this.texture ? (l || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new s.Texture(r, this.canvas, r.gl.RGBA, { premultiply: !0 }), this._prepareData(r);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const l of [this.canvas.width, this.canvas.height]) if (isNaN(l) || l <= 0) return !0;
          return !1;
        }
      }, custom: class extends s.Evented {
        constructor(l, r, o, u) {
          super(), this.id = l, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = r, this.setEventedParent(u), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new s.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new s.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Un(this._implementation.bounds, this.minzoom, this.maxzoom)), r.update = this._update.bind(this), r.clearTiles = this._clearTiles.bind(this), r.coveringTiles = this._coveringTiles.bind(this), s.extend(this, s.pick(r, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return s.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = !0, this.fire(new s.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(l) {
          this._map = l, this._loaded = !1, this.fire(new s.Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(l), this.load();
        }
        onRemove(l) {
          this._implementation.onRemove && this._implementation.onRemove(l);
        }
        hasTile(l) {
          if (this._implementation.hasTile) {
            const { x: r, y: o, z: u } = l.canonical;
            return this._implementation.hasTile({ x: r, y: o, z: u });
          }
          return !this.tileBounds || this.tileBounds.contains(l.canonical);
        }
        loadTile(l, r) {
          const { x: o, y: u, z: d } = l.tileID.canonical, f = new s.window.AbortController();
          l.request = Promise.resolve(this._implementation.loadTile({ x: o, y: u, z: d }, { signal: f.signal })).then((function(g) {
            return delete l.request, l.aborted ? (l.state = "unloaded", r(null)) : g === void 0 ? (l.state = "errored", r(null)) : g === null ? (this.loadTileData(l, { width: this.tileSize, height: this.tileSize, data: null }), l.state = "loaded", r(null)) : function(x) {
              return x instanceof s.window.ImageData || x instanceof s.window.HTMLCanvasElement || x instanceof s.window.ImageBitmap || x instanceof s.window.HTMLImageElement;
            }(g) ? (this.loadTileData(l, g), l.state = "loaded", void r(null)) : (l.state = "errored", r(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
          }).bind(this)).catch((g) => {
            g.code !== 20 && (l.state = "errored", r(g));
          }), l.request.cancel = () => f.abort();
        }
        loadTileData(l, r) {
          Ze.loadTileData(l, r, this._map.painter);
        }
        unloadTileData(l) {
          Ze.unloadTileData(l, this._map.painter);
        }
        unloadTile(l, r) {
          if (this.unloadTileData(l), this._implementation.unloadTile) {
            const { x: o, y: u, z: d } = l.tileID.canonical;
            this._implementation.unloadTile({ x: o, y: u, z: d });
          }
          r();
        }
        abortTile(l, r) {
          l.request && l.request.cancel && (l.request.cancel(), delete l.request), r();
        }
        hasTransition() {
          return !1;
        }
        _coveringTiles() {
          return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((l) => ({ x: l.canonical.x, y: l.canonical.y, z: l.canonical.z }));
        }
        _clearTiles() {
          this._map.style._clearSource(this.id);
        }
        _update() {
          this.fire(new s.Event("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, qt = function(l, r, o, u) {
        const d = new Rt[r.type](l, r, o, u);
        if (d.id !== l) throw new Error(`Expected Source id to be ${l} instead of ${d.id}`);
        return s.bindAll(["load", "abort", "unload", "serialize", "prepare"], d), d;
      };
      function Xt(l, r) {
        const o = s.identity([]);
        return s.scale(o, o, [0.5 * l.width, 0.5 * -l.height, 1]), s.translate(o, o, [1, -1, 0]), s.multiply(o, o, l.calculateProjMatrix(r.toUnwrapped())), Float32Array.from(o);
      }
      function bi(l, r, o, u, d, f, g, x = !1) {
        const b = l.tilesIn(u, g, x);
        b.sort(ar);
        const M = [];
        for (const P of b) M.push({ wrappedTileID: P.tile.tileID.wrapped().key, queryResults: P.tile.queryRenderedFeatures(r, o, l._state, P, d, f, Xt(l.transform, P.tile.tileID), x) });
        const S = function(P) {
          const F = {}, j = {};
          for (const $ of P) {
            const G = $.queryResults, Z = $.wrappedTileID, L = j[Z] = j[Z] || {};
            for (const N in G) {
              const X = G[N], K = L[N] = L[N] || {}, le = F[N] = F[N] || [];
              for (const ue of X) K[ue.featureIndex] || (K[ue.featureIndex] = !0, le.push(ue));
            }
          }
          return F;
        }(M);
        for (const P in S) S[P].forEach((F) => {
          const j = F.feature, $ = j.layer;
          $ && $.type !== "background" && $.type !== "sky" && (j.source = $.source, $["source-layer"] && (j.sourceLayer = $["source-layer"]), j.state = j.id !== void 0 ? l.getFeatureState($["source-layer"], j.id) : {});
        });
        return S;
      }
      function Hi(l, r) {
        const o = l.getRenderableIds().map((f) => l.getTileByID(f)), u = [], d = {};
        for (let f = 0; f < o.length; f++) {
          const g = o[f], x = g.tileID.canonical.key;
          d[x] || (d[x] = !0, g.querySourceFeatures(u, r));
        }
        return u;
      }
      function ar(l, r) {
        const o = l.tileID, u = r.tileID;
        return o.overscaledZ - u.overscaledZ || o.canonical.y - u.canonical.y || o.wrap - u.wrap || o.canonical.x - u.canonical.x;
      }
      function qi() {
        return pa.workerClass != null ? new pa.workerClass() : new s.window.Worker(pa.workerUrl);
      }
      const In = "mapboxgl_preloaded_worker_pool";
      class gr {
        constructor() {
          this.active = {};
        }
        acquire(r) {
          if (!this.workers) for (this.workers = []; this.workers.length < gr.workerCount; ) this.workers.push(new qi());
          return this.active[r] = !0, this.workers.slice();
        }
        release(r) {
          delete this.active[r], this.numActive() === 0 && (this.workers.forEach((o) => {
            o.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[In];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let wi;
      function is() {
        return wi || (wi = new gr()), wi;
      }
      function hc(l, r) {
        const o = {};
        for (const u in l) u !== "ref" && (o[u] = l[u]);
        return s.refProperties.forEach((u) => {
          u in r && (o[u] = r[u]);
        }), o;
      }
      function yl(l) {
        l = l.slice();
        const r = /* @__PURE__ */ Object.create(null);
        for (let o = 0; o < l.length; o++) r[l[o].id] = l[o];
        for (let o = 0; o < l.length; o++) "ref" in l[o] && (l[o] = hc(l[o], r[l[o].ref]));
        return l;
      }
      gr.workerCount = 2;
      const ai = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };
      function Ma(l, r, o) {
        o.push({ command: ai.addSource, args: [l, r[l]] });
      }
      function zo(l, r, o) {
        r.push({ command: ai.removeSource, args: [l] }), o[l] = !0;
      }
      function Ca(l, r, o, u) {
        zo(l, o, u), Ma(l, r, o);
      }
      function ko(l, r, o) {
        let u;
        for (u in l[o]) if (l[o].hasOwnProperty(u) && u !== "data" && !re(l[o][u], r[o][u])) return !1;
        for (u in r[o]) if (r[o].hasOwnProperty(u) && u !== "data" && !re(l[o][u], r[o][u])) return !1;
        return !0;
      }
      function rn(l, r, o, u, d, f) {
        let g;
        for (g in r = r || {}, l = l || {}) l.hasOwnProperty(g) && (re(l[g], r[g]) || o.push({ command: f, args: [u, g, r[g], d] }));
        for (g in r) r.hasOwnProperty(g) && !l.hasOwnProperty(g) && (re(l[g], r[g]) || o.push({ command: f, args: [u, g, r[g], d] }));
      }
      function gn(l) {
        return l.id;
      }
      function Yi(l, r) {
        return l[r.id] = r, l;
      }
      class Ks {
        constructor(r, o) {
          this.reset(r, o);
        }
        reset(r, o) {
          this.points = r || [], this._distances = [0];
          for (let u = 1; u < this.points.length; u++) this._distances[u] = this._distances[u - 1] + this.points[u].dist(this.points[u - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(o || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(r) {
          if (this.points.length === 1) return this.points[0];
          r = s.clamp(r, 0, 1);
          let o = 1, u = this._distances[o];
          const d = r * this.paddedLength + this.padding;
          for (; u < d && o < this._distances.length; ) u = this._distances[++o];
          const f = o - 1, g = this._distances[f], x = u - g, b = x > 0 ? (d - g) / x : 0;
          return this.points[f].mult(1 - b).add(this.points[o].mult(b));
        }
      }
      class uo {
        constructor(r, o, u) {
          const d = this.boxCells = [], f = this.circleCells = [];
          this.xCellCount = Math.ceil(r / u), this.yCellCount = Math.ceil(o / u);
          for (let g = 0; g < this.xCellCount * this.yCellCount; g++) d.push([]), f.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = r, this.height = o, this.xScale = this.xCellCount / r, this.yScale = this.yCellCount / o, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(r, o, u, d, f) {
          this._forEachCell(o, u, d, f, this._insertBoxCell, this.boxUid++), this.boxKeys.push(r), this.bboxes.push(o), this.bboxes.push(u), this.bboxes.push(d), this.bboxes.push(f);
        }
        insertCircle(r, o, u, d) {
          this._forEachCell(o - d, u - d, o + d, u + d, this._insertCircleCell, this.circleUid++), this.circleKeys.push(r), this.circles.push(o), this.circles.push(u), this.circles.push(d);
        }
        _insertBoxCell(r, o, u, d, f, g) {
          this.boxCells[f].push(g);
        }
        _insertCircleCell(r, o, u, d, f, g) {
          this.circleCells[f].push(g);
        }
        _query(r, o, u, d, f, g) {
          if (u < 0 || r > this.width || d < 0 || o > this.height) return !f && [];
          const x = [];
          if (r <= 0 && o <= 0 && this.width <= u && this.height <= d) {
            if (f) return !0;
            for (let b = 0; b < this.boxKeys.length; b++) x.push({ key: this.boxKeys[b], x1: this.bboxes[4 * b], y1: this.bboxes[4 * b + 1], x2: this.bboxes[4 * b + 2], y2: this.bboxes[4 * b + 3] });
            for (let b = 0; b < this.circleKeys.length; b++) {
              const M = this.circles[3 * b], S = this.circles[3 * b + 1], P = this.circles[3 * b + 2];
              x.push({ key: this.circleKeys[b], x1: M - P, y1: S - P, x2: M + P, y2: S + P });
            }
            return g ? x.filter(g) : x;
          }
          return this._forEachCell(r, o, u, d, this._queryCell, x, { hitTest: f, seenUids: { box: {}, circle: {} } }, g), f ? x.length > 0 : x;
        }
        _queryCircle(r, o, u, d, f) {
          const g = r - u, x = r + u, b = o - u, M = o + u;
          if (x < 0 || g > this.width || M < 0 || b > this.height) return !d && [];
          const S = [];
          return this._forEachCell(g, b, x, M, this._queryCellCircle, S, { hitTest: d, circle: { x: r, y: o, radius: u }, seenUids: { box: {}, circle: {} } }, f), d ? S.length > 0 : S;
        }
        query(r, o, u, d, f) {
          return this._query(r, o, u, d, !1, f);
        }
        hitTest(r, o, u, d, f) {
          return this._query(r, o, u, d, !0, f);
        }
        hitTestCircle(r, o, u, d) {
          return this._queryCircle(r, o, u, !0, d);
        }
        _queryCell(r, o, u, d, f, g, x, b) {
          const M = x.seenUids, S = this.boxCells[f];
          if (S !== null) {
            const F = this.bboxes;
            for (const j of S) if (!M.box[j]) {
              M.box[j] = !0;
              const $ = 4 * j;
              if (r <= F[$ + 2] && o <= F[$ + 3] && u >= F[$ + 0] && d >= F[$ + 1] && (!b || b(this.boxKeys[j]))) {
                if (x.hitTest) return g.push(!0), !0;
                g.push({ key: this.boxKeys[j], x1: F[$], y1: F[$ + 1], x2: F[$ + 2], y2: F[$ + 3] });
              }
            }
          }
          const P = this.circleCells[f];
          if (P !== null) {
            const F = this.circles;
            for (const j of P) if (!M.circle[j]) {
              M.circle[j] = !0;
              const $ = 3 * j;
              if (this._circleAndRectCollide(F[$], F[$ + 1], F[$ + 2], r, o, u, d) && (!b || b(this.circleKeys[j]))) {
                if (x.hitTest) return g.push(!0), !0;
                {
                  const G = F[$], Z = F[$ + 1], L = F[$ + 2];
                  g.push({ key: this.circleKeys[j], x1: G - L, y1: Z - L, x2: G + L, y2: Z + L });
                }
              }
            }
          }
        }
        _queryCellCircle(r, o, u, d, f, g, x, b) {
          const M = x.circle, S = x.seenUids, P = this.boxCells[f];
          if (P !== null) {
            const j = this.bboxes;
            for (const $ of P) if (!S.box[$]) {
              S.box[$] = !0;
              const G = 4 * $;
              if (this._circleAndRectCollide(M.x, M.y, M.radius, j[G + 0], j[G + 1], j[G + 2], j[G + 3]) && (!b || b(this.boxKeys[$]))) return g.push(!0), !0;
            }
          }
          const F = this.circleCells[f];
          if (F !== null) {
            const j = this.circles;
            for (const $ of F) if (!S.circle[$]) {
              S.circle[$] = !0;
              const G = 3 * $;
              if (this._circlesCollide(j[G], j[G + 1], j[G + 2], M.x, M.y, M.radius) && (!b || b(this.circleKeys[$]))) return g.push(!0), !0;
            }
          }
        }
        _forEachCell(r, o, u, d, f, g, x, b) {
          const M = this._convertToXCellCoord(r), S = this._convertToYCellCoord(o), P = this._convertToXCellCoord(u), F = this._convertToYCellCoord(d);
          for (let j = M; j <= P; j++) for (let $ = S; $ <= F; $++) if (f.call(this, r, o, u, d, this.xCellCount * $ + j, g, x, b)) return;
        }
        _convertToXCellCoord(r) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(r * this.xScale)));
        }
        _convertToYCellCoord(r) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(r * this.yScale)));
        }
        _circlesCollide(r, o, u, d, f, g) {
          const x = d - r, b = f - o, M = u + g;
          return M * M > x * x + b * b;
        }
        _circleAndRectCollide(r, o, u, d, f, g, x) {
          const b = (g - d) / 2, M = Math.abs(r - (d + b));
          if (M > b + u) return !1;
          const S = (x - f) / 2, P = Math.abs(o - (f + S));
          if (P > S + u) return !1;
          if (M <= b || P <= S) return !0;
          const F = M - b, j = P - S;
          return F * F + j * j <= u * u;
        }
      }
      const wr = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, Fr = Math.tan(85 * Math.PI / 180);
      function Pe(l, r, o, u, d, f, g) {
        const x = s.create();
        if (o) if (f.name === "globe") {
          const b = s.calculateGlobeLabelMatrix(d, r);
          s.multiply(x, x, b);
        } else {
          const b = et([], g);
          x[0] = b[0], x[1] = b[1], x[4] = b[2], x[5] = b[3], u || s.rotateZ(x, x, d.angle);
        }
        else s.multiply(x, d.labelPlaneMatrix, l);
        return x;
      }
      function Cr(l, r, o, u, d, f, g) {
        const x = Pe(l, r, o, u, d, f, g);
        return f.name === "globe" && o || (x[2] = x[6] = x[10] = x[14] = 0), x;
      }
      function Li(l, r, o, u, d, f, g) {
        if (o) {
          if (f.name === "globe") {
            const x = Pe(l, r, o, u, d, f, g);
            return s.invert(x, x), s.multiply(x, l, x), x;
          }
          {
            const x = s.clone(l), b = s.identity([]);
            return b[0] = g[0], b[1] = g[1], b[4] = g[2], b[5] = g[3], s.multiply(x, x, b), u || s.rotateZ(x, x, -d.angle), x;
          }
        }
        return d.glCoordMatrix;
      }
      function lr(l, r, o, u) {
        const d = [l, r, o, 1];
        o ? s.transformMat4$1(d, d, u) : Gt(d, d, u);
        const f = d[3];
        return d[0] /= f, d[1] /= f, d[2] /= f, d;
      }
      function xl(l, r) {
        return Math.min(0.5 + l / r * 0.5, 1.5);
      }
      function Pn(l, r) {
        const o = l[0] / l[3], u = l[1] / l[3];
        return o >= -r[0] && o <= r[0] && u >= -r[1] && u <= r[1];
      }
      function Aa(l, r, o, u, d, f, g, x, b, M) {
        const S = o.transform, P = u ? l.textSizeData : l.iconSizeData, F = s.evaluateSizeForZoom(P, o.transform.zoom), j = S.projection.name === "globe", $ = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1], G = u ? l.text.dynamicLayoutVertexArray : l.icon.dynamicLayoutVertexArray;
        G.clear();
        let Z = null;
        j && (Z = u ? l.text.globeExtVertexArray : l.icon.globeExtVertexArray);
        const L = l.lineVertexArray, N = u ? l.text.placedSymbolArray : l.icon.placedSymbolArray, X = o.transform.width / o.transform.height;
        let K, le = !1;
        for (let ue = 0; ue < N.length; ue++) {
          const ce = N.get(ue), { numGlyphs: ge, writingMode: me } = ce;
          if (me !== s.WritingMode.vertical || le || K === s.WritingMode.horizontal || (le = !0), K = me, (ce.hidden || me === s.WritingMode.vertical) && !le) {
            yn(ge, G);
            continue;
          }
          le = !1;
          const Ee = new s.Point(ce.tileAnchorX, ce.tileAnchorY);
          let { x: Ge, y: be, z: Oe } = S.projection.projectTilePoint(Ee.x, Ee.y, M.canonical);
          if (b) {
            const [Dt, gt, Ct] = b(Ee);
            Ge += Dt, be += gt, Oe += Ct;
          }
          const Ce = [Ge, be, Oe, 1];
          if (s.transformMat4$1(Ce, Ce, r), !Pn(Ce, $)) {
            yn(ge, G);
            continue;
          }
          const Ve = xl(o.transform.cameraToCenterDistance, Ce[3]), Te = s.evaluateSizeForFeature(P, F, ce), Re = g ? Te / Ve : Te * Ve, We = lr(Ge, be, Oe, d);
          if (We[3] <= 0) {
            yn(ge, G);
            continue;
          }
          let Ne = {};
          const He = g ? null : b, wt = st(ce, Re, !1, x, r, d, f, l.glyphOffsetArray, L, G, Z, We, Ee, Ne, X, He, S.projection, M, g);
          le = wt.useVertical, He && wt.needsFlipping && (Ne = {}), (wt.notEnoughRoom || le || wt.needsFlipping && st(ce, Re, !0, x, r, d, f, l.glyphOffsetArray, L, G, Z, We, Ee, Ne, X, He, S.projection, M, g).notEnoughRoom) && yn(ge, G);
        }
        u ? (l.text.dynamicLayoutVertexBuffer.updateData(G), Z && l.text.globeExtVertexBuffer.updateData(Z)) : (l.icon.dynamicLayoutVertexBuffer.updateData(G), Z && l.icon.globeExtVertexBuffer.updateData(Z));
      }
      function Ia(l, r, o, u, d, f, g, x, b, M, S, P, F, j, $, G) {
        const { lineStartIndex: Z, glyphStartIndex: L, segment: N } = x, X = L + x.numGlyphs, K = Z + x.lineLength, le = r.getoffsetX(L), ue = r.getoffsetX(X - 1), ce = Xr(l * le, o, u, d, f, g, N, Z, K, b, M, S, P, F, !0, j, $, G);
        if (!ce) return null;
        const ge = Xr(l * ue, o, u, d, f, g, N, Z, K, b, M, S, P, F, !0, j, $, G);
        return ge ? { first: ce, last: ge } : null;
      }
      function ho(l, r, o, u) {
        return l === s.WritingMode.horizontal && Math.abs(u) > Math.abs(o) ? { useVertical: !0 } : l === s.WritingMode.vertical ? u > 0 ? { needsFlipping: !0 } : null : r !== wr.unknown && function(d, f) {
          return d === 0 || Math.abs(f / d) > Fr;
        }(o, u) ? r === wr.flipRequired ? { needsFlipping: !0 } : null : o < 0 ? { needsFlipping: !0 } : null;
      }
      function st(l, r, o, u, d, f, g, x, b, M, S, P, F, j, $, G, Z, L, N) {
        const X = r / 24, K = l.lineOffsetX * X, le = l.lineOffsetY * X, { lineStartIndex: ue, glyphStartIndex: ce, numGlyphs: ge, segment: me, writingMode: Ee, flipState: Ge } = l, be = ue + l.lineLength, Oe = (Ce) => {
          if (S) {
            const [We, Ne, He] = Ce.up, wt = M.length;
            s.updateGlobeVertexNormal(S, wt + 0, We, Ne, He), s.updateGlobeVertexNormal(S, wt + 1, We, Ne, He), s.updateGlobeVertexNormal(S, wt + 2, We, Ne, He), s.updateGlobeVertexNormal(S, wt + 3, We, Ne, He);
          }
          const [Ve, Te, Re] = Ce.point;
          s.addDynamicAttributes(M, Ve, Te, Re, Ce.angle);
        };
        if (ge > 1) {
          const Ce = Ia(X, x, K, le, o, P, F, l, b, f, j, G, !1, Z, L, N);
          if (!Ce) return { notEnoughRoom: !0 };
          if (u && !o) {
            let [Ve, Te, Re] = Ce.first.point, [We, Ne, He] = Ce.last.point;
            [Ve, Te] = lr(Ve, Te, Re, g), [We, Ne] = lr(We, Ne, He, g);
            const wt = ho(Ee, Ge, (We - Ve) * $, Ne - Te);
            if (l.flipState = wt && wt.needsFlipping ? wr.flipRequired : wr.flipNotRequired, wt) return wt;
          }
          Oe(Ce.first);
          for (let Ve = ce + 1; Ve < ce + ge - 1; Ve++) {
            const Te = Xr(X * x.getoffsetX(Ve), K, le, o, P, F, me, ue, be, b, f, j, G, !1, !1, Z, L, N);
            if (!Te) return M.length -= 4 * (Ve - ce), { notEnoughRoom: !0 };
            Oe(Te);
          }
          Oe(Ce.last);
        } else {
          if (u && !o) {
            const Ve = lr(F.x, F.y, 0, d), Te = ue + me + 1, Re = new s.Point(b.getx(Te), b.gety(Te)), We = lr(Re.x, Re.y, 0, d), Ne = We[3] > 0 ? We : Ht(F, Re, Ve, 1, d, void 0, Z, L.canonical), He = ho(Ee, Ge, (Ne[0] - Ve[0]) * $, Ne[1] - Ve[1]);
            if (l.flipState = He && He.needsFlipping ? wr.flipRequired : wr.flipNotRequired, He) return He;
          }
          const Ce = Xr(X * x.getoffsetX(ce), K, le, o, P, F, me, ue, be, b, f, j, G, !1, !1, Z, L, N);
          if (!Ce) return { notEnoughRoom: !0 };
          Oe(Ce);
        }
        return {};
      }
      function Jt(l, r, o, u, d) {
        const { x: f, y: g, z: x } = u.projectTilePoint(l.x, l.y, r);
        if (!d) return lr(f, g, x, o);
        const [b, M, S] = d(l);
        return lr(f + b, g + M, x + S, o);
      }
      function Ht(l, r, o, u, d, f, g, x) {
        const b = Jt(l.sub(r)._unit()._add(l), x, d, g, f);
        return s.sub(b, o, b), s.normalize(b, b), s.scaleAndAdd(b, o, b, u);
      }
      function Xr(l, r, o, u, d, f, g, x, b, M, S, P, F, j, $, G, Z, L) {
        const N = u ? l - r : l + r;
        let X = N > 0 ? 1 : -1, K = 0;
        u && (X *= -1, K = Math.PI), X < 0 && (K += Math.PI);
        let le = x + g + (X > 0 ? 0 : 1) | 0, ue = d, ce = d, ge = 0, me = 0;
        const Ee = Math.abs(N), Ge = [], be = [];
        let Oe = f, Ce = Oe;
        const Ve = () => Ht(Ce, Oe, ce, Ee - ge + 1, S, F, G, Z.canonical);
        for (; ge + me <= Ee; ) {
          if (le += X, le < x || le >= b) return null;
          if (ce = ue, Ce = Oe, Ge.push(ce), j && be.push(Ce), Oe = new s.Point(M.getx(le), M.gety(le)), ue = P[le], !ue) {
            const Ct = Jt(Oe, Z.canonical, S, G, F);
            ue = Ct[3] > 0 ? P[le] = Ct : Ve();
          }
          ge += me, me = s.distance(ce, ue);
        }
        $ && F && (P[le] && (ue = Ve(), me = s.distance(ce, ue)), P[le] = ue);
        const Te = (Ee - ge) / me, Re = Oe.sub(Ce)._mult(Te)._add(Ce), We = s.sub([], ue, ce), Ne = s.scaleAndAdd([], ce, We, Te);
        let He = [0, 0, 1], wt = We[0], Dt = We[1];
        if (L && (He = G.upVector(Z.canonical, Re.x, Re.y), He[0] !== 0 || He[1] !== 0 || He[2] !== 1)) {
          const Ct = [He[2], 0, -He[0]], ti = s.cross([], He, Ct);
          s.normalize(Ct, Ct), s.normalize(ti, ti), wt = s.dot(We, Ct), Dt = s.dot(We, ti);
        }
        if (o) {
          const Ct = s.cross([], He, We);
          s.normalize(Ct, Ct), s.scaleAndAdd(Ne, Ne, Ct, o * X);
        }
        const gt = K + Math.atan2(Dt, wt);
        return Ge.push(Ne), j && be.push(Re), { point: Ne, angle: gt, path: Ge, tilePath: be, up: He };
      }
      function yn(l, r) {
        const o = r.length, u = o + 4 * l;
        r.resize(u), r.float32.fill(-1 / 0, 4 * o, 4 * u);
      }
      function Gt(l, r, o) {
        const u = r[0], d = r[1];
        return l[0] = o[0] * u + o[4] * d + o[12], l[1] = o[1] * u + o[5] * d + o[13], l[3] = o[3] * u + o[7] * d + o[15], l;
      }
      const y = 100;
      class E {
        constructor(r, o, u = new uo(r.width + 200, r.height + 200, 25), d = new uo(r.width + 200, r.height + 200, 25)) {
          this.transform = r, this.grid = u, this.ignoredGrid = d, this.pitchfactor = Math.cos(r._pitch) * r.cameraToCenterDistance, this.screenRightBoundary = r.width + y, this.screenBottomBoundary = r.height + y, this.gridRightBoundary = r.width + 200, this.gridBottomBoundary = r.height + 200, this.fogState = o;
        }
        placeCollisionBox(r, o, u, d, f, g, x, b) {
          let M = u.projectedAnchorX, S = u.projectedAnchorY, P = u.projectedAnchorZ;
          const F = u.elevation, j = u.tileID, $ = r.getProjection();
          if (F && j) {
            const [ue, ce, ge] = $.upVector(j.canonical, u.tileAnchorX, u.tileAnchorY), me = $.upVectorScale(j.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            M += ue * F * me, S += ce * F * me, P += ge * F * me;
          }
          const G = this.projectAndGetPerspectiveRatio(x, M, S, P, u.tileID, $.name === "globe" || !!F || this.transform.pitch > 0, $), Z = g * G.perspectiveRatio, L = (u.x1 * o + d.x - u.padding) * Z + G.point.x, N = (u.y1 * o + d.y - u.padding) * Z + G.point.y, X = (u.x2 * o + d.x + u.padding) * Z + G.point.x, K = (u.y2 * o + d.y + u.padding) * Z + G.point.y, le = G.perspectiveRatio <= 0.55 || G.occluded;
          return !this.isInsideGrid(L, N, X, K) || !f && this.grid.hitTest(L, N, X, K, b) || le ? { box: [], offscreen: !1, occluded: G.occluded } : { box: [L, N, X, K], offscreen: this.isOffscreen(L, N, X, K), occluded: !1 };
        }
        placeCollisionCircles(r, o, u, d, f, g, x, b, M, S, P, F, j, $, G) {
          const Z = [], L = this.transform.elevation, N = r.getProjection(), X = L ? L.getAtTileOffsetFunc(G, this.transform.center.lat, this.transform.worldSize, N) : null, K = new s.Point(u.tileAnchorX, u.tileAnchorY);
          let { x: le, y: ue, z: ce } = N.projectTilePoint(K.x, K.y, G.canonical);
          if (X) {
            const [Re, We, Ne] = X(K);
            le += Re, ue += We, ce += Ne;
          }
          const ge = N.name === "globe", me = this.projectAndGetPerspectiveRatio(x, le, ue, ce, G, ge || !!L || this.transform.pitch > 0, N), { perspectiveRatio: Ee } = me, Ge = (P ? g / Ee : g * Ee) / s.ONE_EM, be = lr(le, ue, ce, b), Oe = me.signedDistanceFromCamera > 0 ? Ia(Ge, f, u.lineOffsetX * Ge, u.lineOffsetY * Ge, !1, be, K, u, d, b, {}, L && !P ? X : null, P && !!L, N, G, P) : null;
          let Ce = !1, Ve = !1, Te = !0;
          if (Oe && !me.occluded) {
            const Re = 0.5 * j * Ee + $, We = new s.Point(-100, -100), Ne = new s.Point(this.screenRightBoundary, this.screenBottomBoundary), He = new Ks(), { first: wt, last: Dt } = Oe, gt = wt.path.length;
            let Ct = [];
            for (let vt = gt - 1; vt >= 1; vt--) Ct.push(wt.path[vt]);
            for (let vt = 1; vt < Dt.path.length; vt++) Ct.push(Dt.path[vt]);
            const ti = 2.5 * Re;
            M && (Ct = Ct.map(([vt, vi, Ti], Ei) => (X && !ge && (Ti = X(Ei < gt - 1 ? wt.tilePath[gt - 1 - Ei] : Dt.tilePath[Ei - gt + 2])[2]), lr(vt, vi, Ti, M))), Ct.some((vt) => vt[3] <= 0) && (Ct = []));
            let Yt = [];
            if (Ct.length > 0) {
              let vt = 1 / 0, vi = -1 / 0, Ti = 1 / 0, Ei = -1 / 0;
              for (const Si of Ct) vt = Math.min(vt, Si[0]), Ti = Math.min(Ti, Si[1]), vi = Math.max(vi, Si[0]), Ei = Math.max(Ei, Si[1]);
              vi >= We.x && vt <= Ne.x && Ei >= We.y && Ti <= Ne.y && (Yt = [Ct.map((Si) => new s.Point(Si[0], Si[1]))], (vt < We.x || vi > Ne.x || Ti < We.y || Ei > Ne.y) && (Yt = s.clipLine(Yt, We.x, We.y, Ne.x, Ne.y)));
            }
            for (const vt of Yt) {
              He.reset(vt, 0.25 * Re);
              let vi = 0;
              vi = He.length <= 0.5 * Re ? 1 : Math.ceil(He.paddedLength / ti) + 1;
              for (let Ti = 0; Ti < vi; Ti++) {
                const Ei = Ti / Math.max(vi - 1, 1), Si = He.lerp(Ei), Vr = Si.x + y, Er = Si.y + y;
                Z.push(Vr, Er, Re, 0);
                const kn = Vr - Re, Eo = Er - Re, Gi = Vr + Re, Mi = Er + Re;
                if (Te = Te && this.isOffscreen(kn, Eo, Gi, Mi), Ve = Ve || this.isInsideGrid(kn, Eo, Gi, Mi), !o && this.grid.hitTestCircle(Vr, Er, Re, F) && (Ce = !0, !S)) return { circles: [], offscreen: !1, collisionDetected: Ce, occluded: !1 };
              }
            }
          }
          return { circles: !S && Ce || !Ve ? [] : Z, offscreen: Te, collisionDetected: Ce, occluded: me.occluded };
        }
        queryRenderedSymbols(r) {
          if (r.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const o = [];
          let u = 1 / 0, d = 1 / 0, f = -1 / 0, g = -1 / 0;
          for (const S of r) {
            const P = new s.Point(S.x + y, S.y + y);
            u = Math.min(u, P.x), d = Math.min(d, P.y), f = Math.max(f, P.x), g = Math.max(g, P.y), o.push(P);
          }
          const x = this.grid.query(u, d, f, g).concat(this.ignoredGrid.query(u, d, f, g)), b = {}, M = {};
          for (const S of x) {
            const P = S.key;
            if (b[P.bucketInstanceId] === void 0 && (b[P.bucketInstanceId] = {}), b[P.bucketInstanceId][P.featureIndex]) continue;
            const F = [new s.Point(S.x1, S.y1), new s.Point(S.x2, S.y1), new s.Point(S.x2, S.y2), new s.Point(S.x1, S.y2)];
            s.polygonIntersectsPolygon(o, F) && (b[P.bucketInstanceId][P.featureIndex] = !0, M[P.bucketInstanceId] === void 0 && (M[P.bucketInstanceId] = []), M[P.bucketInstanceId].push(P.featureIndex));
          }
          return M;
        }
        insertCollisionBox(r, o, u, d, f) {
          (o ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: u, featureIndex: d, collisionGroupID: f }, r[0], r[1], r[2], r[3]);
        }
        insertCollisionCircles(r, o, u, d, f) {
          const g = o ? this.ignoredGrid : this.grid, x = { bucketInstanceId: u, featureIndex: d, collisionGroupID: f };
          for (let b = 0; b < r.length; b += 4) g.insertCircle(x, r[b], r[b + 1], r[b + 2]);
        }
        projectAndGetPerspectiveRatio(r, o, u, d, f, g, x) {
          const b = [o, u, d, 1];
          let M = !1;
          d || this.transform.pitch > 0 ? (s.transformMat4$1(b, b, r), this.fogState && f && x.name !== "globe" && (M = function(F, j, $, G, Z, L) {
            const N = L.calculateFogTileMatrix(Z), X = [j, $, G];
            return s.transformMat4(X, X, N), br(F, X, L.pitch, L._fov);
          }(this.fogState, o, u, d, f.toUnwrapped(), this.transform) > 0.9)) : Gt(b, b, r);
          const S = b[3];
          return { point: new s.Point((b[0] / S + 1) / 2 * this.transform.width + y, (-b[1] / S + 1) / 2 * this.transform.height + y), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(x) / S * 0.5, 1.5), signedDistanceFromCamera: S, occluded: g && b[2] > S || M };
        }
        isOffscreen(r, o, u, d) {
          return u < y || r >= this.screenRightBoundary || d < y || o > this.screenBottomBoundary;
        }
        isInsideGrid(r, o, u, d) {
          return u >= 0 && r < this.gridRightBoundary && d >= 0 && o < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const r = s.identity([]);
          return s.translate(r, r, [-100, -100, 0]), r;
        }
      }
      function O(l, r, o) {
        const u = r.createTileMatrix(l, l.worldSize, o.toUnwrapped());
        return s.multiply(new Float32Array(16), l.projMatrix, u);
      }
      function Y(l, r, o) {
        if (r.projection.name === o.projection.name) return l.projMatrix;
        const u = o.clone();
        return u.setProjection(r.projection), O(u, r.getProjection(), l);
      }
      function ne(l, r, o) {
        return r.name === o.projection.name ? l.projMatrix : O(o, r, l);
      }
      class fe {
        constructor(r, o, u, d) {
          this.opacity = r ? Math.max(0, Math.min(1, r.opacity + (r.placed ? o : -o))) : d && u ? 1 : 0, this.placed = u;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class _e {
        constructor(r, o, u, d, f, g = !1) {
          this.text = new fe(r ? r.text : null, o, u, f), this.icon = new fe(r ? r.icon : null, o, d, f), this.clipped = g;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class qe {
        constructor(r, o, u, d = !1) {
          this.text = r, this.icon = o, this.skipFade = u, this.clipped = d;
        }
      }
      class tt {
        constructor() {
          this.invProjMatrix = s.create(), this.viewportMatrix = s.create(), this.circles = [];
        }
      }
      class dt {
        constructor(r, o, u, d, f) {
          this.bucketInstanceId = r, this.featureIndex = o, this.sourceLayerIndex = u, this.bucketIndex = d, this.tileID = f;
        }
      }
      class ft {
        constructor(r) {
          this.crossSourceCollisions = r, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(r) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[r]) {
            const o = ++this.maxGroupID;
            this.collisionGroups[r] = { ID: o, predicate: (u) => u.collisionGroupID === o };
          }
          return this.collisionGroups[r];
        }
      }
      function nt(l, r, o, u, d) {
        const { horizontalAlign: f, verticalAlign: g } = s.getAnchorAlignment(l), x = -(f - 0.5) * r, b = -(g - 0.5) * o, M = s.evaluateVariableOffset(l, u);
        return new s.Point(x + M[0] * d, b + M[1] * d);
      }
      function zt(l, r, o, u, d) {
        const f = new s.Point(l, r);
        return o && f._rotate(u ? d : -d), f;
      }
      class Oi {
        constructor(r, o, u, d, f) {
          this.transform = r.clone(), this.projection = r.projection.name, this.collisionIndex = new E(this.transform, f), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = o, this.retainedQueryData = {}, this.collisionGroups = new ft(u), this.collisionCircleArrays = {}, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(r, o, u, d) {
          const f = u.getBucket(o), g = u.latestFeatureIndex;
          if (!f || !g || o.id !== f.layerIds[0]) return;
          const x = f.layers[0].layout, b = u.collisionBoxArray, M = Math.pow(2, this.transform.zoom - u.tileID.overscaledZ), S = u.tileSize / s.EXTENT, P = u.tileID.toUnwrapped();
          this.transform.setProjection(f.projection);
          const F = (j = u.tileID, $ = f.getProjection(), G = this.transform, $.name === this.projection ? G.calculateProjMatrix(j.toUnwrapped()) : O(G, $, j));
          var j, $, G;
          const Z = x.get("text-pitch-alignment") === "map", L = x.get("text-rotation-alignment") === "map";
          o.compileFilter();
          const N = o.dynamicFilter(), X = o.dynamicFilterNeedsFeature(), K = this.transform.calculatePixelsToTileUnitsMatrix(u), le = Cr(F, u.tileID.canonical, Z, L, this.transform, f.getProjection(), K);
          let ue = null;
          if (Z) {
            const me = Li(F, u.tileID.canonical, Z, L, this.transform, f.getProjection(), K);
            ue = s.multiply([], this.transform.labelPlaneMatrix, me);
          }
          let ce = null;
          N && u.latestFeatureIndex && (ce = { unwrappedTileID: P, dynamicFilter: N, dynamicFilterNeedsFeature: X, featureIndex: u.latestFeatureIndex }), this.retainedQueryData[f.bucketInstanceId] = new dt(f.bucketInstanceId, g, f.sourceLayerIndex, f.index, u.tileID);
          const ge = { bucket: f, layout: x, posMatrix: F, textLabelPlaneMatrix: le, labelToScreenMatrix: ue, clippingData: ce, scale: M, textPixelRatio: S, holdingForFade: u.holdingForFade(), collisionBoxArray: b, partiallyEvaluatedTextSize: s.evaluateSizeForZoom(f.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: s.evaluateSizeForZoom(f.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(f.sourceID) };
          if (d) for (const me of f.sortKeyRanges) {
            const { sortKey: Ee, symbolInstanceStart: Ge, symbolInstanceEnd: be } = me;
            r.push({ sortKey: Ee, symbolInstanceStart: Ge, symbolInstanceEnd: be, parameters: ge });
          }
          else r.push({ symbolInstanceStart: 0, symbolInstanceEnd: f.symbolInstances.length, parameters: ge });
        }
        attemptAnchorPlacement(r, o, u, d, f, g, x, b, M, S, P, F, j, $, G, Z, L, N) {
          const { textOffset0: X, textOffset1: K, crossTileID: le } = F, ue = [X, K], ce = nt(r, u, d, ue, f), ge = this.collisionIndex.placeCollisionBox($, f, o, zt(ce.x, ce.y, g, x, this.transform.angle), P, b, M, S.predicate);
          if (Z) {
            const me = $.getSymbolInstanceIconSize(N, this.transform.zoom, F.placedIconSymbolIndex);
            if (this.collisionIndex.placeCollisionBox($, me, Z, zt(ce.x, ce.y, g, x, this.transform.angle), P, b, M, S.predicate).box.length === 0) return;
          }
          if (ge.box.length > 0) {
            let me;
            return this.prevPlacement && this.prevPlacement.variableOffsets[le] && this.prevPlacement.placements[le] && this.prevPlacement.placements[le].text && (me = this.prevPlacement.variableOffsets[le].anchor), this.variableOffsets[le] = { textOffset: ue, width: u, height: d, anchor: r, textScale: f, prevAnchor: me }, this.markUsedJustification($, r, F, G), $.allowVerticalPlacement && (this.markUsedOrientation($, G, F), this.placedOrientations[le] = G), { shift: ce, placedGlyphBoxes: ge };
          }
        }
        placeLayerBucketPart(r, o, u, d) {
          const { bucket: f, layout: g, posMatrix: x, textLabelPlaneMatrix: b, labelToScreenMatrix: M, clippingData: S, textPixelRatio: P, holdingForFade: F, collisionBoxArray: j, partiallyEvaluatedTextSize: $, partiallyEvaluatedIconSize: G, collisionGroup: Z } = r.parameters, L = g.get("text-optional"), N = g.get("icon-optional"), X = g.get("text-allow-overlap"), K = g.get("icon-allow-overlap"), le = g.get("text-rotation-alignment") === "map", ue = g.get("text-pitch-alignment") === "map", ce = g.get("icon-text-fit") !== "none", ge = g.get("symbol-z-order") === "viewport-y";
          this.transform.setProjection(f.projection);
          let me = X && (K || !f.hasIconData() || N), Ee = K && (X || !f.hasTextData() || L);
          !f.collisionArrays && j && f.deserializeCollisionBoxes(j), u && d && f.updateCollisionDebugBuffers(this.transform.zoom, j);
          const Ge = (be, Oe, Ce) => {
            const { crossTileID: Ve, numVerticalGlyphVertices: Te } = be;
            if (S) {
              const Gi = { zoom: this.transform.zoom, pitch: this.transform.pitch };
              let Mi = null;
              if (S.dynamicFilterNeedsFeature) {
                const fi = this.retainedQueryData[f.bucketInstanceId];
                Mi = S.featureIndex.loadFeature({ featureIndex: be.featureIndex, bucketIndex: fi.bucketIndex, sourceLayerIndex: fi.sourceLayerIndex, layoutVertexArrayOffset: 0 });
              }
              if (!(0, S.dynamicFilter)(Gi, Mi, this.retainedQueryData[f.bucketInstanceId].tileID.canonical, new s.Point(be.tileAnchorX, be.tileAnchorY), this.transform.calculateDistanceTileData(S.unwrappedTileID))) return this.placements[Ve] = new qe(!1, !1, !1, !0), void o.add(Ve);
            }
            if (o.has(Ve)) return;
            if (F) return void (this.placements[Ve] = new qe(!1, !1, !1));
            let Re = !1, We = !1, Ne = !0, He = !1, wt = !1, Dt = null, gt = { box: null, offscreen: null, occluded: null }, Ct = { box: null, offscreen: null, occluded: null }, ti = null, Yt = null, vt = null, vi = 0, Ti = 0, Ei = 0;
            Ce.textFeatureIndex ? vi = Ce.textFeatureIndex : be.useRuntimeCollisionCircles && (vi = be.featureIndex), Ce.verticalTextFeatureIndex && (Ti = Ce.verticalTextFeatureIndex);
            const Si = (Gi) => {
              Gi.tileID = this.retainedQueryData[f.bucketInstanceId].tileID;
              const Mi = this.transform.elevation;
              (Mi || Gi.elevation) && (Gi.elevation = Mi ? Mi.getAtTileOffset(Gi.tileID, Gi.tileAnchorX, Gi.tileAnchorY) : 0);
            }, Vr = Ce.textBox;
            if (Vr) {
              Si(Vr);
              const Gi = (fi) => {
                let cr = s.WritingMode.horizontal;
                if (f.allowVerticalPlacement && !fi && this.prevPlacement) {
                  const Jr = this.prevPlacement.placedOrientations[Ve];
                  Jr && (this.placedOrientations[Ve] = Jr, cr = Jr, this.markUsedOrientation(f, cr, be));
                }
                return cr;
              }, Mi = (fi, cr) => {
                if (f.allowVerticalPlacement && Te > 0 && Ce.verticalTextBox) {
                  for (const Jr of f.writingModes) if (Jr === s.WritingMode.vertical ? (gt = cr(), Ct = gt) : gt = fi(), gt && gt.box && gt.box.length) break;
                } else gt = fi();
              };
              if (g.get("text-variable-anchor")) {
                let fi = g.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[Ve]) {
                  const ji = this.prevPlacement.variableOffsets[Ve];
                  fi.indexOf(ji.anchor) > 0 && (fi = fi.filter((cn) => cn !== ji.anchor), fi.unshift(ji.anchor));
                }
                const cr = (ji, cn, Rl) => {
                  const Us = f.getSymbolInstanceTextSize($, be, this.transform.zoom, Oe), Ja = (ji.x2 - ji.x1) * Us + 2 * ji.padding, Vo = (ji.y2 - ji.y1) * Us + 2 * ji.padding, ps = ce && !K ? cn : null;
                  ps && Si(ps);
                  let Ns = { box: [], offscreen: !1, occluded: !1 };
                  const Ol = X ? 2 * fi.length : fi.length;
                  for (let Ya = 0; Ya < Ol; ++Ya) {
                    const Pc = this.attemptAnchorPlacement(fi[Ya % fi.length], ji, Ja, Vo, Us, le, ue, P, x, Z, Ya >= fi.length, be, Oe, f, Rl, ps, $, G);
                    if (Pc && (Ns = Pc.placedGlyphBoxes, Ns && Ns.box && Ns.box.length)) {
                      Re = !0, Dt = Pc.shift;
                      break;
                    }
                  }
                  return Ns;
                };
                Mi(() => cr(Vr, Ce.iconBox, s.WritingMode.horizontal), () => {
                  const ji = Ce.verticalTextBox;
                  return ji && Si(ji), f.allowVerticalPlacement && !(gt && gt.box && gt.box.length) && Te > 0 && ji ? cr(ji, Ce.verticalIconBox, s.WritingMode.vertical) : { box: null, offscreen: null, occluded: null };
                }), gt && (Re = gt.box, Ne = gt.offscreen, He = gt.occluded);
                const Jr = Gi(!(!gt || !gt.box));
                if (!Re && this.prevPlacement) {
                  const ji = this.prevPlacement.variableOffsets[Ve];
                  ji && (this.variableOffsets[Ve] = ji, this.markUsedJustification(f, ji.anchor, be, Jr));
                }
              } else {
                const fi = (cr, Jr) => {
                  const ji = f.getSymbolInstanceTextSize($, be, this.transform.zoom, Oe), cn = this.collisionIndex.placeCollisionBox(f, ji, cr, new s.Point(0, 0), X, P, x, Z.predicate);
                  return cn && cn.box && cn.box.length && (this.markUsedOrientation(f, Jr, be), this.placedOrientations[Ve] = Jr), cn;
                };
                Mi(() => fi(Vr, s.WritingMode.horizontal), () => {
                  const cr = Ce.verticalTextBox;
                  return f.allowVerticalPlacement && Te > 0 && cr ? (Si(cr), fi(cr, s.WritingMode.vertical)) : { box: null, offscreen: null, occluded: null };
                }), Gi(!!(gt && gt.box && gt.box.length));
              }
            }
            if (ti = gt, Re = ti && ti.box && ti.box.length > 0, Ne = ti && ti.offscreen, He = ti && ti.occluded, be.useRuntimeCollisionCircles) {
              const Gi = f.text.placedSymbolArray.get(be.centerJustifiedTextSymbolIndex >= 0 ? be.centerJustifiedTextSymbolIndex : be.verticalPlacedTextSymbolIndex), Mi = s.evaluateSizeForFeature(f.textSizeData, $, Gi), fi = g.get("text-padding");
              Yt = this.collisionIndex.placeCollisionCircles(f, X, Gi, f.lineVertexArray, f.glyphOffsetArray, Mi, x, b, M, u, ue, Z.predicate, be.collisionCircleDiameter * Mi / s.ONE_EM, fi, this.retainedQueryData[f.bucketInstanceId].tileID), Re = X || Yt.circles.length > 0 && !Yt.collisionDetected, Ne = Ne && Yt.offscreen, He = Yt.occluded;
            }
            if (Ce.iconFeatureIndex && (Ei = Ce.iconFeatureIndex), Ce.iconBox) {
              const Gi = (Mi) => {
                Si(Mi);
                const fi = ce && Dt ? zt(Dt.x, Dt.y, le, ue, this.transform.angle) : new s.Point(0, 0), cr = f.getSymbolInstanceIconSize(G, this.transform.zoom, be.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(f, cr, Mi, fi, K, P, x, Z.predicate);
              };
              Ct && Ct.box && Ct.box.length && Ce.verticalIconBox ? (vt = Gi(Ce.verticalIconBox), We = vt.box.length > 0) : (vt = Gi(Ce.iconBox), We = vt.box.length > 0), Ne = Ne && vt.offscreen, wt = vt.occluded;
            }
            const Er = L || be.numHorizontalGlyphVertices === 0 && Te === 0, kn = N || be.numIconVertices === 0;
            if (Er || kn ? kn ? Er || (We = We && Re) : Re = We && Re : We = Re = We && Re, Re && ti && ti.box && this.collisionIndex.insertCollisionBox(ti.box, g.get("text-ignore-placement"), f.bucketInstanceId, Ct && Ct.box && Ti ? Ti : vi, Z.ID), We && vt && this.collisionIndex.insertCollisionBox(vt.box, g.get("icon-ignore-placement"), f.bucketInstanceId, Ei, Z.ID), Yt && (Re && this.collisionIndex.insertCollisionCircles(Yt.circles, g.get("text-ignore-placement"), f.bucketInstanceId, vi, Z.ID), u)) {
              const Gi = f.bucketInstanceId;
              let Mi = this.collisionCircleArrays[Gi];
              Mi === void 0 && (Mi = this.collisionCircleArrays[Gi] = new tt());
              for (let fi = 0; fi < Yt.circles.length; fi += 4) Mi.circles.push(Yt.circles[fi + 0]), Mi.circles.push(Yt.circles[fi + 1]), Mi.circles.push(Yt.circles[fi + 2]), Mi.circles.push(Yt.collisionDetected ? 1 : 0);
            }
            const Eo = f.projection.name !== "globe";
            me = me && (Eo || !He), Ee = Ee && (Eo || !wt), this.placements[Ve] = new qe(Re || me, We || Ee, Ne || f.justReloaded), o.add(Ve);
          };
          if (ge) {
            const be = f.getSortedSymbolIndexes(this.transform.angle);
            for (let Oe = be.length - 1; Oe >= 0; --Oe) {
              const Ce = be[Oe];
              Ge(f.symbolInstances.get(Ce), Ce, f.collisionArrays[Ce]);
            }
          } else for (let be = r.symbolInstanceStart; be < r.symbolInstanceEnd; be++) Ge(f.symbolInstances.get(be), be, f.collisionArrays[be]);
          if (u && f.bucketInstanceId in this.collisionCircleArrays) {
            const be = this.collisionCircleArrays[f.bucketInstanceId];
            s.invert(be.invProjMatrix, x), be.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          f.justReloaded = !1;
        }
        markUsedJustification(r, o, u, d) {
          const { leftJustifiedTextSymbolIndex: f, centerJustifiedTextSymbolIndex: g, rightJustifiedTextSymbolIndex: x, verticalPlacedTextSymbolIndex: b, crossTileID: M } = u, S = s.getAnchorJustification(o), P = d === s.WritingMode.vertical ? b : S === "left" ? f : S === "center" ? g : S === "right" ? x : -1;
          f >= 0 && (r.text.placedSymbolArray.get(f).crossTileID = P >= 0 && f !== P ? 0 : M), g >= 0 && (r.text.placedSymbolArray.get(g).crossTileID = P >= 0 && g !== P ? 0 : M), x >= 0 && (r.text.placedSymbolArray.get(x).crossTileID = P >= 0 && x !== P ? 0 : M), b >= 0 && (r.text.placedSymbolArray.get(b).crossTileID = P >= 0 && b !== P ? 0 : M);
        }
        markUsedOrientation(r, o, u) {
          const d = o === s.WritingMode.horizontal || o === s.WritingMode.horizontalOnly ? o : 0, f = o === s.WritingMode.vertical ? o : 0, { leftJustifiedTextSymbolIndex: g, centerJustifiedTextSymbolIndex: x, rightJustifiedTextSymbolIndex: b, verticalPlacedTextSymbolIndex: M } = u, S = r.text.placedSymbolArray;
          g >= 0 && (S.get(g).placedOrientation = d), x >= 0 && (S.get(x).placedOrientation = d), b >= 0 && (S.get(b).placedOrientation = d), M >= 0 && (S.get(M).placedOrientation = f);
        }
        commit(r) {
          this.commitTime = r, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const o = this.prevPlacement;
          let u = !1;
          this.prevZoomAdjustment = o ? o.zoomAdjustment(this.transform.zoom) : 0;
          const d = o ? o.symbolFadeChange(r) : 1, f = o ? o.opacities : {}, g = o ? o.variableOffsets : {}, x = o ? o.placedOrientations : {};
          for (const b in this.placements) {
            const M = this.placements[b], S = f[b];
            S ? (this.opacities[b] = new _e(S, d, M.text, M.icon, null, M.clipped), u = u || M.text !== S.text.placed || M.icon !== S.icon.placed) : (this.opacities[b] = new _e(null, d, M.text, M.icon, M.skipFade, M.clipped), u = u || M.text || M.icon);
          }
          for (const b in f) {
            const M = f[b];
            if (!this.opacities[b]) {
              const S = new _e(M, d, !1, !1);
              S.isHidden() || (this.opacities[b] = S, u = u || M.text.placed || M.icon.placed);
            }
          }
          for (const b in g) this.variableOffsets[b] || !this.opacities[b] || this.opacities[b].isHidden() || (this.variableOffsets[b] = g[b]);
          for (const b in x) this.placedOrientations[b] || !this.opacities[b] || this.opacities[b].isHidden() || (this.placedOrientations[b] = x[b]);
          u ? this.lastPlacementChangeTime = r : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = o ? o.lastPlacementChangeTime : r);
        }
        updateLayerOpacities(r, o) {
          const u = /* @__PURE__ */ new Set();
          for (const d of o) {
            const f = d.getBucket(r);
            f && d.latestFeatureIndex && r.id === f.layerIds[0] && this.updateBucketOpacities(f, u, d.collisionBoxArray);
          }
        }
        updateBucketOpacities(r, o, u) {
          r.hasTextData() && r.text.opacityVertexArray.clear(), r.hasIconData() && r.icon.opacityVertexArray.clear(), r.hasIconCollisionBoxData() && r.iconCollisionBox.collisionVertexArray.clear(), r.hasTextCollisionBoxData() && r.textCollisionBox.collisionVertexArray.clear();
          const d = r.layers[0].layout, f = !!r.layers[0].dynamicFilter(), g = new _e(null, 0, !1, !1, !0), x = d.get("text-allow-overlap"), b = d.get("icon-allow-overlap"), M = d.get("text-variable-anchor"), S = d.get("text-rotation-alignment") === "map", P = d.get("text-pitch-alignment") === "map", F = d.get("icon-text-fit") !== "none", j = new _e(null, 0, x && (b || !r.hasIconData() || d.get("icon-optional")), b && (x || !r.hasTextData() || d.get("text-optional")), !0);
          !r.collisionArrays && u && (r.hasIconCollisionBoxData() || r.hasTextCollisionBoxData()) && r.deserializeCollisionBoxes(u);
          const $ = (Z, L, N) => {
            for (let X = 0; X < L / 4; X++) Z.opacityVertexArray.emplaceBack(N);
          };
          let G = 0;
          for (let Z = 0; Z < r.symbolInstances.length; Z++) {
            const L = r.symbolInstances.get(Z), { numHorizontalGlyphVertices: N, numVerticalGlyphVertices: X, crossTileID: K, numIconVertices: le } = L, ue = o.has(K);
            let ce = this.opacities[K];
            ue ? ce = g : ce || (ce = j, this.opacities[K] = ce), o.add(K);
            const ge = N > 0 || X > 0, me = le > 0, Ee = this.placedOrientations[K], Ge = Ee === s.WritingMode.vertical, be = Ee === s.WritingMode.horizontal || Ee === s.WritingMode.horizontalOnly;
            if (!ge && !me || ce.isHidden() || G++, ge) {
              const Oe = Ss(ce.text);
              $(r.text, N, Ge ? Ft : Oe), $(r.text, X, be ? Ft : Oe);
              const Ce = ce.text.isHidden(), { leftJustifiedTextSymbolIndex: Ve, centerJustifiedTextSymbolIndex: Te, rightJustifiedTextSymbolIndex: Re, verticalPlacedTextSymbolIndex: We } = L, Ne = r.text.placedSymbolArray, He = Ce || Ge ? 1 : 0;
              Ve >= 0 && (Ne.get(Ve).hidden = He), Te >= 0 && (Ne.get(Te).hidden = He), Re >= 0 && (Ne.get(Re).hidden = He), We >= 0 && (Ne.get(We).hidden = Ce || be ? 1 : 0);
              const wt = this.variableOffsets[K];
              wt && this.markUsedJustification(r, wt.anchor, L, Ee);
              const Dt = this.placedOrientations[K];
              Dt && (this.markUsedJustification(r, "left", L, Dt), this.markUsedOrientation(r, Dt, L));
            }
            if (me) {
              const Oe = Ss(ce.icon), { placedIconSymbolIndex: Ce, verticalPlacedIconSymbolIndex: Ve } = L, Te = r.icon.placedSymbolArray, Re = ce.icon.isHidden() ? 1 : 0;
              Ce >= 0 && ($(r.icon, le, Ge ? Ft : Oe), Te.get(Ce).hidden = Re), Ve >= 0 && ($(r.icon, L.numVerticalIconVertices, be ? Ft : Oe), Te.get(Ve).hidden = Re);
            }
            if (r.hasIconCollisionBoxData() || r.hasTextCollisionBoxData()) {
              const Oe = r.collisionArrays[Z];
              if (Oe) {
                let Ce = new s.Point(0, 0), Ve = !0;
                if (Oe.textBox || Oe.verticalTextBox) {
                  if (M) {
                    const Re = this.variableOffsets[K];
                    Re ? (Ce = nt(Re.anchor, Re.width, Re.height, Re.textOffset, Re.textScale), S && Ce._rotate(P ? this.transform.angle : -this.transform.angle)) : Ve = !1;
                  }
                  f && (Ve = !ce.clipped), Oe.textBox && Ot(r.textCollisionBox.collisionVertexArray, ce.text.placed, !Ve || Ge, Ce.x, Ce.y), Oe.verticalTextBox && Ot(r.textCollisionBox.collisionVertexArray, ce.text.placed, !Ve || be, Ce.x, Ce.y);
                }
                const Te = Ve && !!(!be && Oe.verticalIconBox);
                Oe.iconBox && Ot(r.iconCollisionBox.collisionVertexArray, ce.icon.placed, Te, F ? Ce.x : 0, F ? Ce.y : 0), Oe.verticalIconBox && Ot(r.iconCollisionBox.collisionVertexArray, ce.icon.placed, !Te, F ? Ce.x : 0, F ? Ce.y : 0);
              }
            }
          }
          if (r.fullyClipped = G === 0, r.sortFeatures(this.transform.angle), this.retainedQueryData[r.bucketInstanceId] && (this.retainedQueryData[r.bucketInstanceId].featureSortOrder = r.featureSortOrder), r.hasTextData() && r.text.opacityVertexBuffer && r.text.opacityVertexBuffer.updateData(r.text.opacityVertexArray), r.hasIconData() && r.icon.opacityVertexBuffer && r.icon.opacityVertexBuffer.updateData(r.icon.opacityVertexArray), r.hasIconCollisionBoxData() && r.iconCollisionBox.collisionVertexBuffer && r.iconCollisionBox.collisionVertexBuffer.updateData(r.iconCollisionBox.collisionVertexArray), r.hasTextCollisionBoxData() && r.textCollisionBox.collisionVertexBuffer && r.textCollisionBox.collisionVertexBuffer.updateData(r.textCollisionBox.collisionVertexArray), r.bucketInstanceId in this.collisionCircleArrays) {
            const Z = this.collisionCircleArrays[r.bucketInstanceId];
            r.placementInvProjMatrix = Z.invProjMatrix, r.placementViewportMatrix = Z.viewportMatrix, r.collisionCircleArray = Z.circles, delete this.collisionCircleArrays[r.bucketInstanceId];
          }
        }
        symbolFadeChange(r) {
          return this.fadeDuration === 0 ? 1 : (r - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(r) {
          return Math.max(0, (this.transform.zoom - r) / 1.5);
        }
        hasTransitions(r) {
          return this.stale || r - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(r, o) {
          const u = this.zoomAtLastRecencyCheck === o ? 1 - this.zoomAdjustment(o) : 1;
          return this.zoomAtLastRecencyCheck = o, this.commitTime + this.fadeDuration * u > r;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function Ot(l, r, o, u, d) {
        l.emplaceBack(r ? 1 : 0, o ? 1 : 0, u || 0, d || 0), l.emplaceBack(r ? 1 : 0, o ? 1 : 0, u || 0, d || 0), l.emplaceBack(r ? 1 : 0, o ? 1 : 0, u || 0, d || 0), l.emplaceBack(r ? 1 : 0, o ? 1 : 0, u || 0, d || 0);
      }
      const pi = Math.pow(2, 25), De = Math.pow(2, 24), bt = Math.pow(2, 17), gi = Math.pow(2, 16), yi = Math.pow(2, 9), xi = Math.pow(2, 8), Js = Math.pow(2, 1);
      function Ss(l) {
        if (l.opacity === 0 && !l.placed) return 0;
        if (l.opacity === 1 && l.placed) return 4294967295;
        const r = l.placed ? 1 : 0, o = Math.floor(127 * l.opacity);
        return o * pi + r * De + o * bt + r * gi + o * yi + r * xi + o * Js + r;
      }
      const Ft = 0;
      class rs {
        constructor(r) {
          this._sortAcrossTiles = r.layout.get("symbol-z-order") !== "viewport-y" && r.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
        }
        continuePlacement(r, o, u, d, f) {
          const g = this._bucketParts;
          for (; this._currentTileIndex < r.length; ) if (o.getBucketParts(g, d, r[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, f()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, g.sort((x, b) => x.sortKey - b.sortKey)); this._currentPartIndex < g.length; ) {
            const x = g[this._currentPartIndex];
            if (o.placeLayerBucketPart(x, this._seenCrossTileIDs, u, x.symbolInstanceStart === 0), this._currentPartIndex++, f()) return !0;
          }
          return !1;
        }
      }
      class Pa {
        constructor(r, o, u, d, f, g, x, b) {
          this.placement = new Oi(r, f, g, x, b), this._currentPlacementIndex = o.length - 1, this._forceFullPlacement = u, this._showCollisionBoxes = d, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(r, o, u) {
          const d = s.exported.now(), f = () => {
            const g = s.exported.now() - d;
            return !this._forceFullPlacement && g > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const g = o[r[this._currentPlacementIndex]], x = this.placement.collisionIndex.transform.zoom;
            if (g.type === "symbol" && (!g.minzoom || g.minzoom <= x) && (!g.maxzoom || g.maxzoom > x)) {
              if (this._inProgressLayer || (this._inProgressLayer = new rs(g)), this._inProgressLayer.continuePlacement(u[g.source], this.placement, this._showCollisionBoxes, g, f)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(r) {
          return this.placement.commit(r), this.placement;
        }
      }
      const Ar = 512 / s.EXTENT / 2;
      class yr {
        constructor(r, o, u) {
          this.tileID = r, this.bucketInstanceId = u, this.index = new s.KDBush(o.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
          const d = r.canonical.x * s.EXTENT, f = r.canonical.y * s.EXTENT;
          for (let g = 0; g < o.length; g++) {
            const { key: x, crossTileID: b, tileAnchorX: M, tileAnchorY: S } = o.get(g), P = Math.floor((d + M) * Ar), F = Math.floor((f + S) * Ar);
            this.index.add(P, F), this.keys.push(x), this.crossTileIDs.push(b);
          }
          this.index.finish();
        }
        findMatches(r, o, u) {
          const d = this.tileID.canonical.z < o.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - o.canonical.z), f = Ar / Math.pow(2, o.canonical.z - this.tileID.canonical.z), g = o.canonical.x * s.EXTENT, x = o.canonical.y * s.EXTENT;
          for (let b = 0; b < r.length; b++) {
            const M = r.get(b);
            if (M.crossTileID) continue;
            const { key: S, tileAnchorX: P, tileAnchorY: F } = M, j = Math.floor((g + P) * f), $ = Math.floor((x + F) * f), G = this.index.range(j - d, $ - d, j + d, $ + d);
            for (const Z of G) {
              const L = this.crossTileIDs[Z];
              if (this.keys[Z] === S && !u.has(L)) {
                u.add(L), M.crossTileID = L;
                break;
              }
            }
          }
        }
      }
      class Ys {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Qs {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(r) {
          const o = Math.round((r - this.lng) / 360);
          if (o !== 0) for (const u in this.indexes) {
            const d = this.indexes[u], f = {};
            for (const g in d) {
              const x = d[g];
              x.tileID = x.tileID.unwrapTo(x.tileID.wrap + o), f[x.tileID.key] = x;
            }
            this.indexes[u] = f;
          }
          this.lng = r;
        }
        addBucket(r, o, u) {
          if (this.indexes[r.overscaledZ] && this.indexes[r.overscaledZ][r.key]) {
            if (this.indexes[r.overscaledZ][r.key].bucketInstanceId === o.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(r.overscaledZ, this.indexes[r.overscaledZ][r.key]);
          }
          for (let f = 0; f < o.symbolInstances.length; f++) o.symbolInstances.get(f).crossTileID = 0;
          this.usedCrossTileIDs[r.overscaledZ] || (this.usedCrossTileIDs[r.overscaledZ] = /* @__PURE__ */ new Set());
          const d = this.usedCrossTileIDs[r.overscaledZ];
          for (const f in this.indexes) {
            const g = this.indexes[f];
            if (Number(f) > r.overscaledZ) for (const x in g) {
              const b = g[x];
              b.tileID.isChildOf(r) && b.findMatches(o.symbolInstances, r, d);
            }
            else {
              const x = g[r.scaledTo(Number(f)).key];
              x && x.findMatches(o.symbolInstances, r, d);
            }
          }
          for (let f = 0; f < o.symbolInstances.length; f++) {
            const g = o.symbolInstances.get(f);
            g.crossTileID || (g.crossTileID = u.generate(), d.add(g.crossTileID));
          }
          return this.indexes[r.overscaledZ] === void 0 && (this.indexes[r.overscaledZ] = {}), this.indexes[r.overscaledZ][r.key] = new yr(r, o.symbolInstances, o.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(r, o) {
          for (const u of o.crossTileIDs) this.usedCrossTileIDs[r].delete(u);
        }
        removeStaleBuckets(r) {
          let o = !1;
          for (const u in this.indexes) {
            const d = this.indexes[u];
            for (const f in d) r[d[f].bucketInstanceId] || (this.removeBucketCrossTileIDs(u, d[f]), delete d[f], o = !0);
          }
          return o;
        }
      }
      class xn {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Ys(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(r, o, u, d) {
          let f = this.layerIndexes[r.id];
          f === void 0 && (f = this.layerIndexes[r.id] = new Qs());
          let g = !1;
          const x = {};
          d.name !== "globe" && f.handleWrapJump(u);
          for (const b of o) {
            const M = b.getBucket(r);
            M && r.id === M.layerIds[0] && (M.bucketInstanceId || (M.bucketInstanceId = ++this.maxBucketInstanceId), f.addBucket(b.tileID, M, this.crossTileIDs) && (g = !0), x[M.bucketInstanceId] = !0);
          }
          return f.removeStaleBuckets(x) && (g = !0), g;
        }
        pruneUnusedLayers(r) {
          const o = {};
          r.forEach((u) => {
            o[u] = !0;
          });
          for (const u in this.layerIndexes) o[u] || delete this.layerIndexes[u];
        }
      }
      const Zn = (l, r) => s.emitValidationErrors(l, r && r.filter((o) => o.identifier !== "source.canvas")), Ms = s.pick(ai, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), dc = s.pick(ai, ["setCenter", "setZoom", "setBearing", "setPitch"]), La = { version: 8, layers: [], sources: {} }, ns = { fill: !0, line: !0, background: !0, hillshade: !0, raster: !0 };
      class vn extends s.Evented {
        constructor(r, o = {}) {
          super(), this.map = r, this.dispatcher = new Zi(is(), this), this.imageManager = new or(), this.imageManager.setEventedParent(this), this.glyphManager = new s.GlyphManager(r._requestManager, o.localFontFamily ? s.LocalGlyphMode.all : o.localIdeographFontFamily ? s.LocalGlyphMode.ideographs : s.LocalGlyphMode.none, o.localFontFamily || o.localIdeographFontFamily), this.crossTileSymbolIndex = new xn(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", s.getReferrer());
          const u = this;
          this._rtlTextPluginCallback = vn.registerForPluginStateChange((d) => {
            u.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: d.pluginStatus, pluginURL: d.pluginURL }, (f, g) => {
              if (s.triggerPluginCompletionEvent(f), g && g.every((x) => x)) for (const x in u._sourceCaches) {
                const b = u._sourceCaches[x], M = b.getSource().type;
                M !== "vector" && M !== "geojson" || b.reload();
              }
            });
          }), this.on("data", (d) => {
            if (d.dataType !== "source" || d.sourceDataType !== "metadata") return;
            const f = this.getSource(d.sourceId);
            if (f && f.vectorLayerIds) for (const g in this._layers) {
              const x = this._layers[g];
              x.source === f.id && this._validateLayer(x);
            }
          });
        }
        loadURL(r, o = {}) {
          this.fire(new s.Event("dataloading", { dataType: "style" }));
          const u = typeof o.validate == "boolean" ? o.validate : !s.isMapboxURL(r);
          r = this.map._requestManager.normalizeStyleURL(r, o.accessToken);
          const d = this.map._requestManager.transformRequest(r, s.ResourceType.Style);
          this._request = s.getJSON(d, (f, g) => {
            this._request = null, f ? this.fire(new s.ErrorEvent(f)) : g && this._load(g, u);
          });
        }
        loadJSON(r, o = {}) {
          this.fire(new s.Event("dataloading", { dataType: "style" })), this._request = s.exported.frame(() => {
            this._request = null, this._load(r, o.validate !== !1);
          });
        }
        loadEmpty() {
          this.fire(new s.Event("dataloading", { dataType: "style" })), this._load(La, !1);
        }
        _updateLayerCount(r, o) {
          const u = o ? 1 : -1;
          r.is3D() && (this._num3DLayers += u), r.type === "circle" && (this._numCircleLayers += u), r.type === "symbol" && (this._numSymbolLayers += u);
        }
        _load(r, o) {
          if (o && Zn(this, s.validateStyle(r))) return;
          this._loaded = !0, this.stylesheet = s.clone$1(r), this._updateMapProjection();
          for (const d in r.sources) this.addSource(d, r.sources[d], { validate: !1 });
          this._changed = !1, r.sprite ? this._loadSprite(r.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast("spriteLoaded", !0)), this.glyphManager.setURL(r.glyphs);
          const u = yl(this.stylesheet.layers);
          this._order = u.map((d) => d.id), this._layers = {}, this._serializedLayers = {};
          for (const d of u) {
            const f = s.createStyleLayer(d);
            f.setEventedParent(this, { layer: { id: f.id } }), this._layers[f.id] = f, this._serializedLayers[f.id] = f.serialize(), this._updateLayerCount(f, !0);
          }
          this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new Fi(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new s.Event("data", { dataType: "style" })), this.fire(new s.Event("style.load"));
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && this.terrain.drapeRenderMode === 0;
        }
        setProjection(r) {
          r ? this.stylesheet.projection = r : delete this.stylesheet.projection, this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
        }
        _updateMapProjection() {
          this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
        }
        _loadSprite(r) {
          this._spriteRequest = function(o, u, d) {
            let f, g, x;
            const b = s.exported.devicePixelRatio > 1 ? "@2x" : "";
            let M = s.getJSON(u.transformRequest(u.normalizeSpriteURL(o, b, ".json"), s.ResourceType.SpriteJSON), (F, j) => {
              M = null, x || (x = F, f = j, P());
            }), S = s.getImage(u.transformRequest(u.normalizeSpriteURL(o, b, ".png"), s.ResourceType.SpriteImage), (F, j) => {
              S = null, x || (x = F, g = j, P());
            });
            function P() {
              if (x) d(x);
              else if (f && g) {
                const F = s.exported.getImageData(g), j = {};
                for (const $ in f) {
                  const { width: G, height: Z, x: L, y: N, sdf: X, pixelRatio: K, stretchX: le, stretchY: ue, content: ce } = f[$], ge = new s.RGBAImage({ width: G, height: Z });
                  s.RGBAImage.copy(F, ge, { x: L, y: N }, { x: 0, y: 0 }, { width: G, height: Z }), j[$] = { data: ge, pixelRatio: K, sdf: X, stretchX: le, stretchY: ue, content: ce };
                }
                d(null, j);
              }
            }
            return { cancel() {
              M && (M.cancel(), M = null), S && (S.cancel(), S = null);
            } };
          }(r, this.map._requestManager, (o, u) => {
            if (this._spriteRequest = null, o) this.fire(new s.ErrorEvent(o));
            else if (u) for (const d in u) this.imageManager.addImage(d, u[d]);
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", !0), this.fire(new s.Event("data", { dataType: "style" }));
          });
        }
        _validateLayer(r) {
          const o = this.getSource(r.source);
          if (!o) return;
          const u = r.sourceLayer;
          u && (o.type === "geojson" || o.vectorLayerIds && o.vectorLayerIds.indexOf(u) === -1) && this.fire(new s.ErrorEvent(new Error(`Source layer "${u}" does not exist on source "${o.id}" as specified by style layer "${r.id}"`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const r in this._sourceCaches) if (!this._sourceCaches[r].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeLayers(r) {
          const o = [];
          for (const u of r) {
            const d = this._layers[u];
            d.type !== "custom" && o.push(d.serialize());
          }
          return o;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition() || this.fog && this.fog.hasTransition()) return !0;
          for (const r in this._sourceCaches) if (this._sourceCaches[r].hasTransition()) return !0;
          for (const r in this._layers) if (this._layers[r].hasTransition()) return !0;
          return !1;
        }
        get order() {
          return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
        }
        isLayerDraped(r) {
          return !!this.terrain && (typeof r.isLayerDraped == "function" ? r.isLayerDraped() : ns[r.type]);
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading");
        }
        update(r) {
          if (!this._loaded) return;
          const o = this._changed;
          if (this._changed) {
            const d = Object.keys(this._updatedLayers), f = Object.keys(this._removedLayers);
            (d.length || f.length) && this._updateWorkerLayers(d, f);
            for (const g in this._updatedSources) {
              const x = this._updatedSources[g];
              x === "reload" ? this._reloadSource(g) : x === "clear" && this._clearSource(g);
            }
            this._updateTilesForChangedImages();
            for (const g in this._updatedPaintProps) this._layers[g].updateTransitions(r);
            this.light.updateTransitions(r), this.fog && this.fog.updateTransitions(r), this._resetUpdates();
          }
          const u = {};
          for (const d in this._sourceCaches) {
            const f = this._sourceCaches[d];
            u[d] = f.used, f.used = !1;
          }
          for (const d of this._order) {
            const f = this._layers[d];
            if (f.recalculate(r, this._availableImages), !f.isHidden(r.zoom)) {
              const x = this._getLayerSourceCache(f);
              x && (x.used = !0);
            }
            const g = this.map.painter;
            if (g) {
              const x = f.getProgramIds();
              if (!x) continue;
              const b = f.getProgramConfiguration(r.zoom);
              for (const M of x) g.useProgram(M, b);
            }
          }
          for (const d in u) {
            const f = this._sourceCaches[d];
            u[d] !== f.used && f.getSource().fire(new s.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: f.getSource().id }));
          }
          this.light.recalculate(r), this.terrain && this.terrain.recalculate(r), this.fog && this.fog.recalculate(r), this.z = r.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), o && this.fire(new s.Event("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const r = Object.keys(this._changedImages);
          if (r.length) {
            for (const o in this._sourceCaches) this._sourceCaches[o].reloadTilesForDependencies(["icons", "patterns"], r);
            this._changedImages = {};
          }
        }
        _updateWorkerLayers(r, o) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(r), removedIds: o });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }
        setState(r) {
          if (this._checkLoaded(), Zn(this, s.validateStyle(r))) return !1;
          (r = s.clone$1(r)).layers = yl(r.layers);
          const o = function(d, f) {
            if (!d) return [{ command: ai.setStyle, args: [f] }];
            let g = [];
            try {
              if (!re(d.version, f.version)) return [{ command: ai.setStyle, args: [f] }];
              re(d.center, f.center) || g.push({ command: ai.setCenter, args: [f.center] }), re(d.zoom, f.zoom) || g.push({ command: ai.setZoom, args: [f.zoom] }), re(d.bearing, f.bearing) || g.push({ command: ai.setBearing, args: [f.bearing] }), re(d.pitch, f.pitch) || g.push({ command: ai.setPitch, args: [f.pitch] }), re(d.sprite, f.sprite) || g.push({ command: ai.setSprite, args: [f.sprite] }), re(d.glyphs, f.glyphs) || g.push({ command: ai.setGlyphs, args: [f.glyphs] }), re(d.transition, f.transition) || g.push({ command: ai.setTransition, args: [f.transition] }), re(d.light, f.light) || g.push({ command: ai.setLight, args: [f.light] }), re(d.fog, f.fog) || g.push({ command: ai.setFog, args: [f.fog] }), re(d.projection, f.projection) || g.push({ command: ai.setProjection, args: [f.projection] });
              const x = {}, b = [];
              (function(P, F, j, $) {
                let G;
                for (G in F = F || {}, P = P || {}) P.hasOwnProperty(G) && (F.hasOwnProperty(G) || zo(G, j, $));
                for (G in F) {
                  if (!F.hasOwnProperty(G)) continue;
                  const Z = F[G];
                  P.hasOwnProperty(G) ? re(P[G], Z) || (P[G].type === "geojson" && Z.type === "geojson" && ko(P, F, G) ? j.push({ command: ai.setGeoJSONSourceData, args: [G, Z.data] }) : Ca(G, F, j, $)) : Ma(G, F, j);
                }
              })(d.sources, f.sources, b, x);
              const M = [];
              d.layers && d.layers.forEach((P) => {
                P.source && x[P.source] ? g.push({ command: ai.removeLayer, args: [P.id] }) : M.push(P);
              });
              let S = d.terrain;
              S && x[S.source] && (g.push({ command: ai.setTerrain, args: [void 0] }), S = void 0), g = g.concat(b), re(S, f.terrain) || g.push({ command: ai.setTerrain, args: [f.terrain] }), function(P, F, j) {
                F = F || [];
                const $ = (P = P || []).map(gn), G = F.map(gn), Z = P.reduce(Yi, {}), L = F.reduce(Yi, {}), N = $.slice(), X = /* @__PURE__ */ Object.create(null);
                let K, le, ue, ce, ge, me, Ee;
                for (K = 0, le = 0; K < $.length; K++) ue = $[K], L.hasOwnProperty(ue) ? le++ : (j.push({ command: ai.removeLayer, args: [ue] }), N.splice(N.indexOf(ue, le), 1));
                for (K = 0, le = 0; K < G.length; K++) ue = G[G.length - 1 - K], N[N.length - 1 - K] !== ue && (Z.hasOwnProperty(ue) ? (j.push({ command: ai.removeLayer, args: [ue] }), N.splice(N.lastIndexOf(ue, N.length - le), 1)) : le++, me = N[N.length - K], j.push({ command: ai.addLayer, args: [L[ue], me] }), N.splice(N.length - K, 0, ue), X[ue] = !0);
                for (K = 0; K < G.length; K++) if (ue = G[K], ce = Z[ue], ge = L[ue], !X[ue] && !re(ce, ge)) if (re(ce.source, ge.source) && re(ce["source-layer"], ge["source-layer"]) && re(ce.type, ge.type)) {
                  for (Ee in rn(ce.layout, ge.layout, j, ue, null, ai.setLayoutProperty), rn(ce.paint, ge.paint, j, ue, null, ai.setPaintProperty), re(ce.filter, ge.filter) || j.push({ command: ai.setFilter, args: [ue, ge.filter] }), re(ce.minzoom, ge.minzoom) && re(ce.maxzoom, ge.maxzoom) || j.push({ command: ai.setLayerZoomRange, args: [ue, ge.minzoom, ge.maxzoom] }), ce) ce.hasOwnProperty(Ee) && Ee !== "layout" && Ee !== "paint" && Ee !== "filter" && Ee !== "metadata" && Ee !== "minzoom" && Ee !== "maxzoom" && (Ee.indexOf("paint.") === 0 ? rn(ce[Ee], ge[Ee], j, ue, Ee.slice(6), ai.setPaintProperty) : re(ce[Ee], ge[Ee]) || j.push({ command: ai.setLayerProperty, args: [ue, Ee, ge[Ee]] }));
                  for (Ee in ge) ge.hasOwnProperty(Ee) && !ce.hasOwnProperty(Ee) && Ee !== "layout" && Ee !== "paint" && Ee !== "filter" && Ee !== "metadata" && Ee !== "minzoom" && Ee !== "maxzoom" && (Ee.indexOf("paint.") === 0 ? rn(ce[Ee], ge[Ee], j, ue, Ee.slice(6), ai.setPaintProperty) : re(ce[Ee], ge[Ee]) || j.push({ command: ai.setLayerProperty, args: [ue, Ee, ge[Ee]] }));
                } else j.push({ command: ai.removeLayer, args: [ue] }), me = N[N.lastIndexOf(ue) + 1], j.push({ command: ai.addLayer, args: [ge, me] });
              }(M, f.layers, g);
            } catch (x) {
              console.warn("Unable to compute style diff:", x), g = [{ command: ai.setStyle, args: [f] }];
            }
            return g;
          }(this.serialize(), r).filter((d) => !(d.command in dc));
          if (o.length === 0) return !1;
          const u = o.filter((d) => !(d.command in Ms));
          if (u.length > 0) throw new Error(`Unimplemented: ${u.map((d) => d.command).join(", ")}.`);
          return o.forEach((d) => {
            d.command !== "setTransition" && d.command !== "setProjection" && this[d.command].apply(this, d.args);
          }), this.stylesheet = r, this._updateMapProjection(), !0;
        }
        addImage(r, o) {
          return this.getImage(r) ? this.fire(new s.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(r, o), this._afterImageUpdated(r), this);
        }
        updateImage(r, o) {
          this.imageManager.updateImage(r, o);
        }
        getImage(r) {
          return this.imageManager.getImage(r);
        }
        removeImage(r) {
          return this.getImage(r) ? (this.imageManager.removeImage(r), this._afterImageUpdated(r), this) : this.fire(new s.ErrorEvent(new Error("No image with this name exists.")));
        }
        _afterImageUpdated(r) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[r] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new s.Event("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addSource(r, o, u = {}) {
          if (this._checkLoaded(), this.getSource(r) !== void 0) throw new Error("There is already a source with this ID");
          if (!o.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(o).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(o.type) >= 0 && this._validate(s.validateSource, `sources.${r}`, o, null, u)) return;
          this.map && this.map._collectResourceTiming && (o.collectResourceTiming = !0);
          const d = qt(r, o, this.dispatcher, this);
          d.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(r), source: d.serialize(), sourceId: r }));
          const f = (g) => {
            const x = (g ? "symbol:" : "other:") + r, b = this._sourceCaches[x] = new s.SourceCache(x, d, g);
            (g ? this._symbolSourceCaches : this._otherSourceCaches)[r] = b, b.style = this, b.onAdd(this.map);
          };
          f(!1), o.type !== "vector" && o.type !== "geojson" || f(!0), d.onAdd && d.onAdd(this.map), this._changed = !0;
        }
        removeSource(r) {
          this._checkLoaded();
          const o = this.getSource(r);
          if (!o) throw new Error("There is no source with this ID");
          for (const d in this._layers) if (this._layers[d].source === r) return this.fire(new s.ErrorEvent(new Error(`Source "${r}" cannot be removed while layer "${d}" is using it.`)));
          if (this.terrain && this.terrain.get().source === r) return this.fire(new s.ErrorEvent(new Error(`Source "${r}" cannot be removed while terrain is using it.`)));
          const u = this._getSourceCaches(r);
          for (const d of u) delete this._sourceCaches[d.id], delete this._updatedSources[d.id], d.fire(new s.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: d.getSource().id })), d.setEventedParent(null), d.clearTiles();
          return delete this._otherSourceCaches[r], delete this._symbolSourceCaches[r], o.setEventedParent(null), o.onRemove && o.onRemove(this.map), this._changed = !0, this;
        }
        setGeoJSONSourceData(r, o) {
          this._checkLoaded(), this.getSource(r).setData(o), this._changed = !0;
        }
        getSource(r) {
          const o = this._getSourceCache(r);
          return o && o.getSource();
        }
        _getSources() {
          const r = [];
          for (const o in this._otherSourceCaches) {
            const u = this._getSourceCache(o);
            u && r.push(u.getSource());
          }
          return r;
        }
        addLayer(r, o, u = {}) {
          this._checkLoaded();
          const d = r.id;
          if (this.getLayer(d)) return void this.fire(new s.ErrorEvent(new Error(`Layer with id "${d}" already exists on this map`)));
          let f;
          if (r.type === "custom") {
            if (Zn(this, s.validateCustomStyleLayer(r))) return;
            f = s.createStyleLayer(r);
          } else {
            if (typeof r.source == "object" && (this.addSource(d, r.source), r = s.clone$1(r), r = s.extend(r, { source: d })), this._validate(s.validateLayer, `layers.${d}`, r, { arrayIndex: -1 }, u)) return;
            f = s.createStyleLayer(r), this._validateLayer(f), f.setEventedParent(this, { layer: { id: d } }), this._serializedLayers[f.id] = f.serialize(), this._updateLayerCount(f, !0);
          }
          const g = o ? this._order.indexOf(o) : this._order.length;
          if (o && g === -1) return void this.fire(new s.ErrorEvent(new Error(`Layer with id "${o}" does not exist on this map.`)));
          this._order.splice(g, 0, d), this._layerOrderChanged = !0, this._layers[d] = f;
          const x = this._getLayerSourceCache(f);
          if (this._removedLayers[d] && f.source && x && f.type !== "custom") {
            const b = this._removedLayers[d];
            delete this._removedLayers[d], b.type !== f.type ? this._updatedSources[f.source] = "clear" : (this._updatedSources[f.source] = "reload", x.pause());
          }
          this._updateLayer(f), f.onAdd && f.onAdd(this.map), this._updateDrapeFirstLayers();
        }
        moveLayer(r, o) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[r]) return void this.fire(new s.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style and cannot be moved.`)));
          if (r === o) return;
          const u = this._order.indexOf(r);
          this._order.splice(u, 1);
          const d = o ? this._order.indexOf(o) : this._order.length;
          o && d === -1 ? this.fire(new s.ErrorEvent(new Error(`Layer with id "${o}" does not exist on this map.`))) : (this._order.splice(d, 0, r), this._layerOrderChanged = !0, this._updateDrapeFirstLayers());
        }
        removeLayer(r) {
          this._checkLoaded();
          const o = this._layers[r];
          if (!o) return void this.fire(new s.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style and cannot be removed.`)));
          o.setEventedParent(null), this._updateLayerCount(o, !1);
          const u = this._order.indexOf(r);
          this._order.splice(u, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[r] = o, delete this._layers[r], delete this._serializedLayers[r], delete this._updatedLayers[r], delete this._updatedPaintProps[r], o.onRemove && o.onRemove(this.map), this._updateDrapeFirstLayers();
        }
        getLayer(r) {
          return this._layers[r];
        }
        hasLayer(r) {
          return r in this._layers;
        }
        hasLayerType(r) {
          for (const o in this._layers) if (this._layers[o].type === r) return !0;
          return !1;
        }
        setLayerZoomRange(r, o, u) {
          this._checkLoaded();
          const d = this.getLayer(r);
          d ? d.minzoom === o && d.maxzoom === u || (o != null && (d.minzoom = o), u != null && (d.maxzoom = u), this._updateLayer(d)) : this.fire(new s.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style and cannot have zoom extent.`)));
        }
        setFilter(r, o, u = {}) {
          this._checkLoaded();
          const d = this.getLayer(r);
          if (d) {
            if (!re(d.filter, o)) return o == null ? (d.filter = void 0, void this._updateLayer(d)) : void (this._validate(s.validateFilter, `layers.${d.id}.filter`, o, { layerType: d.type }, u) || (d.filter = s.clone$1(o), this._updateLayer(d)));
          } else this.fire(new s.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style and cannot be filtered.`)));
        }
        getFilter(r) {
          const o = this.getLayer(r);
          return o && s.clone$1(o.filter);
        }
        setLayoutProperty(r, o, u, d = {}) {
          this._checkLoaded();
          const f = this.getLayer(r);
          f ? re(f.getLayoutProperty(o), u) || (f.setLayoutProperty(o, u, d), this._updateLayer(f)) : this.fire(new s.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style and cannot be styled.`)));
        }
        getLayoutProperty(r, o) {
          const u = this.getLayer(r);
          if (u) return u.getLayoutProperty(o);
          this.fire(new s.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style.`)));
        }
        setPaintProperty(r, o, u, d = {}) {
          this._checkLoaded();
          const f = this.getLayer(r);
          f ? re(f.getPaintProperty(o), u) || (f.setPaintProperty(o, u, d) && this._updateLayer(f), this._changed = !0, this._updatedPaintProps[r] = !0) : this.fire(new s.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style and cannot be styled.`)));
        }
        getPaintProperty(r, o) {
          const u = this.getLayer(r);
          return u && u.getPaintProperty(o);
        }
        setFeatureState(r, o) {
          this._checkLoaded();
          const u = r.source, d = r.sourceLayer, f = this.getSource(u);
          if (!f) return void this.fire(new s.ErrorEvent(new Error(`The source '${u}' does not exist in the map's style.`)));
          const g = f.type;
          if (g === "geojson" && d) return void this.fire(new s.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if (g === "vector" && !d) return void this.fire(new s.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          r.id === void 0 && this.fire(new s.ErrorEvent(new Error("The feature id parameter must be provided.")));
          const x = this._getSourceCaches(u);
          for (const b of x) b.setFeatureState(d, r.id, o);
        }
        removeFeatureState(r, o) {
          this._checkLoaded();
          const u = r.source, d = this.getSource(u);
          if (!d) return void this.fire(new s.ErrorEvent(new Error(`The source '${u}' does not exist in the map's style.`)));
          const f = d.type, g = f === "vector" ? r.sourceLayer : void 0;
          if (f === "vector" && !g) return void this.fire(new s.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (o && typeof r.id != "string" && typeof r.id != "number") return void this.fire(new s.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
          const x = this._getSourceCaches(u);
          for (const b of x) b.removeFeatureState(g, r.id, o);
        }
        getFeatureState(r) {
          this._checkLoaded();
          const o = r.source, u = r.sourceLayer, d = this.getSource(o);
          if (d) {
            if (d.type !== "vector" || u) return r.id === void 0 && this.fire(new s.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(o)[0].getFeatureState(u, r.id);
            this.fire(new s.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else this.fire(new s.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
        }
        getTransition() {
          return s.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          const r = {};
          for (const o in this._sourceCaches) {
            const u = this._sourceCaches[o].getSource();
            r[u.id] || (r[u.id] = u.serialize());
          }
          return s.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.getTerrain() || void 0, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: r, layers: this._serializeLayers(this._order) }, (o) => o !== void 0);
        }
        _updateLayer(r) {
          this._updatedLayers[r.id] = !0;
          const o = this._getLayerSourceCache(r);
          r.source && !this._updatedSources[r.source] && o && o.getSource().type !== "raster" && (this._updatedSources[r.source] = "reload", o.pause()), this._changed = !0, r.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(r) {
          const o = (g) => this._layers[g].type === "fill-extrusion", u = {}, d = [];
          for (let g = this._order.length - 1; g >= 0; g--) {
            const x = this._order[g];
            if (o(x)) {
              u[x] = g;
              for (const b of r) {
                const M = b[x];
                if (M) for (const S of M) d.push(S);
              }
            }
          }
          d.sort((g, x) => x.intersectionZ - g.intersectionZ);
          const f = [];
          for (let g = this._order.length - 1; g >= 0; g--) {
            const x = this._order[g];
            if (o(x)) for (let b = d.length - 1; b >= 0; b--) {
              const M = d[b].feature;
              if (u[M.layer.id] < g) break;
              f.push(M), d.pop();
            }
            else for (const b of r) {
              const M = b[x];
              if (M) for (const S of M) f.push(S.feature);
            }
          }
          return f;
        }
        queryRenderedFeatures(r, o, u) {
          o && o.filter && this._validate(s.validateFilter, "queryRenderedFeatures.filter", o.filter, null, o);
          const d = {};
          if (o && o.layers) {
            if (!Array.isArray(o.layers)) return this.fire(new s.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (const b of o.layers) {
              const M = this._layers[b];
              if (!M) return this.fire(new s.ErrorEvent(new Error(`The layer '${b}' does not exist in the map's style and cannot be queried for features.`))), [];
              d[M.source] = !0;
            }
          }
          const f = [];
          o.availableImages = this._availableImages;
          const g = o && o.layers ? o.layers.some((b) => {
            const M = this.getLayer(b);
            return M && M.is3D();
          }) : this.has3DLayers(), x = Mn.createFromScreenPoints(r, u);
          for (const b in this._sourceCaches) {
            const M = this._sourceCaches[b].getSource().id;
            o.layers && !d[M] || f.push(bi(this._sourceCaches[b], this._layers, this._serializedLayers, x, o, u, g, !!this.map._showQueryGeometry));
          }
          return this.placement && f.push(function(b, M, S, P, F, j, $) {
            const G = {}, Z = j.queryRenderedSymbols(P), L = [];
            for (const N of Object.keys(Z).map(Number)) L.push($[N]);
            L.sort(ar);
            for (const N of L) {
              const X = N.featureIndex.lookupSymbolFeatures(Z[N.bucketInstanceId], M, N.bucketIndex, N.sourceLayerIndex, F.filter, F.layers, F.availableImages, b);
              for (const K in X) {
                const le = G[K] = G[K] || [], ue = X[K];
                ue.sort((ce, ge) => {
                  const me = N.featureSortOrder;
                  if (me) {
                    const Ee = me.indexOf(ce.featureIndex);
                    return me.indexOf(ge.featureIndex) - Ee;
                  }
                  return ge.featureIndex - ce.featureIndex;
                });
                for (const ce of ue) le.push(ce);
              }
            }
            for (const N in G) G[N].forEach((X) => {
              const K = X.feature, le = S(b[N]);
              if (!le) return;
              const ue = le.getFeatureState(K.layer["source-layer"], K.id);
              K.source = K.layer.source, K.layer["source-layer"] && (K.sourceLayer = K.layer["source-layer"]), K.state = ue;
            });
            return G;
          }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), x.screenGeometry, o, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(f);
        }
        querySourceFeatures(r, o) {
          o && o.filter && this._validate(s.validateFilter, "querySourceFeatures.filter", o.filter, null, o);
          const u = this._getSourceCaches(r);
          let d = [];
          for (const f of u) d = d.concat(Hi(f, o));
          return d;
        }
        addSourceType(r, o, u) {
          return vn.getSourceType(r) ? u(new Error(`A source type called "${r}" already exists.`)) : (vn.setSourceType(r, o), o.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: r, url: o.workerSourceURL }, u) : u(null, null));
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(r, o = {}) {
          this._checkLoaded();
          const u = this.light.getLight();
          let d = !1;
          for (const g in r) if (!re(r[g], u[g])) {
            d = !0;
            break;
          }
          if (!d) return;
          const f = this._setTransitionParameters({ duration: 300, delay: 0 });
          this.light.setLight(r, o), this.light.updateTransitions(f);
        }
        getTerrain() {
          return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        setTerrain(r, o = 1) {
          if (this._checkLoaded(), !r) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
          let u = r;
          if (o === 1) {
            if (typeof u.source == "object") {
              const d = "terrain-dem-src";
              this.addSource(d, u.source), u = s.clone$1(u), u = s.extend(u, { source: d });
            }
            if (this._validate(s.validateTerrain, "terrain", u)) return;
          }
          if (!this.terrain || this.terrain && o !== this.terrain.drapeRenderMode) {
            if (!u) return;
            this._createTerrain(u, o);
          } else {
            const d = this.terrain, f = d.get();
            for (const g of Object.keys(s.spec.terrain)) !u.hasOwnProperty(g) && s.spec.terrain[g].default && (u[g] = s.spec.terrain[g].default);
            for (const g in u) if (!re(u[g], f[g])) {
              d.set(u), this.stylesheet.terrain = u;
              const x = this._setTransitionParameters({ duration: 0 });
              d.updateTransitions(x);
              break;
            }
          }
          this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
        }
        _createFog(r) {
          const o = this.fog = new Sn(r, this.map.transform);
          this.stylesheet.fog = r;
          const u = this._setTransitionParameters({ duration: 0 });
          o.updateTransitions(u);
        }
        _updateMarkersOpacity() {
          this.map._markers.length !== 0 && this.map._requestDomTask(() => {
            for (const r of this.map._markers) r._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(r) {
          if (this._checkLoaded(), !r) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
          if (this.fog) {
            const o = this.fog, u = o.get();
            Object.keys(r).length === 0 && o.set(r);
            for (const d in r) if (!re(r[d], u[d])) {
              o.set(r), this.stylesheet.fog = r;
              const f = this._setTransitionParameters({ duration: 0 });
              o.updateTransitions(f);
              break;
            }
          } else this._createFog(r);
          this._markersNeedUpdate = !0;
        }
        _setTransitionParameters(r) {
          return { now: s.exported.now(), transition: s.extend(r, this.stylesheet.transition) };
        }
        _updateDrapeFirstLayers() {
          if (!this.map._optimizeForTerrain || !this.terrain) return;
          const r = this._order.filter((u) => this.isLayerDraped(this._layers[u])), o = this._order.filter((u) => !this.isLayerDraped(this._layers[u]));
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...r), this._drapedFirstOrder.push(...o);
        }
        _createTerrain(r, o) {
          const u = this.terrain = new Fn(r, o);
          this.stylesheet.terrain = r, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
          const d = this._setTransitionParameters({ duration: 0 });
          u.updateTransitions(d);
        }
        _force3DLayerUpdate() {
          for (const r in this._layers) {
            const o = this._layers[r];
            o.type === "fill-extrusion" && this._updateLayer(o);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const r in this._layers) {
            const o = this._layers[r];
            o.type === "symbol" && this._updateLayer(o);
          }
        }
        _validate(r, o, u, d, f = {}) {
          return (!f || f.validate !== !1) && Zn(this, r.call(s.validateStyle, s.extend({ key: o, style: this.serialize(), value: u, styleSpec: s.spec }, d)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), s.evented.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const r in this._layers) this._layers[r].setEventedParent(null);
          for (const r in this._sourceCaches) this._sourceCaches[r].clearTiles(), this._sourceCaches[r].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }
        _clearSource(r) {
          const o = this._getSourceCaches(r);
          for (const u of o) u.clearTiles();
        }
        _reloadSource(r) {
          const o = this._getSourceCaches(r);
          for (const u of o) u.resume(), u.reload();
        }
        _reloadSources() {
          for (const r of this._getSources()) r.reload && r.reload();
        }
        _updateSources(r) {
          for (const o in this._sourceCaches) this._sourceCaches[o].update(r);
        }
        _generateCollisionBoxes() {
          for (const r in this._sourceCaches) {
            const o = this._sourceCaches[r];
            o.resume(), o.reload();
          }
        }
        _updatePlacement(r, o, u, d, f = !1) {
          let g = !1, x = !1;
          const b = {};
          for (const M of this._order) {
            const S = this._layers[M];
            if (S.type !== "symbol") continue;
            if (!b[S.source]) {
              const F = this._getLayerSourceCache(S);
              if (!F) continue;
              b[S.source] = F.getRenderableIds(!0).map((j) => F.getTileByID(j)).sort((j, $) => $.tileID.overscaledZ - j.tileID.overscaledZ || (j.tileID.isLessThan($.tileID) ? -1 : 1));
            }
            const P = this.crossTileSymbolIndex.addLayer(S, b[S.source], r.center.lng, r.projection);
            g = g || P;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), f = f || this._layerOrderChanged || u === 0, this._layerOrderChanged && this.fire(new s.Event("neworder")), (f || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s.exported.now(), r.zoom)) && (this.pauseablePlacement = new Pa(r, this._order, f, o, u, d, this.placement, this.fog && r.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, b), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s.exported.now()), x = !0), g && this.pauseablePlacement.placement.setStale()), x || g) for (const M of this._order) {
            const S = this._layers[M];
            S.type === "symbol" && this.placement.updateLayerOpacities(S, b[S.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s.exported.now());
        }
        _releaseSymbolFadeTiles() {
          for (const r in this._sourceCaches) this._sourceCaches[r].releaseSymbolFadeTiles();
        }
        getImages(r, o, u) {
          this.imageManager.getImages(o.icons, u), this._updateTilesForChangedImages();
          const d = (f) => {
            f && f.setDependencies(o.tileID.key, o.type, o.icons);
          };
          d(this._otherSourceCaches[o.source]), d(this._symbolSourceCaches[o.source]);
        }
        getGlyphs(r, o, u) {
          this.glyphManager.getGlyphs(o.stacks, u);
        }
        getResource(r, o, u) {
          return s.makeRequest(o, u);
        }
        _getSourceCache(r) {
          return this._otherSourceCaches[r];
        }
        _getLayerSourceCache(r) {
          return r.type === "symbol" ? this._symbolSourceCaches[r.source] : this._otherSourceCaches[r.source];
        }
        _getSourceCaches(r) {
          const o = [];
          return this._otherSourceCaches[r] && o.push(this._otherSourceCaches[r]), this._symbolSourceCaches[r] && o.push(this._symbolSourceCaches[r]), o;
        }
        _isSourceCacheLoaded(r) {
          const o = this._getSourceCaches(r);
          return o.length === 0 ? (this.fire(new s.ErrorEvent(new Error(`There is no source with ID '${r}'`))), !1) : o.every((u) => u.loaded());
        }
        has3DLayers() {
          return this._num3DLayers > 0;
        }
        hasSymbolLayers() {
          return this._numSymbolLayers > 0;
        }
        hasCircleLayers() {
          return this._numCircleLayers > 0;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      vn.getSourceType = function(l) {
        return Rt[l];
      }, vn.setSourceType = function(l, r) {
        Rt[l] = r;
      }, vn.registerForPluginStateChange = s.registerForPluginStateChange;
      var ea = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#define EXTENT 8192.0
#define HALF_PI PI/2.0
#define QUARTER_PI PI/4.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0`, po = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", qn = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}
#ifdef TERRAIN
#ifdef TERRAIN_DEM_FLOAT_FORMAT
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;
#else
uniform sampler2D u_dem;uniform sampler2D u_dem_prev;
#endif
uniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));
#ifdef TERRAIN_DEM_NEAREST_FILTER
return u_exaggeration*tl;
#endif
float tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(
unpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))
);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
float tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;
#else
vec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);
#endif
return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }
#endif`, Cs = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`, nn = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`;
      let os = {}, Do = {};
      const Ur = [];
      Wn(ea, Ur), Wn(qn, Ur), Wn(Cs, Ur), Wn(nn, Ur), os = li("", qn), Do = li(nn, Cs);
      const za = li(`
#if __VERSION__ >=300
#define varying in
#define gl_FragColor glFragColor
#define texture2D texture
#define textureCube texture
out vec4 glFragColor;
#endif
highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}`, `
#if __VERSION__ >=300
#define attribute in
#define varying out
#define texture2D texture
#endif
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered.`), As = ea, ka = `
#ifdef GL_ES
precision mediump float;
#else

#if !defined(lowp)
#define lowp
#endif

#if !defined(mediump)
#define mediump
#endif

#if !defined(highp)
#define highp
#endif

#endif`;
      var ta = { background: li(`uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
varying vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform vec4 u_color;varying vec4 v_color;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting(u_color);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), backgroundPattern: li(`uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), circle: li(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
gl_FragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`), clippingMask: li("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: li(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), heatmapTexture: li(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: li("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", `attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`), collisionCircle: li("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", `attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`), debug: li("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", `attribute vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;
#endif
varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`), fill: li(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillOutline: li(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillOutlinePattern: li(`uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillPattern: li(`uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillExtrusion: li(`varying vec4 v_color;
#ifdef RENDER_SHADOWS
varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;varying vec3 v_ao;
#endif
#ifdef ZERO_ROOF_RADIUS
varying vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)
varying highp vec3 v_normal;
#endif
void main() {
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)
vec3 normal=v_normal;
#endif
float z;vec4 color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);
#else
color=v_color;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;
#endif
#ifdef RENDER_SHADOWS
#ifdef ZERO_ROOF_RADIUS
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#endif
color.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
gl_FragColor=color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
varying vec4 v_color;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;
#endif
#ifdef ZERO_ROOF_RADIUS
varying vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)
varying highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;varying vec3 v_ao;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)
v_normal=normal;
#endif
base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele;vec3 pos;
#ifdef TERRAIN
bool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);
#ifdef RENDER_SHADOWS
v_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting(color,NdotL);
#else
v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));
#endif
v_color*=u_opacity;
#ifdef ZERO_ROOF_RADIUS
v_roof_color=vec4(0.0,0.0,0.0,1.0);
#ifdef LIGHTING_3D_MODE
v_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));
#else
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));
#endif
v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), fillExtrusionPattern: li(`uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;varying vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
varying float v_NdotL;
#endif
varying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,v_NdotL)*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
varying vec2 v_pos;varying vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;varying vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
varying float v_NdotL;
#endif
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_NdotL=NdotL;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif 
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`), hillshadePrepare: li(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
return texture2D(u_image,coord).a/4.0;
#else
vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;
#endif
}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: li(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
gl_FragColor=apply_lighting(gl_FragColor);
#endif
#ifdef FOG
gl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), line: li(`uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;varying vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
uniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture2D(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trimmed=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef RENDER_LINE_ALPHA_DISCARD
if (alpha < u_alpha_discard_threshold) {discard;}
#endif
#ifdef RENDER_LINE_BORDER
float edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);
#ifdef RENDER_LINE_BORDER_AUTO
float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}
#else
out_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);
#endif
}
#endif
gl_FragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define EXTRUDE_SCALE 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
attribute highp vec4 a_packed;
#endif
#ifdef RENDER_LINE_DASH
attribute float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);
#else
v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), linePattern: li(`uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
color=apply_lighting(color);
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#else
v_gamma_scale=1.0;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), raster: li(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply(out_color,v_fog_pos));
#endif
gl_FragColor=vec4(out_color*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), symbolIcon: li(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);
#else
offsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);
#endif
vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
float occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#endif
float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}`), symbolSDF: li(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);
#endif
vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
float occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#endif
float gamma_scale=gl_Position.w;float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}`), symbolTextAndIcon: li(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
float occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#endif
float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}`), terrainRaster: li(`uniform sampler2D u_image0;varying vec2 v_pos0;
#ifdef FOG
varying float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;
#endif
void main() {vec4 color=texture2D(u_image0,v_pos0);
#ifdef RENDER_SHADOWS
color.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
gl_FragColor=color;
#ifdef TERRAIN_WIREFRAME
gl_FragColor=vec4(1.0,0.0,0.0,0.8);
#endif
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;
#ifdef FOG
varying float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;
#endif
const float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;
#ifdef TERRAIN_WIREFRAME
elevation+=wireframeOffset;
#endif
v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;
#endif
}`), terrainDepth: li(`#ifdef GL_ES
precision highp float;
#endif
varying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}`, "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: li(`
varying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, po), skyboxGradient: li(`varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, po), skyboxCapture: li(`
varying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;
#ifdef GL_ES
precision highp float;
#endif
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}`, "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: li(`uniform sampler2D u_image0;varying vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);
#else
color=texture2D(u_image0,v_pos0);
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
gl_FragColor=color;
#ifdef TERRAIN_WIREFRAME
gl_FragColor=vec4(1.0,0.0,0.0,0.8);
#endif
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
attribute vec3 a_globe_pos;attribute vec2 a_uv;
#else
attribute vec2 a_pos;
#endif
varying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);
#ifdef TERRAIN_WIREFRAME
height+=wireframeOffset;
#endif
globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`), globeAtmosphere: li(`uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:
(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:
uv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}`, `attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`) };
      function Wn(l, r) {
        const o = l.replace(/\s*\/\/[^\n]*\n/g, `
`).split(`
`);
        for (let u of o) if (u = u.trim(), u[0] === "#" && u.includes("if") && !u.includes("endif")) {
          u = u.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
          const d = u.split(" ");
          for (const f of d) r.includes(f) || r.push(f);
        }
      }
      function li(l, r) {
        const o = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, u = r.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), d = {}, f = [...Ur];
        return Wn(l, f), Wn(r, f), { fragmentSource: l = l.replace(o, (g, x, b, M, S) => (d[S] = !0, x === "define" ? `
#ifndef HAS_UNIFORM_u_${S}
varying ${b} ${M} ${S};
#else
uniform ${b} ${M} u_${S};
#endif
` : `
#ifdef HAS_UNIFORM_u_${S}
    ${b} ${M} ${S} = u_${S};
#endif
`)), vertexSource: r = r.replace(o, (g, x, b, M, S) => {
          const P = M === "float" ? "vec2" : "vec4", F = S.match(/color/) ? "color" : P;
          return d[S] ? x === "define" ? `
#ifndef HAS_UNIFORM_u_${S}
uniform lowp float u_${S}_t;
attribute ${b} ${P} a_${S};
varying ${b} ${M} ${S};
#else
uniform ${b} ${M} u_${S};
#endif
` : F === "vec4" ? `
#ifndef HAS_UNIFORM_u_${S}
    ${S} = a_${S};
#else
    ${b} ${M} ${S} = u_${S};
#endif
` : `
#ifndef HAS_UNIFORM_u_${S}
    ${S} = unpack_mix_${F}(a_${S}, u_${S}_t);
#else
    ${b} ${M} ${S} = u_${S};
#endif
` : x === "define" ? `
#ifndef HAS_UNIFORM_u_${S}
uniform lowp float u_${S}_t;
attribute ${b} ${P} a_${S};
#else
uniform ${b} ${M} u_${S};
#endif
` : F === "vec4" ? `
#ifndef HAS_UNIFORM_u_${S}
    ${b} ${M} ${S} = a_${S};
#else
    ${b} ${M} ${S} = u_${S};
#endif
` : `
#ifndef HAS_UNIFORM_u_${S}
    ${b} ${M} ${S} = unpack_mix_${F}(a_${S}, u_${S}_t);
#else
    ${b} ${M} ${S} = u_${S};
#endif
`;
        }), staticAttributes: u, usedDefines: f };
      }
      class vl {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(r, o, u, d, f, g, x) {
          this.context = r;
          let b = this.boundPaintVertexBuffers.length !== d.length;
          for (let S = 0; !b && S < d.length; S++) this.boundPaintVertexBuffers[S] !== d[S] && (b = !0);
          let M = this.boundDynamicVertexBuffers.length !== x.length;
          for (let S = 0; !M && S < x.length; S++) this.boundDynamicVertexBuffers[S] !== x[S] && (M = !0);
          if (!r.extVertexArrayObject || !this.vao || this.boundProgram !== o || this.boundLayoutVertexBuffer !== u || b || M || this.boundIndexBuffer !== f || this.boundVertexOffset !== g) this.freshBind(o, u, d, f, g, x);
          else {
            r.bindVertexArrayOES.set(this.vao);
            for (const S of x) S && S.bind();
            f && f.dynamicDraw && f.bind();
          }
        }
        freshBind(r, o, u, d, f, g) {
          let x;
          const b = r.numAttributes, M = this.context, S = M.gl;
          if (M.extVertexArrayObject) this.vao && this.destroy(), this.vao = M.extVertexArrayObject.createVertexArrayOES(), M.bindVertexArrayOES.set(this.vao), x = 0, this.boundProgram = r, this.boundLayoutVertexBuffer = o, this.boundPaintVertexBuffers = u, this.boundIndexBuffer = d, this.boundVertexOffset = f, this.boundDynamicVertexBuffers = g;
          else {
            x = M.currentNumAttributes || 0;
            for (let P = b; P < x; P++) S.disableVertexAttribArray(P);
          }
          o.enableAttributes(S, r), o.bind(), o.setVertexAttribPointers(S, r, f);
          for (const P of u) P.enableAttributes(S, r), P.bind(), P.setVertexAttribPointers(S, r, f);
          for (const P of g) P && (P.enableAttributes(S, r), P.bind(), P.setVertexAttribPointers(S, r, f));
          d && d.bind(), M.currentNumAttributes = b;
        }
        destroy() {
          this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
        }
      }
      function Da(l, r) {
        const o = Math.pow(2, r.canonical.z), u = r.canonical.y;
        return [new s.MercatorCoordinate(0, u / o).toLngLat().lat, new s.MercatorCoordinate(0, (u + 1) / o).toLngLat().lat];
      }
      function fo(l, r, o, u, d, f, g) {
        const x = l.context, b = x.gl, M = o.fbo;
        if (!M) return;
        l.prepareDrawTile();
        const S = l.useProgram("hillshade");
        x.activeTexture.set(b.TEXTURE0), b.bindTexture(b.TEXTURE_2D, M.colorAttachment.get());
        const P = ((G, Z, L, N) => {
          const X = L.paint.get("hillshade-shadow-color"), K = L.paint.get("hillshade-highlight-color"), le = L.paint.get("hillshade-accent-color");
          let ue = L.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          L.paint.get("hillshade-illumination-anchor") === "viewport" && (ue -= G.transform.angle);
          const ce = !G.options.moving;
          return { u_matrix: N || G.transform.calculateProjMatrix(Z.tileID.toUnwrapped(), ce), u_image: 0, u_latrange: Da(0, Z.tileID), u_light: [L.paint.get("hillshade-exaggeration"), ue], u_shadow: X, u_highlight: K, u_accent: le };
        })(l, o, u, l.terrain ? r.projMatrix : null);
        l.prepareDrawProgram(x, S, r.toUnwrapped());
        const { tileBoundsBuffer: F, tileBoundsIndexBuffer: j, tileBoundsSegments: $ } = l.getTileBoundsBuffers(o);
        S.draw(x, b.TRIANGLES, d, f, g, s.CullFaceMode.disabled, P, u.id, F, j, $);
      }
      function ia(l, r, o) {
        if (!r.needsDEMTextureUpload) return;
        const u = l.context, d = u.gl;
        u.pixelStoreUnpackPremultiplyAlpha.set(!1), r.demTexture = r.demTexture || l.getTileTexture(o.stride);
        const f = o.getPixels();
        r.demTexture ? r.demTexture.update(f, { premultiply: !1 }) : r.demTexture = new s.Texture(u, f, d.RGBA, { premultiply: !1 }), r.needsDEMTextureUpload = !1;
      }
      function bl(l, r, o, u, d, f) {
        const g = l.context, x = g.gl;
        if (!r.dem) return;
        const b = r.dem;
        if (g.activeTexture.set(x.TEXTURE1), ia(l, r, b), !r.demTexture) return;
        r.demTexture.bind(x.NEAREST, x.CLAMP_TO_EDGE);
        const M = b.dim;
        g.activeTexture.set(x.TEXTURE0);
        let S = r.fbo;
        if (!S) {
          const $ = new s.Texture(g, { width: M, height: M, data: null }, x.RGBA);
          $.bind(x.LINEAR, x.CLAMP_TO_EDGE), S = r.fbo = g.createFramebuffer(M, M, !0), S.colorAttachment.set($.texture);
        }
        g.bindFramebuffer.set(S.framebuffer), g.viewport.set([0, 0, M, M]);
        const { tileBoundsBuffer: P, tileBoundsIndexBuffer: F, tileBoundsSegments: j } = l.getMercatorTileBoundsBuffers();
        l.useProgram("hillshadePrepare").draw(g, x.TRIANGLES, u, d, f, s.CullFaceMode.disabled, (($, G) => {
          const Z = G.stride, L = s.create();
          return s.ortho(L, 0, s.EXTENT, -s.EXTENT, 0, 0, 1), s.translate(L, L, [0, -s.EXTENT, 0]), { u_matrix: L, u_image: 1, u_dimension: [Z, Z], u_zoom: $.overscaledZ, u_unpack: G.unpackVector };
        })(r.tileID, b), o.id, P, F, j), r.needsHillshadePrepare = !1;
      }
      const Ra = (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_image0: new s.Uniform1i(l), u_skirt_height: new s.Uniform1f(l) }), mo = (l, r) => ({ u_matrix: l, u_image0: 0, u_skirt_height: r }), _o = (l, r, o, u, d, f, g, x, b, M, S, P, F, j, $) => ({ u_proj_matrix: Float32Array.from(l), u_globe_matrix: r, u_normalize_matrix: Float32Array.from(u), u_merc_matrix: o, u_zoom_transition: d, u_merc_center: f, u_image0: 0, u_frustum_tl: g, u_frustum_tr: x, u_frustum_br: b, u_frustum_bl: M, u_globe_pos: S, u_globe_radius: P, u_viewport: F, u_grid_matrix: $ ? Float32Array.from($) : new Float32Array(9), u_skirt_height: j });
      function go(l, r) {
        return l != null && r != null && !(!l.hasData() || !r.hasData()) && l.demTexture != null && r.demTexture != null && l.tileID.key !== r.tileID.key;
      }
      const bn = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(l, r, o, u, d) {
          if (l in this.operations) {
            const f = this.operations[l];
            f.to.tileID.key !== o.tileID.key && (f.queued = o);
          } else this.operations[l] = { startTime: u, phase: 0, duration: d, from: r, to: o, queued: null };
        }
        getMorphValuesForProxy(l) {
          if (!(l in this.operations)) return null;
          const r = this.operations[l];
          return { from: r.from, to: r.to, phase: r.phase };
        }
        update(l) {
          for (const r in this.operations) {
            const o = this.operations[r];
            for (o.phase = (l - o.startTime) / o.duration; o.phase >= 1 || !this._validOp(o); ) if (!this._nextOp(o, l)) {
              delete this.operations[r];
              break;
            }
          }
        }
        _nextOp(l, r) {
          return !!l.queued && (l.from = l.to, l.to = l.queued, l.queued = null, l.phase = 0, l.startTime = r, !0);
        }
        _validOp(l) {
          return l.from.hasData() && l.to.hasData();
        }
      }(), Xn = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
      function yo(l) {
        return 6 * Math.pow(1.5, 22 - l);
      }
      function wl(l, r) {
        const o = 1 << l.z;
        return !r && (l.x === 0 || l.x === o - 1) || l.y === 0 || l.y === o - 1;
      }
      const Is = (l) => ({ u_matrix: l });
      function Oa(l, r, o, u, d) {
        if (d > 0) {
          const f = s.exported.now(), g = (f - l.timeAdded) / d, x = r ? (f - r.timeAdded) / d : -1, b = o.getSource(), M = u.coveringZoomLevel({ tileSize: b.tileSize, roundZoom: b.roundZoom }), S = !r || Math.abs(r.tileID.overscaledZ - M) > Math.abs(l.tileID.overscaledZ - M), P = S && l.refreshedUponExpiration ? 1 : s.clamp(S ? g : 1 - x, 0, 1);
          return l.refreshedUponExpiration && g >= 1 && (l.refreshedUponExpiration = !1), r ? { opacity: 1, mix: 1 - P } : { opacity: P, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class Ba extends s.SourceCache {
        constructor(r) {
          const o = { type: "raster-dem", maxzoom: r.transform.maxZoom }, u = new Zi(is(), null), d = qt("mock-dem", o, u, r.style);
          super("mock-dem", d, !1), d.setEventedParent(this), this._sourceLoaded = !0;
        }
        _loadTile(r, o) {
          r.state = "loaded", o(null);
        }
      }
      class ra extends s.SourceCache {
        constructor(r) {
          const o = qt("proxy", { type: "geojson", maxzoom: r.transform.maxZoom }, new Zi(is(), null), r.style);
          super("proxy", o, !1), o.setEventedParent(this), this.map = this.getSource().map = r, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(r, o, u) {
          if (r.freezeTileCoverage) return;
          this.transform = r;
          const d = r.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((f, g) => {
            if (f[g.key] = "", !this._tiles[g.key]) {
              const x = new s.Tile(g, this._source.tileSize * g.overscaleFactor(), r.tileZoom);
              x.state = "loaded", this._tiles[g.key] = x;
            }
            return f;
          }, {});
          for (const f in this._tiles) f in d || (this.freeFBO(f), this._tiles[f].unloadVectorData(), delete this._tiles[f]);
        }
        freeFBO(r) {
          const o = this.proxyCachedFBO[r];
          if (o !== void 0) {
            const u = Object.values(o);
            this.renderCachePool.push(...u), delete this.proxyCachedFBO[r];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((r) => r.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class Ps extends s.OverscaledTileID {
        constructor(r, o, u) {
          super(r.overscaledZ, r.wrap, r.canonical.z, r.canonical.x, r.canonical.y), this.proxyTileKey = o, this.projMatrix = u;
        }
      }
      class Ls extends s.Elevation {
        constructor(r, o) {
          super(), this.painter = r, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [u, d, f] = function(b) {
            const M = new s.StructArrayLayout2i4(), S = new s.StructArrayLayout3ui6(), P = 131;
            M.reserve(17161), S.reserve(33800);
            const F = s.EXTENT / 128, j = s.EXTENT + F / 2, $ = j + F;
            for (let Z = -F; Z < $; Z += F) for (let L = -F; L < $; L += F) {
              const N = L < 0 || L > j || Z < 0 || Z > j ? 24575 : 0, X = s.clamp(Math.round(L), 0, s.EXTENT), K = s.clamp(Math.round(Z), 0, s.EXTENT);
              M.emplaceBack(X + N, K);
            }
            const G = (Z, L) => {
              const N = L * P + Z;
              S.emplaceBack(N + 1, N, N + P), S.emplaceBack(N + P, N + P + 1, N + 1);
            };
            for (let Z = 1; Z < 129; Z++) for (let L = 1; L < 129; L++) G(L, Z);
            return [0, 129].forEach((Z) => {
              for (let L = 0; L < 130; L++) G(L, Z), G(Z, L);
            }), [M, S, 32768];
          }(), g = r.context;
          this.gridBuffer = g.createVertexBuffer(u, s.posAttributes.members), this.gridIndexBuffer = g.createIndexBuffer(d), this.gridSegments = s.SegmentVector.simpleSegment(0, 0, u.length, d.length), this.gridNoSkirtSegments = s.SegmentVector.simpleSegment(0, 0, u.length, f), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new ra(o.map), this.orthoMatrix = s.create(), s.ortho(this.orthoMatrix, this.painter.transform.projection.name === "globe" ? 0.015 : 0, s.EXTENT, 0, s.EXTENT, 0, 1);
          const x = g.gl;
          this._overlapStencilMode = new s.StencilMode({ func: x.GEQUAL, mask: 255 }, 0, 255, x.KEEP, x.KEEP, x.REPLACE), this._previousZoom = r.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = o, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Ba(o.map);
        }
        set style(r) {
          r.on("data", this._onStyleDataEvent.bind(this)), r.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = r, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", () => {
            this._clearLineLayersFromRenderCache();
          });
        }
        update(r, o, u) {
          if (r && r.terrain) {
            this._style !== r && (this.style = r), this.enabled = !0;
            const d = r.terrain.properties;
            this.sourceCache = r.terrain.drapeRenderMode === 0 ? this._mockSourceCache : r._getSourceCache(d.get("source")), this._exaggeration = d.get("exaggeration");
            const f = () => {
              this.sourceCache.used && s.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const g = this.getScaledDemTileSize();
              this.sourceCache.update(o, g, !0), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, f(), this._initializing = !0), f(), o.updateElevation(!0, u), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(o), this._emptyDEMTextureDirty = !0;
          } else this._disable();
        }
        resetTileLookupCache(r) {
          this._findCoveringTileCache[r] = {};
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _checkRenderCacheEfficiency() {
          const r = this.renderCacheEfficiency(this._style);
          this._style.map._optimizeForTerrain || r.efficiency !== 100 && s.warnOnce(`Terrain render cache efficiency is not optimal (${r.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${r.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
        }
        _onStyleDataEvent(r) {
          r.coord && r.dataType === "source" ? this._clearRenderCacheForTile(r.sourceCacheId, r.coord) : r.dataType === "style" && (this._invalidateRenderCache = !0);
        }
        _disable() {
          if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const r in this._style._sourceCaches) this._style._sourceCaches[r].usedForTerrain = !1;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((r) => r.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this._exaggeration;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const r = 2 * this.proxySourceCache.getSource().tileSize;
          return [r, r];
        }
        set useVertexMorphing(r) {
          this._useVertexMorphing = r;
        }
        updateTileBinding(r) {
          if (!this.enabled) return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const o = this.proxySourceCache, u = this.painter.transform;
          this._initializing && (this._initializing = u._centerAltitude === 0 && this.getAtPointOrZero(s.MercatorCoordinate.fromLngLat(u.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
          const d = this.proxyCoords = o.getIds().map((b) => {
            const M = o.getTileByID(b).tileID;
            return M.projMatrix = u.calculateProjMatrix(M.toUnwrapped()), M;
          });
          (function(b, M) {
            const S = M.transform.pointCoordinate(M.transform.getCameraPoint()), P = new s.Point(S.x, S.y);
            b.sort((F, j) => {
              if (j.overscaledZ - F.overscaledZ) return j.overscaledZ - F.overscaledZ;
              const $ = new s.Point(F.canonical.x + (1 << F.canonical.z) * F.wrap, F.canonical.y), G = new s.Point(j.canonical.x + (1 << j.canonical.z) * j.wrap, j.canonical.y), Z = P.mult(1 << F.canonical.z);
              return Z.x -= 0.5, Z.y -= 0.5, Z.distSqr($) - Z.distSqr(G);
            });
          })(d, this.painter), this._previousZoom = u.zoom;
          const f = this.proxyToSource || {};
          this.proxyToSource = {}, d.forEach((b) => {
            this.proxyToSource[b.key] = {};
          }), this.terrainTileForTile = {};
          const g = this._style._sourceCaches;
          for (const b in g) {
            const M = g[b];
            if (!M.used || (M !== this.sourceCache && this.resetTileLookupCache(M.id), this._setupProxiedCoordsForOrtho(M, r[b], f), M.usedForTerrain)) continue;
            const S = r[b];
            M.getSource().reparseOverscaled && this._assignTerrainTiles(S);
          }
          this.proxiedCoords[o.id] = d.map((b) => new Ps(b, b.key, this.orthoMatrix)), this._assignTerrainTiles(d), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(f), this.renderingToTexture = !1, this._updateTimestamp = s.exported.now();
          const x = {};
          this._visibleDemTiles = [];
          for (const b of this.proxyCoords) {
            const M = this.terrainTileForTile[b.key];
            if (!M) continue;
            const S = M.tileID.key;
            S in x || (this._visibleDemTiles.push(M), x[S] = S);
          }
        }
        _assignTerrainTiles(r) {
          this._initializing || r.forEach((o) => {
            if (this.terrainTileForTile[o.key]) return;
            const u = this._findTileCoveringTileID(o, this.sourceCache);
            u && (this.terrainTileForTile[o.key] = u);
          });
        }
        _prepareDEMTextures() {
          const r = this.painter.context, o = r.gl;
          for (const u in this.terrainTileForTile) {
            const d = this.terrainTileForTile[u], f = d.dem;
            !f || d.demTexture && !d.needsDEMTextureUpload || (r.activeTexture.set(o.TEXTURE1), ia(this.painter, d, f));
          }
        }
        _prepareDemTileUniforms(r, o, u, d) {
          if (!o || o.demTexture == null) return !1;
          const f = r.tileID.canonical, g = Math.pow(2, o.tileID.canonical.z - f.z), x = d || "";
          return u[`u_dem_tl${x}`] = [f.x * g % 1, f.y * g % 1], u[`u_dem_scale${x}`] = g, !0;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        get emptyDepthBufferTexture() {
          const r = this.painter.context, o = r.gl;
          if (!this._emptyDepthBufferTexture) {
            const u = new s.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
            this._emptyDepthBufferTexture = new s.Texture(r, u, o.RGBA, { premultiply: !1 });
          }
          return this._emptyDepthBufferTexture;
        }
        _getLoadedAreaMinimum() {
          let r = 0;
          const o = this._visibleDemTiles.reduce((u, d) => {
            if (!d.dem) return u;
            const f = d.dem.tree.minimums[0];
            return f > 0 && r++, u + f;
          }, 0);
          return r ? o / r : 0;
        }
        _updateEmptyDEMTexture() {
          const r = this.painter.context, o = r.gl;
          r.activeTexture.set(o.TEXTURE2);
          const u = this._getLoadedAreaMinimum(), d = new s.RGBAImage({ width: 1, height: 1 }, new Uint8Array(s.DEMData.pack(u, this.sourceCache.getSource().encoding)));
          this._emptyDEMTextureDirty = !1;
          let f = this._emptyDEMTexture;
          return f ? f.update(d, { premultiply: !1 }) : f = this._emptyDEMTexture = new s.Texture(r, d, o.RGBA, { premultiply: !1 }), f;
        }
        setupElevationDraw(r, o, u) {
          const d = this.painter.context, f = d.gl, g = (x = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: s.DEMData.getUnpackVector(x), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 });
          var x;
          g.u_dem_size = this.sourceCache.getSource().tileSize, g.u_exaggeration = this.exaggeration();
          let b = null, M = null, S = 1;
          if (u && u.morphing && this._useVertexMorphing) {
            const P = u.morphing.srcDemTile, F = u.morphing.dstDemTile;
            S = u.morphing.phase, P && F && (this._prepareDemTileUniforms(r, P, g, "_prev") && (M = P), this._prepareDemTileUniforms(r, F, g) && (b = F));
          }
          if (M && b ? (d.activeTexture.set(f.TEXTURE2), b.demTexture.bind(f.NEAREST, f.CLAMP_TO_EDGE, f.NEAREST), d.activeTexture.set(f.TEXTURE4), M.demTexture.bind(f.NEAREST, f.CLAMP_TO_EDGE, f.NEAREST), g.u_dem_lerp = S) : (b = this.terrainTileForTile[r.tileID.key], d.activeTexture.set(f.TEXTURE2), (this._prepareDemTileUniforms(r, b, g) ? b.demTexture : this.emptyDEMTexture).bind(f.NEAREST, f.CLAMP_TO_EDGE)), d.activeTexture.set(f.TEXTURE3), u && u.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(f.NEAREST, f.CLAMP_TO_EDGE), this._depthFBO && (g.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(f.NEAREST, f.CLAMP_TO_EDGE), g.u_depth_size_inv = [1, 1]), u && u.useMeterToDem && b) {
            const P = (1 << b.tileID.canonical.z) * s.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            g.u_meter_to_dem = P;
          }
          if (u && u.labelPlaneMatrixInv && (g.u_label_plane_matrix_inv = u.labelPlaneMatrixInv), o.setTerrainUniformValues(d, g), this.painter.transform.projection.name === "globe") {
            const P = this.globeUniformValues(this.painter.transform, r.tileID.canonical, u && u.useDenormalizedUpVectorScale);
            o.setGlobeUniformValues(d, P);
          }
        }
        globeUniformValues(r, o, u) {
          const d = r.projection;
          return { u_tile_tl_up: d.upVector(o, 0, 0), u_tile_tr_up: d.upVector(o, s.EXTENT, 0), u_tile_br_up: d.upVector(o, s.EXTENT, s.EXTENT), u_tile_bl_up: d.upVector(o, 0, s.EXTENT), u_tile_up_scale: u ? s.globeMetersToEcef(1) : d.upVectorScale(o, r.center.lat, r.worldSize).metersToTile };
        }
        renderToBackBuffer(r) {
          const o = this.painter, u = this.painter.context;
          r.length !== 0 && (u.bindFramebuffer.set(null), u.viewport.set([0, 0, o.width, o.height]), o.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(d, f, g, x, b) {
            if (d.transform.projection.name === "globe") (function(M, S, P, F, j) {
              const $ = M.context, G = $.gl;
              let Z, L;
              const N = M.options.showTerrainWireframe ? 2 : 0, X = M.transform, K = s.globeUseCustomAntiAliasing(M, $, X), le = (Ve, Te) => {
                if (L === Ve) return;
                const Re = [Xn[Ve], "PROJECTION_GLOBE_VIEW"];
                K && Re.push("CUSTOM_ANTIALIASING"), Te && Re.push(Xn[N]), Z = M.useProgram("globeRaster", null, Re), L = Ve;
              }, ue = M.colorModeForRenderPass(), ce = new s.DepthMode(G.LEQUAL, s.DepthMode.ReadWrite, M.depthRangeFor3D);
              bn.update(j);
              const ge = s.calculateGlobeMercatorMatrix(X), me = [s.mercatorXfromLng(X.center.lng), s.mercatorYfromLat(X.center.lat)], Ee = N ? [!1, !0] : [!1], Ge = M.globeSharedBuffers, be = [X.width * s.exported.devicePixelRatio, X.height * s.exported.devicePixelRatio], Oe = Float32Array.from(X.globeMatrix), Ce = { useDenormalizedUpVectorScale: !0 };
              if (Ee.forEach((Ve) => {
                const Te = M.transform, Re = yo(Te.zoom) * S.exaggeration();
                L = -1;
                const We = Ve ? G.LINES : G.TRIANGLES;
                for (const Ne of F) {
                  const He = P.getTile(Ne), wt = s.StencilMode.disabled, Dt = S.prevTerrainTileForTile[Ne.key], gt = S.terrainTileForTile[Ne.key];
                  go(Dt, gt) && bn.newMorphing(Ne.key, Dt, gt, j, 250), $.activeTexture.set(G.TEXTURE0), He.texture.bind(G.LINEAR, G.CLAMP_TO_EDGE);
                  const Ct = bn.getMorphValuesForProxy(Ne.key), ti = Ct ? 1 : 0;
                  Ct && s.extend$1(Ce, { morphing: { srcDemTile: Ct.from, dstDemTile: Ct.to, phase: s.easeCubicInOut(Ct.phase) } });
                  const Yt = s.tileCornersToBounds(Ne.canonical), vt = s.getLatitudinalLod(Yt.getCenter().lat), vi = s.getGridMatrix(Ne.canonical, Yt, vt, Te.worldSize / Te._pixelsPerMercatorPixel), Ti = s.globeNormalizeECEF(s.globeTileBounds(Ne.canonical)), Ei = _o(Te.projMatrix, Oe, ge, Ti, s.globeToMercatorTransition(Te.zoom), me, Te.frustumCorners.TL, Te.frustumCorners.TR, Te.frustumCorners.BR, Te.frustumCorners.BL, Te.globeCenterInViewSpace, Te.globeRadius, be, Re, vi);
                  if (le(ti, Ve), S.setupElevationDraw(He, Z, Ce), M.prepareDrawProgram($, Z, Ne.toUnwrapped()), Ge) {
                    const [Si, Vr, Er] = Ve ? Ge.getWirefameBuffers(M.context, vt) : Ge.getGridBuffers(vt, Re !== 0);
                    Z.draw($, We, ce, wt, ue, s.CullFaceMode.backCCW, Ei, "globe_raster", Si, Vr, Er);
                  }
                }
              }), Ge) {
                const Ve = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                K && Ve.push("CUSTOM_ANTIALIASING"), Z = M.useProgram("globeRaster", null, Ve);
                for (const Te of F) {
                  const { x: Re, y: We, z: Ne } = Te.canonical, He = We === 0, wt = We === (1 << Ne) - 1, [Dt, gt, Ct, ti] = Ge.getPoleBuffers(Ne);
                  if (ti && (He || wt)) {
                    const Yt = P.getTile(Te);
                    $.activeTexture.set(G.TEXTURE0), Yt.texture.bind(G.LINEAR, G.CLAMP_TO_EDGE);
                    let vt = s.globePoleMatrixForTile(Ne, Re, X);
                    const vi = s.globeNormalizeECEF(s.globeTileBounds(Te.canonical)), Ti = (Ei, Si) => Ei.draw($, G.TRIANGLES, ce, s.StencilMode.disabled, ue, s.CullFaceMode.disabled, _o(X.projMatrix, vt, vt, vi, 0, me, X.frustumCorners.TL, X.frustumCorners.TR, X.frustumCorners.BR, X.frustumCorners.BL, X.globeCenterInViewSpace, X.globeRadius, be, 0), "globe_pole_raster", Si, Ct, ti);
                    S.setupElevationDraw(Yt, Z, Ce), M.prepareDrawProgram($, Z, Te.toUnwrapped()), He && Ti(Z, Dt), wt && (vt = s.scale(s.create(), vt, [1, -1, 1]), Ti(Z, gt));
                  }
                }
              }
            })(d, f, g, x, b);
            else {
              const M = d.context, S = M.gl;
              let P, F;
              const j = d.options.showTerrainWireframe ? 2 : 0, $ = (X, K) => {
                if (F === X) return;
                const le = [Xn[X]];
                K && le.push(Xn[j]), P = d.useProgram("terrainRaster", null, le), F = X;
              }, G = d.colorModeForRenderPass(), Z = new s.DepthMode(S.LEQUAL, s.DepthMode.ReadWrite, d.depthRangeFor3D);
              bn.update(b);
              const L = d.transform, N = yo(L.zoom) * f.exaggeration();
              (j ? [!1, !0] : [!1]).forEach((X) => {
                F = -1;
                const K = X ? S.LINES : S.TRIANGLES, [le, ue] = X ? f.getWirefameBuffer() : [f.gridIndexBuffer, f.gridSegments];
                for (const ce of x) {
                  const ge = g.getTile(ce), me = s.StencilMode.disabled, Ee = f.prevTerrainTileForTile[ce.key], Ge = f.terrainTileForTile[ce.key];
                  go(Ee, Ge) && bn.newMorphing(ce.key, Ee, Ge, b, 250), M.activeTexture.set(S.TEXTURE0), ge.texture.bind(S.LINEAR, S.CLAMP_TO_EDGE, S.LINEAR_MIPMAP_NEAREST);
                  const be = bn.getMorphValuesForProxy(ce.key), Oe = be ? 1 : 0;
                  let Ce;
                  be && (Ce = { morphing: { srcDemTile: be.from, dstDemTile: be.to, phase: s.easeCubicInOut(be.phase) } });
                  const Ve = mo(ce.projMatrix, wl(ce.canonical, L.renderWorldCopies) ? N / 10 : N);
                  $(Oe, X), f.setupElevationDraw(ge, P, Ce), d.prepareDrawProgram(M, P, ce.toUnwrapped()), P.draw(M, K, Z, me, G, s.CullFaceMode.backCCW, Ve, "terrain_raster", f.gridBuffer, le, ue);
                }
              });
            }
          }(o, this, this.proxySourceCache, r, this._updateTimestamp), this.renderingToTexture = !0, o.gpuTimingDeferredRenderEnd(), r.splice(0, r.length));
        }
        renderBatch(r) {
          if (this._drapedRenderBatches.length === 0) return r + 1;
          this.renderingToTexture = !0;
          const o = this.painter, u = this.painter.context, d = this.proxySourceCache, f = this.proxiedCoords[d.id], g = this._drapedRenderBatches.shift(), x = [], b = o.style.order;
          let M = 0;
          for (const S of f) {
            const P = d.getTileByID(S.proxyTileKey), F = d.proxyCachedFBO[S.key] ? d.proxyCachedFBO[S.key][r] : void 0, j = F !== void 0 ? d.renderCache[F] : this.pool[M++], $ = F !== void 0;
            if (P.texture = j.tex, $ && !j.dirty) {
              x.push(P.tileID);
              continue;
            }
            let G;
            u.bindFramebuffer.set(j.fb.framebuffer), this.renderedToTile = !1, j.dirty && (u.clear({ color: s.Color.transparent, stencil: 0 }), j.dirty = !1);
            for (let Z = g.start; Z <= g.end; ++Z) {
              const L = o.style._layers[b[Z]];
              if (L.isHidden(o.transform.zoom)) continue;
              const N = o.style._getLayerSourceCache(L), X = N ? this.proxyToSource[S.key][N.id] : [S];
              if (!X) continue;
              const K = X;
              u.viewport.set([0, 0, j.fb.width, j.fb.height]), G !== (N ? N.id : null) && (this._setupStencil(j, X, L, N), G = N ? N.id : null), o.renderLayer(o, N, L, K);
            }
            this.renderedToTile ? (j.dirty = !0, x.push(P.tileID)) : $ || --M, M === 5 && (M = 0, this.renderToBackBuffer(x));
          }
          return this.renderToBackBuffer(x), this.renderingToTexture = !1, u.bindFramebuffer.set(null), u.viewport.set([0, 0, o.width, o.height]), g.end + 1;
        }
        postRender() {
        }
        renderCacheEfficiency(r) {
          const o = r.order.length;
          if (o === 0) return { efficiency: 100 };
          let u, d = 0, f = 0, g = !1;
          for (let x = 0; x < o; ++x) {
            const b = r._layers[r.order[x]];
            this._style.isLayerDraped(b) ? (g && ++d, ++f) : g || (g = !0, u = b.id);
          }
          return f === 0 ? { efficiency: 100 } : { efficiency: 100 * (1 - d / f), firstUndrapedLayer: u };
        }
        getMinElevationBelowMSL() {
          let r = 0;
          return this._visibleDemTiles.filter((o) => o.dem).forEach((o) => {
            r = Math.min(r, o.dem.tree.minimums[0]);
          }), r === 0 ? r : (r - 30) * this._exaggeration;
        }
        raycast(r, o, u) {
          if (!this._visibleDemTiles) return null;
          const d = this._visibleDemTiles.filter((f) => f.dem).map((f) => {
            const g = f.tileID, x = 1 << g.overscaledZ, { x: b, y: M } = g.canonical, S = b / x, P = (b + 1) / x, F = M / x, j = (M + 1) / x;
            return { minx: S, miny: F, maxx: P, maxy: j, t: f.dem.tree.raycastRoot(S, F, P, j, r, o, u), tile: f };
          });
          d.sort((f, g) => (f.t !== null ? f.t : Number.MAX_VALUE) - (g.t !== null ? g.t : Number.MAX_VALUE));
          for (const f of d) {
            if (f.t == null) return null;
            const g = f.tile.dem.tree.raycast(f.minx, f.miny, f.maxx, f.maxy, r, o, u);
            if (g != null) return g;
          }
          return null;
        }
        _createFBO() {
          const r = this.painter.context, o = r.gl, u = this.drapeBufferSize;
          r.activeTexture.set(o.TEXTURE0);
          const d = new s.Texture(r, { width: u[0], height: u[1], data: null }, o.RGBA);
          d.bind(o.LINEAR, o.CLAMP_TO_EDGE);
          const f = r.createFramebuffer(u[0], u[1], !1);
          return f.colorAttachment.set(d.texture), f.depthAttachment = new pe(r, f.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = r.createRenderbuffer(r.gl.DEPTH_STENCIL, u[0], u[1]), this._stencilRef = 0, f.depthAttachment.set(this._sharedDepthStencil), r.clear({ stencil: 0 })) : f.depthAttachment.set(this._sharedDepthStencil), r.extTextureFilterAnisotropic && !r.extTextureFilterAnisotropicForceOff && o.texParameterf(o.TEXTURE_2D, r.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r.extTextureFilterAnisotropicMax), { fb: f, tex: d, dirty: !1 };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); ) this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._style.light && this._style.light.hasTransition()) return !0;
          for (const r in this._style._sourceCaches) if (this._style._sourceCaches[r].hasTransition()) return !0;
          return this._style.order.some((r) => {
            const o = this._style._layers[r], u = o.isHidden(this.painter.transform.zoom);
            return o.type === "custom" ? !u && o.shouldRedrape() : !u && o.hasTransition();
          });
        }
        _clearLineLayersFromRenderCache() {
          let r = !1;
          for (const u of this._style._getSources()) if (u instanceof it) {
            r = !0;
            break;
          }
          if (!r) return;
          const o = {};
          for (let u = 0; u < this._style.order.length; ++u) {
            const d = this._style._layers[this._style.order[u]], f = this._style._getLayerSourceCache(d);
            if (f && !o[f.id] && !d.isHidden(this.painter.transform.zoom) && d.type === "line" && d.widthExpression() instanceof s.ZoomDependentExpression) {
              o[f.id] = !0;
              for (const g of this.proxyCoords) {
                const x = this.proxyToSource[g.key][f.id];
                if (x) for (const b of x) this._clearRenderCacheForTile(f.id, b);
              }
            }
          }
        }
        _clearRasterLayersFromRenderCache() {
          let r = !1;
          for (const u in this._style._sourceCaches) if (this._style._sourceCaches[u]._source instanceof Ze) {
            r = !0;
            break;
          }
          if (!r) return;
          const o = {};
          for (let u = 0; u < this._style.order.length; ++u) {
            const d = this._style._layers[this._style.order[u]], f = this._style._getLayerSourceCache(d);
            if (!f || o[f.id] || d.isHidden(this.painter.transform.zoom) || d.type !== "raster") continue;
            const g = d.paint.get("raster-fade-duration");
            for (const x of this.proxyCoords) {
              const b = this.proxyToSource[x.key][f.id];
              if (b) for (const M of b) {
                const S = Oa(f.getTile(M), f.findLoadedParent(M, 0), f, this.painter.transform, g);
                (S.opacity !== 1 || S.mix !== 0) && this._clearRenderCacheForTile(f.id, M);
              }
            }
          }
        }
        _setupDrapedRenderBatches() {
          const r = this._style.order, o = r.length;
          if (o === 0) return;
          const u = [];
          let d, f = 0, g = this._style._layers[r[f]];
          for (; !this._style.isLayerDraped(g) && g.isHidden(this.painter.transform.zoom) && ++f < o; ) g = this._style._layers[r[f]];
          for (; f < o; ++f) {
            const x = this._style._layers[r[f]];
            x.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(x) ? d === void 0 && (d = f) : d !== void 0 && (u.push({ start: d, end: f - 1 }), d = void 0));
          }
          d !== void 0 && u.push({ start: d, end: f - 1 }), this._drapedRenderBatches = u;
        }
        _setupRenderCache(r) {
          const o = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
            if (this._invalidateRenderCache = !1, o.renderCache.length > o.renderCachePool.length) {
              const g = Object.values(o.proxyCachedFBO);
              o.proxyCachedFBO = {};
              for (let x = 0; x < g.length; ++x) {
                const b = Object.values(g[x]);
                o.renderCachePool.push(...b);
              }
            }
            return;
          }
          this._clearRasterLayersFromRenderCache();
          const u = this.proxyCoords, d = this._tilesDirty;
          for (let g = u.length - 1; g >= 0; g--) {
            const x = u[g];
            if (o.getTileByID(x.key), o.proxyCachedFBO[x.key] !== void 0) {
              const b = r[x.key], M = this.proxyToSource[x.key];
              let S = 0;
              for (const P in M) {
                const F = M[P], j = b[P];
                if (!j || j.length !== F.length || F.some(($, G) => $ !== j[G] || d[P] && d[P].hasOwnProperty($.key))) {
                  S = -1;
                  break;
                }
                ++S;
              }
              for (const P in o.proxyCachedFBO[x.key]) o.renderCache[o.proxyCachedFBO[x.key][P]].dirty = S < 0 || S !== Object.values(b).length;
            }
          }
          const f = [...this._drapedRenderBatches];
          f.sort((g, x) => x.end - x.start - (g.end - g.start));
          for (const g of f) for (const x of u) {
            if (o.proxyCachedFBO[x.key]) continue;
            let b = o.renderCachePool.pop();
            b === void 0 && o.renderCache.length < 50 && (b = o.renderCache.length, o.renderCache.push(this._createFBO())), b !== void 0 && (o.proxyCachedFBO[x.key] = {}, o.proxyCachedFBO[x.key][g.start] = b, o.renderCache[b].dirty = !0);
          }
          this._tilesDirty = {};
        }
        _setupStencil(r, o, u, d) {
          if (!d || !this._sourceTilesOverlap[d.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
          const f = this.painter.context, g = f.gl;
          if (o.length <= 1) return void (this._overlapStencilType = !1);
          let x;
          if (u.isTileClipped()) x = o.length, this._overlapStencilMode.test = { func: g.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(o[0].overscaledZ > o[o.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
            x = 1, this._overlapStencilMode.test = { func: g.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + x > 255 && (f.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += x, this._overlapStencilMode.ref = this._stencilRef, u.isTileClipped() && this._renderTileClippingMasks(o, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask";
        }
        stencilModeForRTTOverlap(r) {
          return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[r.key]), this._overlapStencilMode) : s.StencilMode.disabled;
        }
        _renderTileClippingMasks(r, o) {
          const u = this.painter, d = this.painter.context, f = d.gl;
          u._tileClippingMaskIDs = {}, d.setColorMode(s.ColorMode.disabled), d.setDepthMode(s.DepthMode.disabled);
          const g = u.useProgram("clippingMask");
          for (const x of r) {
            const b = u._tileClippingMaskIDs[x.key] = --o;
            g.draw(d, f.TRIANGLES, s.DepthMode.disabled, new s.StencilMode({ func: f.ALWAYS, mask: 0 }, b, 255, f.KEEP, f.KEEP, f.REPLACE), s.ColorMode.disabled, s.CullFaceMode.disabled, Is(x.projMatrix), "$clipping", u.tileExtentBuffer, u.quadTriangleIndexBuffer, u.tileExtentSegments);
          }
        }
        pointCoordinate(r) {
          const o = this.painter.transform;
          if (r.x < 0 || r.x > o.width || r.y < 0 || r.y > o.height) return null;
          const u = [r.x, r.y, 1, 1];
          s.transformMat4$1(u, u, o.pixelMatrixInverse), s.scale$1(u, u, 1 / u[3]), u[0] /= o.worldSize, u[1] /= o.worldSize;
          const d = o._camera.position, f = s.mercatorZfromAltitude(1, o.center.lat), g = [d[0], d[1], d[2] / f, 0], x = s.subtract([], u.slice(0, 3), g);
          s.normalize(x, x);
          const b = this.raycast(g, x, this._exaggeration);
          return b !== null && b ? (s.scaleAndAdd(g, g, x, b), g[3] = g[2], g[2] *= f, g) : null;
        }
        drawDepth() {
          const r = this.painter, o = r.context, u = this.proxySourceCache, d = Math.ceil(r.width), f = Math.ceil(r.height);
          if (!this._depthFBO || this._depthFBO.width === d && this._depthFBO.height === f || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
            const g = o.gl, x = o.createFramebuffer(d, f, !0);
            o.activeTexture.set(g.TEXTURE0);
            const b = new s.Texture(o, { width: d, height: f, data: null }, g.RGBA);
            b.bind(g.NEAREST, g.CLAMP_TO_EDGE), x.colorAttachment.set(b.texture);
            const M = o.createRenderbuffer(o.gl.DEPTH_COMPONENT16, d, f);
            x.depthAttachment.set(M), this._depthFBO = x, this._depthTexture = b;
          }
          o.bindFramebuffer.set(this._depthFBO.framebuffer), o.viewport.set([0, 0, d, f]), function(g, x, b, M) {
            if (g.transform.projection.name === "globe") return;
            const S = g.context, P = S.gl;
            S.clear({ depth: 1 });
            const F = g.useProgram("terrainDepth"), j = new s.DepthMode(P.LESS, s.DepthMode.ReadWrite, g.depthRangeFor3D);
            for (const $ of M) {
              const G = b.getTile($), Z = mo($.projMatrix, 0);
              x.setupElevationDraw(G, F), F.draw(S, P.TRIANGLES, j, s.StencilMode.disabled, s.ColorMode.unblended, s.CullFaceMode.backCCW, Z, "terrain_depth", x.gridBuffer, x.gridIndexBuffer, x.gridNoSkirtSegments);
            }
          }(r, this, u, this.proxyCoords);
        }
        _setupProxiedCoordsForOrtho(r, o, u) {
          if (r.getSource() instanceof Lt) return this._setupProxiedCoordsForImageSource(r, o, u);
          this._findCoveringTileCache[r.id] = this._findCoveringTileCache[r.id] || {};
          const d = this.proxiedCoords[r.id] = [], f = this.proxyCoords;
          for (let x = 0; x < f.length; x++) {
            const b = f[x], M = this._findTileCoveringTileID(b, r);
            if (M) {
              const S = this._createProxiedId(b, M, u[b.key] && u[b.key][r.id]);
              d.push(S), this.proxyToSource[b.key][r.id] = [S];
            }
          }
          let g = !1;
          for (let x = 0; x < o.length; x++) {
            const b = r.getTile(o[x]);
            if (!b || !b.hasData()) continue;
            const M = this._findTileCoveringTileID(b.tileID, this.proxySourceCache);
            if (M && M.tileID.canonical.z !== b.tileID.canonical.z) {
              const S = this.proxyToSource[M.tileID.key][r.id], P = this._createProxiedId(M.tileID, b, u[M.tileID.key] && u[M.tileID.key][r.id]);
              S ? S.splice(S.length - 1, 0, P) : this.proxyToSource[M.tileID.key][r.id] = [P], d.push(P), g = !0;
            }
          }
          this._sourceTilesOverlap[r.id] = g;
        }
        _setupProxiedCoordsForImageSource(r, o, u) {
          if (!r.getSource().loaded()) return;
          const d = this.proxiedCoords[r.id] = [], f = this.proxyCoords, g = r.getSource(), x = new s.Point(g.tileID.x, g.tileID.y)._div(1 << g.tileID.z), b = g.coordinates.map(s.MercatorCoordinate.fromLngLat).reduce((S, P) => (S.min.x = Math.min(S.min.x, P.x - x.x), S.min.y = Math.min(S.min.y, P.y - x.y), S.max.x = Math.max(S.max.x, P.x - x.x), S.max.y = Math.max(S.max.y, P.y - x.y), S), { min: new s.Point(Number.MAX_VALUE, Number.MAX_VALUE), max: new s.Point(-Number.MAX_VALUE, -Number.MAX_VALUE) }), M = (S, P) => {
            const F = S.wrap + S.canonical.x / (1 << S.canonical.z), j = S.canonical.y / (1 << S.canonical.z), $ = s.EXTENT / (1 << S.canonical.z), G = P.wrap + P.canonical.x / (1 << P.canonical.z), Z = P.canonical.y / (1 << P.canonical.z);
            return F + $ < G + b.min.x || F > G + b.max.x || j + $ < Z + b.min.y || j > Z + b.max.y;
          };
          for (let S = 0; S < f.length; S++) {
            const P = f[S];
            for (let F = 0; F < o.length; F++) {
              const j = r.getTile(o[F]);
              if (!j || !j.hasData() || M(P, j.tileID)) continue;
              const $ = this._createProxiedId(P, j, u[P.key] && u[P.key][r.id]), G = this.proxyToSource[P.key][r.id];
              G ? G.push($) : this.proxyToSource[P.key][r.id] = [$], d.push($);
            }
          }
        }
        _createProxiedId(r, o, u) {
          let d = this.orthoMatrix;
          if (u) {
            const f = u.find((g) => g.key === o.tileID.key);
            if (f) return f;
          }
          if (o.tileID.key !== r.key) {
            const f = r.canonical.z - o.tileID.canonical.z;
            let g, x, b;
            d = s.create();
            const M = o.tileID.wrap - r.wrap << r.overscaledZ;
            f > 0 ? (g = s.EXTENT >> f, x = g * ((o.tileID.canonical.x << f) - r.canonical.x + M), b = g * ((o.tileID.canonical.y << f) - r.canonical.y)) : (g = s.EXTENT << -f, x = s.EXTENT * (o.tileID.canonical.x - (r.canonical.x + M << -f)), b = s.EXTENT * (o.tileID.canonical.y - (r.canonical.y << -f))), s.ortho(d, 0, g, 0, g, 0, 1), s.translate(d, d, [x, b, 0]);
          }
          return new Ps(o.tileID, r.key, d);
        }
        _findTileCoveringTileID(r, o) {
          let u = o.getTile(r);
          if (u && u.hasData()) return u;
          const d = this._findCoveringTileCache[o.id], f = d[r.key];
          if (u = f ? o.getTileByID(f) : null, u && u.hasData() || f === null) return u;
          let g = u ? u.tileID : r, x = g.overscaledZ;
          const b = o.getSource().minzoom, M = [];
          if (!f) {
            const P = o.getSource().maxzoom;
            if (r.canonical.z >= P) {
              const F = r.canonical.z - P;
              o.getSource().reparseOverscaled ? (x = Math.max(r.canonical.z + 2, o.transform.tileZoom), g = new s.OverscaledTileID(x, r.wrap, P, r.canonical.x >> F, r.canonical.y >> F)) : F !== 0 && (x = P, g = new s.OverscaledTileID(x, r.wrap, P, r.canonical.x >> F, r.canonical.y >> F));
            }
            g.key !== r.key && (M.push(g.key), u = o.getTile(g));
          }
          const S = (P) => {
            M.forEach((F) => {
              d[F] = P;
            }), M.length = 0;
          };
          for (x -= 1; x >= b && (!u || !u.hasData()); x--) {
            u && S(u.tileID.key);
            const P = g.calculateScaledKey(x);
            if (u = o.getTileByID(P), u && u.hasData()) break;
            const F = d[P];
            if (F === null) break;
            F === void 0 ? M.push(P) : u = o.getTileByID(F);
          }
          return S(u ? u.tileID.key : null), u && u.hasData() ? u : null;
        }
        findDEMTileFor(r) {
          return this.enabled ? this._findTileCoveringTileID(r, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = !0;
        }
        _clearRenderCacheForTile(r, o) {
          let u = this._tilesDirty[r];
          u || (u = this._tilesDirty[r] = {}), u[o.key] = !0;
        }
        getWirefameBuffer() {
          if (!this.wireframeSegments) {
            const r = function(o) {
              let u = 0;
              const d = new s.StructArrayLayout2ui4(), f = 131;
              for (let g = 1; g < 129; g++) {
                for (let x = 1; x < 129; x++) u = g * f + x, d.emplaceBack(u, u + 1), d.emplaceBack(u, u + f), d.emplaceBack(u + 1, u + f), g === 128 && d.emplaceBack(u + f, u + f + 1);
                d.emplaceBack(u + 1, u + 1 + f);
              }
              return d;
            }();
            this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(r), this.wireframeSegments = s.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, r.length);
          }
          return [this.wireframeIndexBuffer, this.wireframeSegments];
        }
      }
      class Kt {
        static cacheKey(r, o, u, d) {
          let f = `${o}${d ? d.cacheKey : ""}`;
          for (const g of u) r.usedDefines.includes(g) && (f += `/${g}`);
          return f;
        }
        constructor(r, o, u, d, f, g) {
          const x = r.gl;
          this.program = x.createProgram();
          const b = function(L) {
            const N = [];
            for (let X = 0; X < L.length; X++) {
              if (L[X] === null) continue;
              const K = L[X].split(" ");
              N.push(K.pop());
            }
            return N;
          }(u.staticAttributes), M = d ? d.getBinderAttributes() : [], S = b.concat(M);
          let P = d ? d.defines() : [];
          P = P.concat(g.map((L) => `#define ${L}`));
          const F = r.isWebGL2 ? `#version 300 es
` : "", j = F + P.concat(r.extStandardDerivatives && F.length === 0 ? `#extension GL_OES_standard_derivatives : enable
`.concat(ka) : ka, ka, As, za.fragmentSource, Do.fragmentSource, u.fragmentSource).join(`
`), $ = F + P.concat(`
#ifdef GL_ES
precision highp float;
#else

#if !defined(lowp)
#define lowp
#endif

#if !defined(mediump)
#define mediump
#endif

#if !defined(highp)
#define highp
#endif

#endif`, As, za.vertexSource, Do.vertexSource, os.vertexSource, u.vertexSource).join(`
`), G = x.createShader(x.FRAGMENT_SHADER);
          if (x.isContextLost()) return void (this.failedToCreate = !0);
          x.shaderSource(G, j), x.compileShader(G), x.attachShader(this.program, G);
          const Z = x.createShader(x.VERTEX_SHADER);
          if (x.isContextLost()) this.failedToCreate = !0;
          else {
            x.shaderSource(Z, $), x.compileShader(Z), x.attachShader(this.program, Z), this.attributes = {}, this.numAttributes = S.length;
            for (let L = 0; L < this.numAttributes; L++) S[L] && (x.bindAttribLocation(this.program, L, S[L]), this.attributes[S[L]] = L);
            x.linkProgram(this.program), x.deleteShader(Z), x.deleteShader(G), this.fixedUniforms = f(r), this.binderUniforms = d ? d.getUniforms(r) : [], g.includes("TERRAIN") && (this.terrainUniforms = ((L) => ({ u_dem: new s.Uniform1i(L), u_dem_prev: new s.Uniform1i(L), u_dem_unpack: new s.Uniform4f(L), u_dem_tl: new s.Uniform2f(L), u_dem_scale: new s.Uniform1f(L), u_dem_tl_prev: new s.Uniform2f(L), u_dem_scale_prev: new s.Uniform1f(L), u_dem_size: new s.Uniform1f(L), u_dem_lerp: new s.Uniform1f(L), u_exaggeration: new s.Uniform1f(L), u_depth: new s.Uniform1i(L), u_depth_size_inv: new s.Uniform2f(L), u_meter_to_dem: new s.Uniform1f(L), u_label_plane_matrix_inv: new s.UniformMatrix4f(L) }))(r)), g.includes("GLOBE") && (this.globeUniforms = ((L) => ({ u_tile_tl_up: new s.Uniform3f(L), u_tile_tr_up: new s.Uniform3f(L), u_tile_br_up: new s.Uniform3f(L), u_tile_bl_up: new s.Uniform3f(L), u_tile_up_scale: new s.Uniform1f(L) }))(r)), g.includes("FOG") && (this.fogUniforms = ((L) => ({ u_fog_matrix: new s.UniformMatrix4f(L), u_fog_range: new s.Uniform2f(L), u_fog_color: new s.Uniform4f(L), u_fog_horizon_blend: new s.Uniform1f(L), u_fog_temporal_offset: new s.Uniform1f(L), u_frustum_tl: new s.Uniform3f(L), u_frustum_tr: new s.Uniform3f(L), u_frustum_br: new s.Uniform3f(L), u_frustum_bl: new s.Uniform3f(L), u_globe_pos: new s.Uniform3f(L), u_globe_radius: new s.Uniform1f(L), u_globe_transition: new s.Uniform1f(L), u_is_globe: new s.Uniform1i(L), u_viewport: new s.Uniform2f(L) }))(r));
          }
        }
        setTerrainUniformValues(r, o) {
          if (!this.terrainUniforms) return;
          const u = this.terrainUniforms;
          if (!this.failedToCreate) {
            r.program.set(this.program);
            for (const d in o) u[d] && u[d].set(this.program, d, o[d]);
          }
        }
        setGlobeUniformValues(r, o) {
          if (!this.globeUniforms) return;
          const u = this.globeUniforms;
          if (!this.failedToCreate) {
            r.program.set(this.program);
            for (const d in o) u[d] && u[d].set(this.program, d, o[d]);
          }
        }
        setFogUniformValues(r, o) {
          if (!this.fogUniforms) return;
          const u = this.fogUniforms;
          if (!this.failedToCreate) {
            r.program.set(this.program);
            for (const d in o) u[d].set(this.program, d, o[d]);
          }
        }
        draw(r, o, u, d, f, g, x, b, M, S, P, F, j, $, G) {
          const Z = r.gl;
          if (this.failedToCreate) return;
          r.program.set(this.program), r.setDepthMode(u), r.setStencilMode(d), r.setColorMode(f), r.setCullFace(g);
          for (const N of Object.keys(this.fixedUniforms)) this.fixedUniforms[N].set(this.program, N, x[N]);
          $ && $.setUniforms(this.program, r, this.binderUniforms, F, { zoom: j });
          const L = { [Z.LINES]: 2, [Z.TRIANGLES]: 3, [Z.LINE_STRIP]: 1 }[o];
          for (const N of P.get()) {
            const X = N.vaos || (N.vaos = {});
            (X[b] || (X[b] = new vl())).bind(r, this, M, $ ? $.getPaintVertexBuffers() : [], S, N.vertexOffset, G || []), Z.drawElements(o, N.primitiveLength * L, Z.UNSIGNED_SHORT, N.primitiveOffset * L * 2);
          }
        }
      }
      function Hr(l, r) {
        const o = Math.pow(2, r.tileID.overscaledZ), u = r.tileSize * Math.pow(2, l.transform.tileZoom) / o, d = u * (r.tileID.canonical.x + r.tileID.wrap * o), f = u * r.tileID.canonical.y;
        return { u_image: 0, u_texsize: r.imageAtlasTexture.size, u_tile_units_to_pixels: 1 / er(r, 1, l.transform.tileZoom), u_pixel_coord_upper: [d >> 16, f >> 16], u_pixel_coord_lower: [65535 & d, 65535 & f] };
      }
      const xo = s.create(), ss = (l, r, o, u, d, f, g, x, b, M, S) => {
        const P = r.style.light, F = P.properties.get("position"), j = [F.x, F.y, F.z], $ = s.create$1();
        P.properties.get("anchor") === "viewport" && (s.fromRotation($, -r.transform.angle), s.transformMat3(j, j, $));
        const G = P.properties.get("color"), Z = r.transform, L = { u_matrix: l, u_lightpos: j, u_lightintensity: P.properties.get("intensity"), u_lightcolor: [G.r, G.g, G.b], u_vertical_gradient: +o, u_opacity: u, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: xo, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: d, u_edge_radius: f };
        return Z.projection.name === "globe" && (L.u_tile_id = [g.canonical.x, g.canonical.y, 1 << g.canonical.z], L.u_zoom_transition = b, L.u_inv_rot_matrix = S, L.u_merc_center = M, L.u_up_dir = Z.projection.upVector(new s.CanonicalTileID(0, 0, 0), M[0] * s.EXTENT, M[1] * s.EXTENT), L.u_height_lift = x), L;
      }, Hn = (l, r, o, u, d, f, g, x, b, M, S, P) => {
        const F = ss(l, r, o, u, d, f, g, b, M, S, P), j = { u_height_factor: -Math.pow(2, g.overscaledZ) / x.tileSize / 8 };
        return s.extend(F, Hr(r, x), j);
      }, Ro = (l) => ({ u_matrix: l }), as = (l, r, o) => s.extend(Ro(l), Hr(r, o)), zs = (l, r) => ({ u_matrix: l, u_world: r }), Tl = (l, r, o, u) => s.extend(as(l, r, o), { u_world: u }), El = s.create(), Fa = (l, r, o, u, d, f) => {
        const g = l.transform, x = g.projection.name === "globe";
        let b;
        if (f.paint.get("circle-pitch-alignment") === "map") if (x) {
          const S = s.globePixelsToTileUnits(g.zoom, r.canonical) * g._pixelsPerMercatorPixel;
          b = Float32Array.from([S, 0, 0, S]);
        } else b = g.calculatePixelsToTileUnitsMatrix(o);
        else b = new Float32Array([g.pixelsToGLUnits[0], 0, 0, g.pixelsToGLUnits[1]]);
        const M = { u_camera_to_center_distance: g.cameraToCenterDistance, u_matrix: l.translatePosMatrix(r.projMatrix, o, f.paint.get("circle-translate"), f.paint.get("circle-translate-anchor")), u_device_pixel_ratio: s.exported.devicePixelRatio, u_extrude_scale: b, u_inv_rot_matrix: El, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (x) {
          M.u_inv_rot_matrix = u, M.u_merc_center = d, M.u_tile_id = [r.canonical.x, r.canonical.y, 1 << r.canonical.z], M.u_zoom_transition = s.globeToMercatorTransition(g.zoom);
          const S = d[0] * s.EXTENT, P = d[1] * s.EXTENT;
          M.u_up_dir = g.projection.upVector(new s.CanonicalTileID(0, 0, 0), S, P);
        }
        return M;
      }, Ua = (l) => {
        const r = [];
        return l.paint.get("circle-pitch-alignment") === "map" && r.push("PITCH_WITH_MAP"), l.paint.get("circle-pitch-scale") === "map" && r.push("SCALE_WITH_MAP"), r;
      }, na = (l, r, o, u) => {
        const d = s.EXTENT / o.tileSize;
        return { u_matrix: l, u_camera_to_center_distance: r.getCameraToCenterDistance(u), u_extrude_scale: [r.pixelsToGLUnits[0] / d, r.pixelsToGLUnits[1] / d] };
      }, ks = (l, r, o = 1) => ({ u_matrix: l, u_color: r, u_overlay: 0, u_overlay_scale: o }), Ds = s.create(), Oo = (l, r, o, u, d, f, g) => {
        const x = l.transform, b = x.projection.name === "globe", M = b ? s.globePixelsToTileUnits(x.zoom, r.canonical) * x._pixelsPerMercatorPixel : er(o, 1, f), S = { u_matrix: r.projMatrix, u_extrude_scale: M, u_intensity: g, u_inv_rot_matrix: Ds, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (b) {
          S.u_inv_rot_matrix = u, S.u_merc_center = d, S.u_tile_id = [r.canonical.x, r.canonical.y, 1 << r.canonical.z], S.u_zoom_transition = s.globeToMercatorTransition(x.zoom);
          const P = d[0] * s.EXTENT, F = d[1] * s.EXTENT;
          S.u_up_dir = x.projection.upVector(new s.CanonicalTileID(0, 0, 0), P, F);
        }
        return S;
      }, pc = (l, r, o, u, d, f, g) => {
        const x = l.transform, b = x.calculatePixelsToTileUnitsMatrix(r);
        return { u_matrix: Kn(l, r, o, u), u_pixels_to_tile_units: b, u_device_pixel_ratio: f, u_units_to_pixels: [1 / x.pixelsToGLUnits[0], 1 / x.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: d, u_texsize: cs(o) ? r.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: ls(r, l.transform), u_alpha_discard_threshold: 0, u_trim_offset: g };
      }, on = (l, r, o, u, d) => {
        const f = l.transform;
        return { u_matrix: Kn(l, r, o, u), u_texsize: r.imageAtlasTexture.size, u_pixels_to_tile_units: f.calculatePixelsToTileUnitsMatrix(r), u_device_pixel_ratio: d, u_image: 0, u_tile_units_to_pixels: ls(r, f), u_units_to_pixels: [1 / f.pixelsToGLUnits[0], 1 / f.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
      };
      function ls(l, r) {
        return 1 / er(l, 1, r.tileZoom);
      }
      function Kn(l, r, o, u) {
        return l.translatePosMatrix(u || r.tileID.projMatrix, r, o.paint.get("line-translate"), o.paint.get("line-translate-anchor"));
      }
      function cs(l) {
        const r = l.paint.get("line-dasharray").value;
        return r.value || r.kind !== "constant";
      }
      const Na = (l, r, o, u, d, f) => {
        return { u_matrix: l, u_tl_parent: r, u_scale_parent: o, u_fade_t: u.mix, u_opacity: u.opacity * d.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d.paint.get("raster-brightness-min"), u_brightness_high: d.paint.get("raster-brightness-max"), u_saturation_factor: (x = d.paint.get("raster-saturation"), x > 0 ? 1 - 1 / (1.001 - x) : -x), u_contrast_factor: (g = d.paint.get("raster-contrast"), g > 0 ? 1 / (1 - g) : 1 + g), u_spin_weights: Kr(d.paint.get("raster-hue-rotate")), u_perspective_transform: f };
        var g, x;
      };
      function Kr(l) {
        l *= Math.PI / 180;
        const r = Math.sin(l), o = Math.cos(l);
        return [(2 * o + 1) / 3, (-Math.sqrt(3) * r - o + 1) / 3, (Math.sqrt(3) * r - o + 1) / 3];
      }
      const us = s.create(), oa = (l, r, o, u, d, f, g, x, b, M, S, P, F, j, $, G) => {
        const Z = d.transform, L = { u_is_size_zoom_constant: +(l === "constant" || l === "source"), u_is_size_feature_constant: +(l === "constant" || l === "camera"), u_size_t: r ? r.uSizeT : 0, u_size: r ? r.uSize : 0, u_camera_to_center_distance: Z.cameraToCenterDistance, u_rotate_symbol: +o, u_aspect_ratio: Z.width / Z.height, u_fade_change: d.options.fadeDuration ? d.symbolFadeChange : 1, u_matrix: f, u_label_plane_matrix: g, u_coord_matrix: x, u_is_text: +b, u_pitch_with_map: +u, u_texsize: M, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: us, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: us, u_up_vector: [0, -1, 0] };
        return G.name === "globe" && (L.u_tile_id = [S.canonical.x, S.canonical.y, 1 << S.canonical.z], L.u_zoom_transition = P, L.u_inv_rot_matrix = j, L.u_merc_center = F, L.u_camera_forward = Z._camera.forward(), L.u_ecef_origin = s.globeECEFOrigin(Z.globeMatrix, S.toUnwrapped()), L.u_tile_matrix = Float32Array.from(Z.globeMatrix), L.u_up_vector = $), L;
      }, Rs = (l, r, o, u, d, f, g, x, b, M, S, P, F, j, $, G, Z) => s.extend(oa(l, r, o, u, d, f, g, x, b, M, P, F, j, $, G, Z), { u_gamma_scale: u ? d.transform.cameraToCenterDistance * Math.cos(d.terrain ? 0 : d.transform._pitch) : 1, u_device_pixel_ratio: s.exported.devicePixelRatio, u_is_halo: +S }), ja = (l, r, o, u, d, f, g, x, b, M, S, P, F, j, $, G) => s.extend(Rs(l, r, o, u, d, f, g, x, !0, b, !0, S, P, F, j, $, G), { u_texsize_icon: M, u_texture_icon: 1 }), Bo = (l, r, o) => ({ u_matrix: l, u_opacity: r, u_color: o }), Sl = (l, r, o, u, d) => s.extend(function(f, g, x) {
        const b = g.imageManager.getPattern(f.toString()), { width: M, height: S } = g.imageManager.getPixelSize(), P = Math.pow(2, x.tileID.overscaledZ), F = x.tileSize * Math.pow(2, g.transform.tileZoom) / P, j = F * (x.tileID.canonical.x + x.tileID.wrap * P), $ = F * x.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl: b.tl, u_pattern_br: b.br, u_texsize: [M, S], u_pattern_size: b.displaySize, u_tile_units_to_pixels: 1 / er(x, 1, g.transform.tileZoom), u_pixel_coord_upper: [j >> 16, $ >> 16], u_pixel_coord_lower: [65535 & j, 65535 & $] };
      }(u, o, d), { u_matrix: l, u_opacity: r }), Va = { fillExtrusion: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_lightpos: new s.Uniform3f(l), u_lightintensity: new s.Uniform1f(l), u_lightcolor: new s.Uniform3f(l), u_vertical_gradient: new s.Uniform1f(l), u_opacity: new s.Uniform1f(l), u_edge_radius: new s.Uniform1f(l), u_ao: new s.Uniform2f(l), u_tile_id: new s.Uniform3f(l), u_zoom_transition: new s.Uniform1f(l), u_inv_rot_matrix: new s.UniformMatrix4f(l), u_merc_center: new s.Uniform2f(l), u_up_dir: new s.Uniform3f(l), u_height_lift: new s.Uniform1f(l) }), fillExtrusionPattern: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_lightpos: new s.Uniform3f(l), u_lightintensity: new s.Uniform1f(l), u_lightcolor: new s.Uniform3f(l), u_vertical_gradient: new s.Uniform1f(l), u_height_factor: new s.Uniform1f(l), u_edge_radius: new s.Uniform1f(l), u_ao: new s.Uniform2f(l), u_tile_id: new s.Uniform3f(l), u_zoom_transition: new s.Uniform1f(l), u_inv_rot_matrix: new s.UniformMatrix4f(l), u_merc_center: new s.Uniform2f(l), u_up_dir: new s.Uniform3f(l), u_height_lift: new s.Uniform1f(l), u_image: new s.Uniform1i(l), u_texsize: new s.Uniform2f(l), u_pixel_coord_upper: new s.Uniform2f(l), u_pixel_coord_lower: new s.Uniform2f(l), u_tile_units_to_pixels: new s.Uniform1f(l), u_opacity: new s.Uniform1f(l) }), fill: (l) => ({ u_matrix: new s.UniformMatrix4f(l) }), fillPattern: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_image: new s.Uniform1i(l), u_texsize: new s.Uniform2f(l), u_pixel_coord_upper: new s.Uniform2f(l), u_pixel_coord_lower: new s.Uniform2f(l), u_tile_units_to_pixels: new s.Uniform1f(l) }), fillOutline: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_world: new s.Uniform2f(l) }), fillOutlinePattern: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_world: new s.Uniform2f(l), u_image: new s.Uniform1i(l), u_texsize: new s.Uniform2f(l), u_pixel_coord_upper: new s.Uniform2f(l), u_pixel_coord_lower: new s.Uniform2f(l), u_tile_units_to_pixels: new s.Uniform1f(l) }), circle: (l) => ({ u_camera_to_center_distance: new s.Uniform1f(l), u_extrude_scale: new s.UniformMatrix2f(l), u_device_pixel_ratio: new s.Uniform1f(l), u_matrix: new s.UniformMatrix4f(l), u_inv_rot_matrix: new s.UniformMatrix4f(l), u_merc_center: new s.Uniform2f(l), u_tile_id: new s.Uniform3f(l), u_zoom_transition: new s.Uniform1f(l), u_up_dir: new s.Uniform3f(l) }), collisionBox: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_camera_to_center_distance: new s.Uniform1f(l), u_extrude_scale: new s.Uniform2f(l) }), collisionCircle: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_inv_matrix: new s.UniformMatrix4f(l), u_camera_to_center_distance: new s.Uniform1f(l), u_viewport_size: new s.Uniform2f(l) }), debug: (l) => ({ u_color: new s.UniformColor(l), u_matrix: new s.UniformMatrix4f(l), u_overlay: new s.Uniform1i(l), u_overlay_scale: new s.Uniform1f(l) }), clippingMask: (l) => ({ u_matrix: new s.UniformMatrix4f(l) }), heatmap: (l) => ({ u_extrude_scale: new s.Uniform1f(l), u_intensity: new s.Uniform1f(l), u_matrix: new s.UniformMatrix4f(l), u_inv_rot_matrix: new s.UniformMatrix4f(l), u_merc_center: new s.Uniform2f(l), u_tile_id: new s.Uniform3f(l), u_zoom_transition: new s.Uniform1f(l), u_up_dir: new s.Uniform3f(l) }), heatmapTexture: (l) => ({ u_image: new s.Uniform1i(l), u_color_ramp: new s.Uniform1i(l), u_opacity: new s.Uniform1f(l) }), hillshade: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_image: new s.Uniform1i(l), u_latrange: new s.Uniform2f(l), u_light: new s.Uniform2f(l), u_shadow: new s.UniformColor(l), u_highlight: new s.UniformColor(l), u_accent: new s.UniformColor(l) }), hillshadePrepare: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_image: new s.Uniform1i(l), u_dimension: new s.Uniform2f(l), u_zoom: new s.Uniform1f(l), u_unpack: new s.Uniform4f(l) }), line: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_pixels_to_tile_units: new s.UniformMatrix2f(l), u_device_pixel_ratio: new s.Uniform1f(l), u_units_to_pixels: new s.Uniform2f(l), u_dash_image: new s.Uniform1i(l), u_gradient_image: new s.Uniform1i(l), u_image_height: new s.Uniform1f(l), u_texsize: new s.Uniform2f(l), u_tile_units_to_pixels: new s.Uniform1f(l), u_alpha_discard_threshold: new s.Uniform1f(l), u_trim_offset: new s.Uniform2f(l) }), linePattern: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_texsize: new s.Uniform2f(l), u_pixels_to_tile_units: new s.UniformMatrix2f(l), u_device_pixel_ratio: new s.Uniform1f(l), u_image: new s.Uniform1i(l), u_units_to_pixels: new s.Uniform2f(l), u_tile_units_to_pixels: new s.Uniform1f(l), u_alpha_discard_threshold: new s.Uniform1f(l) }), raster: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_tl_parent: new s.Uniform2f(l), u_scale_parent: new s.Uniform1f(l), u_fade_t: new s.Uniform1f(l), u_opacity: new s.Uniform1f(l), u_image0: new s.Uniform1i(l), u_image1: new s.Uniform1i(l), u_brightness_low: new s.Uniform1f(l), u_brightness_high: new s.Uniform1f(l), u_saturation_factor: new s.Uniform1f(l), u_contrast_factor: new s.Uniform1f(l), u_spin_weights: new s.Uniform3f(l), u_perspective_transform: new s.Uniform2f(l) }), symbolIcon: (l) => ({ u_is_size_zoom_constant: new s.Uniform1i(l), u_is_size_feature_constant: new s.Uniform1i(l), u_size_t: new s.Uniform1f(l), u_size: new s.Uniform1f(l), u_camera_to_center_distance: new s.Uniform1f(l), u_rotate_symbol: new s.Uniform1i(l), u_aspect_ratio: new s.Uniform1f(l), u_fade_change: new s.Uniform1f(l), u_matrix: new s.UniformMatrix4f(l), u_label_plane_matrix: new s.UniformMatrix4f(l), u_coord_matrix: new s.UniformMatrix4f(l), u_is_text: new s.Uniform1i(l), u_pitch_with_map: new s.Uniform1i(l), u_texsize: new s.Uniform2f(l), u_tile_id: new s.Uniform3f(l), u_zoom_transition: new s.Uniform1f(l), u_inv_rot_matrix: new s.UniformMatrix4f(l), u_merc_center: new s.Uniform2f(l), u_camera_forward: new s.Uniform3f(l), u_tile_matrix: new s.UniformMatrix4f(l), u_up_vector: new s.Uniform3f(l), u_ecef_origin: new s.Uniform3f(l), u_texture: new s.Uniform1i(l) }), symbolSDF: (l) => ({ u_is_size_zoom_constant: new s.Uniform1i(l), u_is_size_feature_constant: new s.Uniform1i(l), u_size_t: new s.Uniform1f(l), u_size: new s.Uniform1f(l), u_camera_to_center_distance: new s.Uniform1f(l), u_rotate_symbol: new s.Uniform1i(l), u_aspect_ratio: new s.Uniform1f(l), u_fade_change: new s.Uniform1f(l), u_matrix: new s.UniformMatrix4f(l), u_label_plane_matrix: new s.UniformMatrix4f(l), u_coord_matrix: new s.UniformMatrix4f(l), u_is_text: new s.Uniform1i(l), u_pitch_with_map: new s.Uniform1i(l), u_texsize: new s.Uniform2f(l), u_texture: new s.Uniform1i(l), u_gamma_scale: new s.Uniform1f(l), u_device_pixel_ratio: new s.Uniform1f(l), u_tile_id: new s.Uniform3f(l), u_zoom_transition: new s.Uniform1f(l), u_inv_rot_matrix: new s.UniformMatrix4f(l), u_merc_center: new s.Uniform2f(l), u_camera_forward: new s.Uniform3f(l), u_tile_matrix: new s.UniformMatrix4f(l), u_up_vector: new s.Uniform3f(l), u_ecef_origin: new s.Uniform3f(l), u_is_halo: new s.Uniform1i(l) }), symbolTextAndIcon: (l) => ({ u_is_size_zoom_constant: new s.Uniform1i(l), u_is_size_feature_constant: new s.Uniform1i(l), u_size_t: new s.Uniform1f(l), u_size: new s.Uniform1f(l), u_camera_to_center_distance: new s.Uniform1f(l), u_rotate_symbol: new s.Uniform1i(l), u_aspect_ratio: new s.Uniform1f(l), u_fade_change: new s.Uniform1f(l), u_matrix: new s.UniformMatrix4f(l), u_label_plane_matrix: new s.UniformMatrix4f(l), u_coord_matrix: new s.UniformMatrix4f(l), u_is_text: new s.Uniform1i(l), u_pitch_with_map: new s.Uniform1i(l), u_texsize: new s.Uniform2f(l), u_texsize_icon: new s.Uniform2f(l), u_texture: new s.Uniform1i(l), u_texture_icon: new s.Uniform1i(l), u_gamma_scale: new s.Uniform1f(l), u_device_pixel_ratio: new s.Uniform1f(l), u_is_halo: new s.Uniform1i(l) }), background: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_opacity: new s.Uniform1f(l), u_color: new s.UniformColor(l) }), backgroundPattern: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_opacity: new s.Uniform1f(l), u_image: new s.Uniform1i(l), u_pattern_tl: new s.Uniform2f(l), u_pattern_br: new s.Uniform2f(l), u_texsize: new s.Uniform2f(l), u_pattern_size: new s.Uniform2f(l), u_pixel_coord_upper: new s.Uniform2f(l), u_pixel_coord_lower: new s.Uniform2f(l), u_tile_units_to_pixels: new s.Uniform1f(l) }), terrainRaster: Ra, terrainDepth: Ra, skybox: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_sun_direction: new s.Uniform3f(l), u_cubemap: new s.Uniform1i(l), u_opacity: new s.Uniform1f(l), u_temporal_offset: new s.Uniform1f(l) }), skyboxGradient: (l) => ({ u_matrix: new s.UniformMatrix4f(l), u_color_ramp: new s.Uniform1i(l), u_center_direction: new s.Uniform3f(l), u_radius: new s.Uniform1f(l), u_opacity: new s.Uniform1f(l), u_temporal_offset: new s.Uniform1f(l) }), skyboxCapture: (l) => ({ u_matrix_3f: new s.UniformMatrix3f(l), u_sun_direction: new s.Uniform3f(l), u_sun_intensity: new s.Uniform1f(l), u_color_tint_r: new s.Uniform4f(l), u_color_tint_m: new s.Uniform4f(l), u_luminance: new s.Uniform1f(l) }), globeRaster: (l) => ({ u_proj_matrix: new s.UniformMatrix4f(l), u_globe_matrix: new s.UniformMatrix4f(l), u_normalize_matrix: new s.UniformMatrix4f(l), u_merc_matrix: new s.UniformMatrix4f(l), u_zoom_transition: new s.Uniform1f(l), u_merc_center: new s.Uniform2f(l), u_image0: new s.Uniform1i(l), u_grid_matrix: new s.UniformMatrix3f(l), u_skirt_height: new s.Uniform1f(l), u_frustum_tl: new s.Uniform3f(l), u_frustum_tr: new s.Uniform3f(l), u_frustum_br: new s.Uniform3f(l), u_frustum_bl: new s.Uniform3f(l), u_globe_pos: new s.Uniform3f(l), u_globe_radius: new s.Uniform1f(l), u_viewport: new s.Uniform2f(l) }), globeAtmosphere: (l) => ({ u_frustum_tl: new s.Uniform3f(l), u_frustum_tr: new s.Uniform3f(l), u_frustum_br: new s.Uniform3f(l), u_frustum_bl: new s.Uniform3f(l), u_horizon: new s.Uniform1f(l), u_transition: new s.Uniform1f(l), u_fadeout_range: new s.Uniform1f(l), u_color: new s.Uniform4f(l), u_high_color: new s.Uniform4f(l), u_space_color: new s.Uniform4f(l), u_star_intensity: new s.Uniform1f(l), u_star_density: new s.Uniform1f(l), u_star_size: new s.Uniform1f(l), u_temporal_offset: new s.Uniform1f(l), u_horizon_angle: new s.Uniform1f(l), u_rotation_matrix: new s.UniformMatrix4f(l) }) };
      let ye;
      function ze(l, r, o, u, d, f, g) {
        const x = l.context, b = x.gl, M = l.transform, S = l.useProgram("collisionBox"), P = [];
        let F = 0, j = 0;
        for (let K = 0; K < u.length; K++) {
          const le = u[K], ue = r.getTile(le), ce = ue.getBucket(o);
          if (!ce) continue;
          const ge = Y(le, ce, M);
          let me = ge;
          d[0] === 0 && d[1] === 0 || (me = l.translatePosMatrix(ge, ue, d, f));
          const Ee = g ? ce.textCollisionBox : ce.iconCollisionBox, Ge = ce.collisionCircleArray;
          if (Ge.length > 0) {
            const be = s.create(), Oe = me;
            s.mul(be, ce.placementInvProjMatrix, M.glCoordMatrix), s.mul(be, be, ce.placementViewportMatrix), P.push({ circleArray: Ge, circleOffset: j, transform: Oe, invTransform: be, projection: ce.getProjection() }), F += Ge.length / 4, j = F;
          }
          Ee && (l.terrain && l.terrain.setupElevationDraw(ue, S), S.draw(x, b.LINES, s.DepthMode.disabled, s.StencilMode.disabled, l.colorModeForRenderPass(), s.CullFaceMode.disabled, na(me, M, ue, ce.getProjection()), o.id, Ee.layoutVertexBuffer, Ee.indexBuffer, Ee.segments, null, M.zoom, null, [Ee.collisionVertexBuffer, Ee.collisionVertexBufferExt]));
        }
        if (!g || !P.length) return;
        const $ = l.useProgram("collisionCircle"), G = new s.StructArrayLayout2f1f2i16();
        G.resize(4 * F), G._trim();
        let Z = 0;
        for (const K of P) for (let le = 0; le < K.circleArray.length / 4; le++) {
          const ue = 4 * le, ce = K.circleArray[ue + 0], ge = K.circleArray[ue + 1], me = K.circleArray[ue + 2], Ee = K.circleArray[ue + 3];
          G.emplace(Z++, ce, ge, me, Ee, 0), G.emplace(Z++, ce, ge, me, Ee, 1), G.emplace(Z++, ce, ge, me, Ee, 2), G.emplace(Z++, ce, ge, me, Ee, 3);
        }
        (!ye || ye.length < 2 * F) && (ye = function(K) {
          const le = 2 * K, ue = new s.StructArrayLayout3ui6();
          ue.resize(le), ue._trim();
          for (let ce = 0; ce < le; ce++) {
            const ge = 6 * ce;
            ue.uint16[ge + 0] = 4 * ce + 0, ue.uint16[ge + 1] = 4 * ce + 1, ue.uint16[ge + 2] = 4 * ce + 2, ue.uint16[ge + 3] = 4 * ce + 2, ue.uint16[ge + 4] = 4 * ce + 3, ue.uint16[ge + 5] = 4 * ce + 0;
          }
          return ue;
        }(F));
        const L = x.createIndexBuffer(ye, !0), N = x.createVertexBuffer(G, s.collisionCircleLayout.members, !0);
        for (const K of P) {
          const le = { u_matrix: K.transform, u_inv_matrix: K.invTransform, u_camera_to_center_distance: (X = M).getCameraToCenterDistance(K.projection), u_viewport_size: [X.width, X.height] };
          $.draw(x, b.TRIANGLES, s.DepthMode.disabled, s.StencilMode.disabled, l.colorModeForRenderPass(), s.CullFaceMode.disabled, le, o.id, N, L, s.SegmentVector.simpleSegment(0, 2 * K.circleOffset, K.circleArray.length, K.circleArray.length / 2), null, M.zoom);
        }
        var X;
        N.destroy(), L.destroy();
      }
      const ht = s.create();
      function Mt({ width: l, height: r, anchor: o, textOffset: u, textScale: d }, f) {
        const { horizontalAlign: g, verticalAlign: x } = s.getAnchorAlignment(o), b = -(g - 0.5) * l, M = -(x - 0.5) * r, S = s.evaluateVariableOffset(o, u);
        return new s.Point((b / d + S[0]) * f, (M / d + S[1]) * f);
      }
      function Ni(l, r, o, u, d, f, g, x, b, M, S) {
        const P = l.text.placedSymbolArray, F = l.text.dynamicLayoutVertexArray, j = l.icon.dynamicLayoutVertexArray, $ = {}, G = l.getProjection(), Z = ne(x, G, f), L = f.elevation, N = G.upVectorScale(x.canonical, f.center.lat, f.worldSize).metersToTile;
        F.clear();
        for (let X = 0; X < P.length; X++) {
          const K = P.get(X), { tileAnchorX: le, tileAnchorY: ue, numGlyphs: ce } = K, ge = K.hidden || !K.crossTileID || l.allowVerticalPlacement && !K.placedOrientation ? null : u[K.crossTileID];
          if (ge) {
            let me = 0, Ee = 0, Ge = 0;
            if (L) {
              const He = L ? L.getAtTileOffset(x, le, ue) : 0, [wt, Dt, gt] = G.upVector(x.canonical, le, ue);
              me = He * wt * N, Ee = He * Dt * N, Ge = He * gt * N;
            }
            let [be, Oe, Ce, Ve] = lr(K.projectedAnchorX + me, K.projectedAnchorY + Ee, K.projectedAnchorZ + Ge, o ? Z : g);
            const Te = xl(f.getCameraToCenterDistance(G), Ve);
            let Re = d.evaluateSizeForFeature(l.textSizeData, M, K) * Te / s.ONE_EM;
            o && (Re *= l.tilePixelRatio / b);
            const We = Mt(ge, Re);
            o ? ({ x: be, y: Oe, z: Ce } = G.projectTilePoint(le + We.x, ue + We.y, x.canonical), [be, Oe, Ce] = lr(be + me, Oe + Ee, Ce + Ge, g)) : (r && We._rotate(-f.angle), be += We.x, Oe += We.y, Ce = 0);
            const Ne = l.allowVerticalPlacement && K.placedOrientation === s.WritingMode.vertical ? Math.PI / 2 : 0;
            for (let He = 0; He < ce; He++) s.addDynamicAttributes(F, be, Oe, Ce, Ne);
            S && K.associatedIconIndex >= 0 && ($[K.associatedIconIndex] = { x: be, y: Oe, z: Ce, angle: Ne });
          } else yn(ce, F);
        }
        if (S) {
          j.clear();
          const X = l.icon.placedSymbolArray;
          for (let K = 0; K < X.length; K++) {
            const le = X.get(K), { numGlyphs: ue } = le, ce = $[K];
            if (le.hidden || !ce) yn(ue, j);
            else {
              const { x: ge, y: me, z: Ee, angle: Ge } = ce;
              for (let be = 0; be < ue; be++) s.addDynamicAttributes(j, ge, me, Ee, Ge);
            }
          }
          l.icon.dynamicLayoutVertexBuffer.updateData(j);
        }
        l.text.dynamicLayoutVertexBuffer.updateData(F);
      }
      function ri(l, r, o) {
        return o.iconsInText && r ? "symbolTextAndIcon" : l ? "symbolSDF" : "symbolIcon";
      }
      function Wi(l, r, o, u, d, f, g, x, b, M, S, P) {
        const F = l.context, j = F.gl, $ = l.transform, G = x === "map", Z = b === "map", L = G && o.layout.get("symbol-placement") !== "point", N = G && !Z && !L, X = o.layout.get("symbol-sort-key").constantOr(1) !== void 0;
        let K = !1;
        const le = l.depthModeForSublayer(0, s.DepthMode.ReadOnly), ue = [s.mercatorXfromLng($.center.lng), s.mercatorYfromLat($.center.lat)], ce = o.layout.get("text-variable-anchor"), ge = $.projection.name === "globe", me = [], Ee = [0, -1, 0];
        let Ge = Ee;
        !ge && !$.mercatorFromTransition || G || (Ge = function(be) {
          const Oe = be._camera.getWorldToCamera(be.worldSize, 1), Ce = s.multiply([], Oe, be.globeMatrix);
          s.invert(Ce, Ce);
          const Ve = [0, 0, 0], Te = [0, 1, 0, 0];
          return s.transformMat4$1(Te, Te, Ce), Ve[0] = Te[0], Ve[1] = Te[1], Ve[2] = Te[2], s.normalize(Ve, Ve), Ve;
        }($));
        for (const be of u) {
          const Oe = r.getTile(be), Ce = Oe.getBucket(o);
          if (!Ce || Ce.projection.name === "mercator" && ge) continue;
          const Ve = d ? Ce.text : Ce.icon;
          if (!Ve || Ce.fullyClipped || !Ve.segments.get().length) continue;
          const Te = Ve.programConfigurations.get(o.id), Re = d || Ce.sdfIcons, We = d ? Ce.textSizeData : Ce.iconSizeData, Ne = Z || $.pitch !== 0, He = s.evaluateSizeForZoom(We, $.zoom);
          let wt, Dt, gt, Ct, ti = [0, 0], Yt = null;
          if (d) Dt = Oe.glyphAtlasTexture, gt = j.LINEAR, wt = Oe.glyphAtlasTexture.size, Ce.iconsInText && (ti = Oe.imageAtlasTexture.size, Yt = Oe.imageAtlasTexture, Ct = Ne || l.options.rotating || l.options.zooming || We.kind === "composite" || We.kind === "camera" ? j.LINEAR : j.NEAREST);
          else {
            const Vo = o.layout.get("icon-size").constantOr(0) !== 1 || Ce.iconsNeedLinear;
            Dt = Oe.imageAtlasTexture, gt = Re || l.options.rotating || l.options.zooming || Vo || Ne ? j.LINEAR : j.NEAREST, wt = Oe.imageAtlasTexture.size;
          }
          const vt = Ce.projection.name === "globe", vi = vt ? Ge : Ee, Ti = vt ? s.globeToMercatorTransition($.zoom) : 0, Ei = ne(be, Ce.getProjection(), $), Si = $.calculatePixelsToTileUnitsMatrix(Oe), Vr = Pe(Ei, Oe.tileID.canonical, Z, G, $, Ce.getProjection(), Si), Er = l.terrain && Z && L ? s.invert(s.create(), Vr) : ht, kn = Li(Ei, Oe.tileID.canonical, Z, G, $, Ce.getProjection(), Si), Eo = ce && Ce.hasTextData(), Gi = o.layout.get("icon-text-fit") !== "none" && Eo && Ce.hasIconData();
          if (L) {
            const Vo = $.elevation, ps = Vo ? Vo.getAtTileOffsetFunc(be, $.center.lat, $.worldSize, Ce.getProjection()) : null, Ns = Cr(Ei, Oe.tileID.canonical, Z, G, $, Ce.getProjection(), Si);
            Aa(Ce, Ei, l, d, Ns, kn, Z, M, ps, be);
          }
          const Mi = L || d && ce || Gi, fi = l.translatePosMatrix(Ei, Oe, f, g), cr = Mi ? ht : Vr, Jr = l.translatePosMatrix(kn, Oe, f, g, !0), ji = Ce.getProjection().createInversionMatrix($, be.canonical), cn = [];
          l.terrainRenderModeElevated() && Z && cn.push("PITCH_WITH_MAP_TERRAIN"), vt && cn.push("PROJECTION_GLOBE_VIEW"), Mi && cn.push("PROJECTED_POS_ON_VIEWPORT");
          const Rl = Re && o.paint.get(d ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let Us;
          Us = Re ? Ce.iconsInText ? ja(We.kind, He, N, Z, l, fi, cr, Jr, wt, ti, be, Ti, ue, ji, vi, Ce.getProjection()) : Rs(We.kind, He, N, Z, l, fi, cr, Jr, d, wt, !0, be, Ti, ue, ji, vi, Ce.getProjection()) : oa(We.kind, He, N, Z, l, fi, cr, Jr, d, wt, be, Ti, ue, ji, vi, Ce.getProjection());
          const Ja = { program: l.useProgram(ri(Re, d, Ce), Te, cn), buffers: Ve, uniformValues: Us, atlasTexture: Dt, atlasTextureIcon: Yt, atlasInterpolation: gt, atlasInterpolationIcon: Ct, isSDF: Re, hasHalo: Rl, tile: Oe, labelPlaneMatrixInv: Er };
          if (X && Ce.canOverlap) {
            K = !0;
            const Vo = Ve.segments.get();
            for (const ps of Vo) me.push({ segments: new s.SegmentVector([ps]), sortKey: ps.sortKey, state: Ja });
          } else me.push({ segments: Ve.segments, sortKey: 0, state: Ja });
        }
        K && me.sort((be, Oe) => be.sortKey - Oe.sortKey);
        for (const be of me) {
          const Oe = be.state;
          if (l.terrain && l.terrain.setupElevationDraw(Oe.tile, Oe.program, { useDepthForOcclusion: !ge, labelPlaneMatrixInv: Oe.labelPlaneMatrixInv }), F.activeTexture.set(j.TEXTURE0), Oe.atlasTexture.bind(Oe.atlasInterpolation, j.CLAMP_TO_EDGE), Oe.atlasTextureIcon && (F.activeTexture.set(j.TEXTURE1), Oe.atlasTextureIcon && Oe.atlasTextureIcon.bind(Oe.atlasInterpolationIcon, j.CLAMP_TO_EDGE)), Oe.isSDF) {
            const Ce = Oe.uniformValues;
            Oe.hasHalo && (Ce.u_is_halo = 1, Vi(Oe.buffers, be.segments, o, l, Oe.program, le, S, P, Ce)), Ce.u_is_halo = 0;
          }
          Vi(Oe.buffers, be.segments, o, l, Oe.program, le, S, P, Oe.uniformValues);
        }
      }
      function Vi(l, r, o, u, d, f, g, x, b) {
        const M = u.context, S = [l.dynamicLayoutVertexBuffer, l.opacityVertexBuffer, l.globeExtVertexBuffer];
        d.draw(M, M.gl.TRIANGLES, f, g, x, s.CullFaceMode.disabled, b, o.id, l.layoutVertexBuffer, l.indexBuffer, r, o.paint, u.transform.zoom, l.programConfigurations.get(o.id), S);
      }
      function sn(l, r, o, u, d, f, g) {
        const x = l.context.gl, b = o.paint.get("fill-pattern"), M = b && b.constantOr(1);
        let S, P, F, j, $;
        g ? (P = M && !o.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", S = x.LINES) : (P = M ? "fillPattern" : "fill", S = x.TRIANGLES);
        for (const G of u) {
          const Z = r.getTile(G);
          if (M && !Z.patternsLoaded()) continue;
          const L = Z.getBucket(o);
          if (!L) continue;
          l.prepareDrawTile();
          const N = L.programConfigurations.get(o.id), X = l.useProgram(P, N);
          M && (l.context.activeTexture.set(x.TEXTURE0), Z.imageAtlasTexture.bind(x.LINEAR, x.CLAMP_TO_EDGE), N.updatePaintBuffers());
          const K = b.constantOr(null);
          if (K && Z.imageAtlas) {
            const ue = Z.imageAtlas.patternPositions[K.toString()];
            ue && N.setConstantPatternPositions(ue);
          }
          const le = l.translatePosMatrix(G.projMatrix, Z, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));
          if (g) {
            j = L.indexBuffer2, $ = L.segments2;
            const ue = l.terrain && l.terrain.renderingToTexture ? l.terrain.drapeBufferSize : [x.drawingBufferWidth, x.drawingBufferHeight];
            F = P === "fillOutlinePattern" && M ? Tl(le, l, Z, ue) : zs(le, ue);
          } else j = L.indexBuffer, $ = L.segments, F = M ? as(le, l, Z) : Ro(le);
          l.prepareDrawProgram(l.context, X, G.toUnwrapped()), X.draw(l.context, S, d, l.stencilModeForClipping(G), f, s.CullFaceMode.disabled, F, o.id, L.layoutVertexBuffer, j, $, o.paint, l.transform.zoom, N);
        }
      }
      function Ki(l, r, o, u, d, f, g) {
        const x = l.context, b = x.gl, M = l.transform, S = o.paint.get("fill-extrusion-pattern"), P = S.constantOr(1), F = o.paint.get("fill-extrusion-opacity"), j = [o.paint.get("fill-extrusion-ambient-occlusion-intensity"), o.paint.get("fill-extrusion-ambient-occlusion-radius")], $ = o.layout.get("fill-extrusion-edge-radius"), G = $ > 0 && !o.paint.get("fill-extrusion-rounded-roof"), Z = G ? 0 : $, L = M.projection.name === "globe" ? s.fillExtrusionHeightLift() : 0, N = M.projection.name === "globe", X = N ? s.globeToMercatorTransition(M.zoom) : 0, K = [s.mercatorXfromLng(M.center.lng), s.mercatorYfromLat(M.center.lat)], le = [];
        N && le.push("PROJECTION_GLOBE_VIEW"), j[0] > 0 && le.push("FAUX_AO"), G && le.push("ZERO_ROOF_RADIUS");
        for (const ue of u) {
          const ce = r.getTile(ue), ge = ce.getBucket(o);
          if (!ge || ge.projection.name !== M.projection.name) continue;
          const me = ge.programConfigurations.get(o.id), Ee = l.useProgram(P ? "fillExtrusionPattern" : "fillExtrusion", me, le);
          if (l.terrain) {
            const Re = l.terrain;
            if (l.style.terrainSetForDrapingOnly()) Re.setupElevationDraw(ce, Ee, { useMeterToDem: !0 });
            else {
              if (!ge.enableTerrain) continue;
              if (Re.setupElevationDraw(ce, Ee, { useMeterToDem: !0 }), ir(x, r, ue, ge, o, Re), !ge.centroidVertexBuffer) {
                const We = Ee.attributes.a_centroid_pos;
                We !== void 0 && b.vertexAttrib2f(We, 0, 0);
              }
            }
          }
          P && (l.context.activeTexture.set(b.TEXTURE0), ce.imageAtlasTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE), me.updatePaintBuffers());
          const Ge = S.constantOr(null);
          if (Ge && ce.imageAtlas) {
            const Re = ce.imageAtlas.patternPositions[Ge.toString()];
            Re && me.setConstantPatternPositions(Re);
          }
          const be = l.translatePosMatrix(ue.projMatrix, ce, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), Oe = M.projection.createInversionMatrix(M, ue.canonical), Ce = o.paint.get("fill-extrusion-vertical-gradient"), Ve = P ? Hn(be, l, Ce, F, j, Z, ue, ce, L, X, K, Oe) : ss(be, l, Ce, F, j, Z, ue, L, X, K, Oe);
          l.prepareDrawProgram(x, Ee, ue.toUnwrapped());
          const Te = [];
          l.terrain && Te.push(ge.centroidVertexBuffer), N && Te.push(ge.layoutVertexExtBuffer), Ee.draw(x, x.gl.TRIANGLES, d, f, g, s.CullFaceMode.backCCW, Ve, o.id, ge.layoutVertexBuffer, ge.indexBuffer, ge.segments, o.paint, l.transform.zoom, me, Te);
        }
      }
      function ir(l, r, o, u, d, f) {
        const g = [(L) => {
          let N = L.canonical.x - 1, X = L.wrap;
          return N < 0 && (N = (1 << L.canonical.z) - 1, X--), new s.OverscaledTileID(L.overscaledZ, X, L.canonical.z, N, L.canonical.y);
        }, (L) => {
          let N = L.canonical.x + 1, X = L.wrap;
          return N === 1 << L.canonical.z && (N = 0, X++), new s.OverscaledTileID(L.overscaledZ, X, L.canonical.z, N, L.canonical.y);
        }, (L) => new s.OverscaledTileID(L.overscaledZ, L.wrap, L.canonical.z, L.canonical.x, (L.canonical.y === 0 ? 1 << L.canonical.z : L.canonical.y) - 1), (L) => new s.OverscaledTileID(L.overscaledZ, L.wrap, L.canonical.z, L.canonical.x, L.canonical.y === (1 << L.canonical.z) - 1 ? 0 : L.canonical.y + 1)], x = (L) => {
          const N = r.getSource().minzoom, X = (le) => {
            const ue = r.getTileByID(le);
            if (ue && ue.hasData()) return ue.getBucket(d);
          }, K = [0, -1, 1];
          for (const le of K) {
            if (L.overscaledZ + le < N) continue;
            const ue = X(L.calculateScaledKey(L.overscaledZ + le));
            if (ue) return ue;
          }
        }, b = [0, 0, 0], M = (L, N) => (b[0] = Math.min(L.min.y, N.min.y), b[1] = Math.max(L.max.y, N.max.y), b[2] = s.EXTENT - N.min.x > L.max.x ? N.min.x - s.EXTENT : L.max.x, b), S = (L, N) => (b[0] = Math.min(L.min.x, N.min.x), b[1] = Math.max(L.max.x, N.max.x), b[2] = s.EXTENT - N.min.y > L.max.y ? N.min.y - s.EXTENT : L.max.y, b), P = [(L, N) => M(L, N), (L, N) => M(N, L), (L, N) => S(L, N), (L, N) => S(N, L)], F = new s.Point(0, 0);
        let j, $, G;
        const Z = (L, N, X, K, le) => {
          const ue = [[K ? X : L, K ? L : X, 0], [K ? X : N, K ? N : X, 0]], ce = le < 0 ? s.EXTENT + le : le, ge = [K ? ce : (L + N) / 2, K ? (L + N) / 2 : ce, 0];
          return X === 0 && le < 0 || X !== 0 && le > 0 ? f.getForTilePoints(G, [ge], !0, $) : ue.push(ge), f.getForTilePoints(o, ue, !0, j), Math.max(ue[0][2], ue[1][2], ge[2]) / f.exaggeration();
        };
        for (let L = 0; L < 4; L++) {
          const N = (L < 2 ? 1 : 5) - L, X = u.borders[L];
          if (X.length === 0) continue;
          const K = G = g[L](o), le = x(K);
          if (!(le && le instanceof s.FillExtrusionBucket && le.enableTerrain) || u.borderDoneWithNeighborZ[L] === le.canonical.z && le.borderDoneWithNeighborZ[N] === u.canonical.z || ($ = f.findDEMTileFor(K), !$ || !$.dem)) continue;
          if (!j) {
            const me = f.findDEMTileFor(o);
            if (!me || !me.dem) return;
            j = me;
          }
          const ue = le.borders[N];
          let ce = 0;
          const ge = le.borderDoneWithNeighborZ[N] !== u.canonical.z;
          if (u.canonical.z === le.canonical.z) {
            for (let me = 0; me < X.length; me++) {
              const Ee = u.featuresOnBorder[X[me]], Ge = Ee.borders[L];
              let be;
              for (; ce < ue.length && (be = le.featuresOnBorder[ue[ce]], !(be.borders[N][1] > Ge[0] + 3)); ) ge && le.encodeCentroid(void 0, be, !1), ce++;
              if (be && ce < ue.length) {
                const Oe = ce;
                let Ce = 0;
                for (; !(be.borders[N][0] > Ge[1] - 3) && (Ce++, ++ce !== ue.length); ) be = le.featuresOnBorder[ue[ce]];
                if (be = le.featuresOnBorder[ue[Oe]], Ee.intersectsCount() > 1 || be.intersectsCount() > 1 || Ce !== 1) {
                  Ce !== 1 && (ce = Oe), u.encodeCentroid(void 0, Ee, !1), ge && le.encodeCentroid(void 0, be, !1);
                  continue;
                }
                const Ve = P[L](Ee, be), Te = L % 2 ? s.EXTENT - 1 : 0;
                F.x = Z(Ve[0], Math.min(s.EXTENT - 1, Ve[1]), Te, L < 2, Ve[2]), F.y = 0, u.encodeCentroid(F, Ee, !1), ge && le.encodeCentroid(F, be, !1);
              } else u.encodeCentroid(void 0, Ee, !1);
            }
            u.borderDoneWithNeighborZ[L] = le.canonical.z, u.needsCentroidUpdate = !0, ge && (le.borderDoneWithNeighborZ[N] = u.canonical.z, le.needsCentroidUpdate = !0);
          } else {
            for (const me of X) u.encodeCentroid(void 0, u.featuresOnBorder[me], !1);
            if (ge) {
              for (const me of ue) le.encodeCentroid(void 0, le.featuresOnBorder[me], !1);
              le.borderDoneWithNeighborZ[N] = u.canonical.z, le.needsCentroidUpdate = !0;
            }
            u.borderDoneWithNeighborZ[L] = le.canonical.z, u.needsCentroidUpdate = !0;
          }
        }
        (u.needsCentroidUpdate || !u.centroidVertexBuffer && u.centroidVertexArray.length !== 0) && u.uploadCentroid(l);
      }
      const Ir = new s.Color(1, 0, 0, 1), Jn = new s.Color(0, 1, 0, 1), Pr = new s.Color(0, 0, 1, 1), Yn = new s.Color(1, 0, 1, 1), hs = new s.Color(0, 1, 1, 1);
      function sa(l, r, o) {
        const u = l.context, d = l.transform, f = u.gl, g = d.projection.name === "globe", x = g ? ["PROJECTION_GLOBE_VIEW"] : null;
        let b = o.projMatrix;
        if (g && s.globeToMercatorTransition(d.zoom) > 0) {
          const Ee = s.transitionTileAABBinECEF(o.canonical, d), Ge = s.globeDenormalizeECEF(Ee);
          b = s.multiply(new Float32Array(16), d.globeMatrix, Ge), s.multiply(b, d.projMatrix, b);
        }
        const M = l.useProgram("debug", null, x), S = r.getTileByID(o.key);
        l.terrain && l.terrain.setupElevationDraw(S, M);
        const P = s.DepthMode.disabled, F = s.StencilMode.disabled, j = l.colorModeForRenderPass(), $ = "$debug";
        u.activeTexture.set(f.TEXTURE0), l.emptyTexture.bind(f.LINEAR, f.CLAMP_TO_EDGE), g ? S._makeGlobeTileDebugBuffers(l.context, d) : S._makeDebugTileBoundsBuffers(l.context, d.projection);
        const G = S._tileDebugBuffer || l.debugBuffer, Z = S._tileDebugIndexBuffer || l.debugIndexBuffer, L = S._tileDebugSegments || l.debugSegments;
        M.draw(u, f.LINE_STRIP, P, F, j, s.CullFaceMode.disabled, ks(b, s.Color.red), $, G, Z, L, null, null, null, [S._globeTileDebugBorderBuffer]);
        const N = S.latestRawTileData, X = Math.floor((N && N.byteLength || 0) / 1024), K = r.getTile(o).tileSize, le = 512 / Math.min(K, 512) * (o.overscaledZ / d.zoom) * 0.5;
        let ue = o.canonical.toString();
        o.overscaledZ !== o.canonical.z && (ue += ` => ${o.overscaledZ}`), ue += ` ${X}kb`, function(Ee, Ge) {
          Ee.initDebugOverlayCanvas();
          const be = Ee.debugOverlayCanvas, Oe = Ee.context.gl, Ce = Ee.debugOverlayCanvas.getContext("2d");
          Ce.clearRect(0, 0, be.width, be.height), Ce.shadowColor = "white", Ce.shadowBlur = 2, Ce.lineWidth = 1.5, Ce.strokeStyle = "white", Ce.textBaseline = "top", Ce.font = "bold 36px Open Sans, sans-serif", Ce.fillText(Ge, 5, 5), Ce.strokeText(Ge, 5, 5), Ee.debugOverlayTexture.update(be), Ee.debugOverlayTexture.bind(Oe.LINEAR, Oe.CLAMP_TO_EDGE);
        }(l, ue);
        const ce = S._tileDebugTextBuffer || l.debugBuffer, ge = S._tileDebugTextIndexBuffer || l.quadTriangleIndexBuffer, me = S._tileDebugTextSegments || l.debugSegments;
        M.draw(u, f.TRIANGLES, P, F, s.ColorMode.alphaBlended, s.CullFaceMode.disabled, ks(b, s.Color.transparent, le), $, ce, ge, me, null, null, null, [S._globeTileDebugTextBuffer]);
      }
      function Fo(l, r, o, u) {
        Uo(l, 0, r + o / 2, l.transform.width, o, u);
      }
      function vo(l, r, o, u) {
        Uo(l, r - o / 2, 0, o, l.transform.height, u);
      }
      function Uo(l, r, o, u, d, f) {
        const g = l.context, x = g.gl;
        x.enable(x.SCISSOR_TEST), x.scissor(r * s.exported.devicePixelRatio, o * s.exported.devicePixelRatio, u * s.exported.devicePixelRatio, d * s.exported.devicePixelRatio), g.clear({ color: f }), x.disable(x.SCISSOR_TEST);
      }
      const Ml = s.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Cl } = Ml;
      function ci(l, r, o, u) {
        l.emplaceBack(r, o, u);
      }
      class _i {
        constructor(r) {
          this.vertexArray = new s.StructArrayLayout3f12(), this.indices = new s.StructArrayLayout3ui6(), ci(this.vertexArray, -1, -1, 1), ci(this.vertexArray, 1, -1, 1), ci(this.vertexArray, -1, 1, 1), ci(this.vertexArray, 1, 1, 1), ci(this.vertexArray, -1, -1, -1), ci(this.vertexArray, 1, -1, -1), ci(this.vertexArray, -1, 1, -1), ci(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = r.createVertexBuffer(this.vertexArray, Cl), this.indexBuffer = r.createIndexBuffer(this.indices), this.segment = s.SegmentVector.simpleSegment(0, 0, 36, 12);
        }
      }
      function Lr(l, r, o, u, d, f) {
        const g = l.gl, x = r.paint.get("sky-atmosphere-color"), b = r.paint.get("sky-atmosphere-halo-color"), M = r.paint.get("sky-atmosphere-sun-intensity"), S = ((P, F, j, $, G) => ({ u_matrix_3f: P, u_sun_direction: F, u_sun_intensity: j, u_color_tint_r: [$.r, $.g, $.b, $.a], u_color_tint_m: [G.r, G.g, G.b, G.a], u_luminance: 5e-5 }))(s.fromMat4(s.create$1(), u), d, M, x, b);
        g.framebufferTexture2D(g.FRAMEBUFFER, g.COLOR_ATTACHMENT0, g.TEXTURE_CUBE_MAP_POSITIVE_X + f, r.skyboxTexture, 0), o.draw(l, g.TRIANGLES, s.DepthMode.disabled, s.StencilMode.disabled, s.ColorMode.unblended, s.CullFaceMode.frontCW, S, "skyboxCapture", r.skyboxGeometry.vertexBuffer, r.skyboxGeometry.indexBuffer, r.skyboxGeometry.segment);
      }
      const an = s.createLayout([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class aa {
        constructor(r) {
          const o = new s.StructArrayLayout5f20();
          o.emplaceBack(-1, 1, 1, 0, 0), o.emplaceBack(1, 1, 1, 1, 0), o.emplaceBack(1, -1, 1, 1, 1), o.emplaceBack(-1, -1, 1, 0, 1);
          const u = new s.StructArrayLayout3ui6();
          u.emplaceBack(0, 1, 2), u.emplaceBack(2, 3, 0), this.vertexBuffer = r.createVertexBuffer(o, an.members), this.indexBuffer = r.createIndexBuffer(u), this.segments = s.SegmentVector.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const xr = { symbol: function(l, r, o, u, d) {
        if (l.renderPass !== "translucent") return;
        const f = s.StencilMode.disabled, g = l.colorModeForRenderPass();
        o.layout.get("text-variable-anchor") && function(x, b, M, S, P, F, j) {
          const $ = b.transform, G = P === "map", Z = F === "map";
          for (const L of x) {
            const N = S.getTile(L), X = N.getBucket(M);
            if (!X || !X.text || !X.text.segments.get().length) continue;
            const K = s.evaluateSizeForZoom(X.textSizeData, $.zoom), le = ne(L, X.getProjection(), $), ue = $.calculatePixelsToTileUnitsMatrix(N), ce = Pe(le, N.tileID.canonical, Z, G, $, X.getProjection(), ue), ge = M.layout.get("icon-text-fit") !== "none" && X.hasIconData();
            if (K) {
              const me = Math.pow(2, $.zoom - N.tileID.overscaledZ);
              Ni(X, G, Z, j, s.symbolSize, $, ce, L, me, K, ge);
            }
          }
        }(u, l, o, r, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), d), o.paint.get("icon-opacity").constantOr(1) !== 0 && Wi(l, r, o, u, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), f, g), o.paint.get("text-opacity").constantOr(1) !== 0 && Wi(l, r, o, u, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), f, g), r.map.showCollisionBoxes && (ze(l, r, o, u, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), ze(l, r, o, u, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
      }, circle: function(l, r, o, u) {
        if (l.renderPass !== "translucent") return;
        const d = o.paint.get("circle-opacity"), f = o.paint.get("circle-stroke-width"), g = o.paint.get("circle-stroke-opacity"), x = o.layout.get("circle-sort-key").constantOr(1) !== void 0;
        if (d.constantOr(1) === 0 && (f.constantOr(1) === 0 || g.constantOr(1) === 0)) return;
        const b = l.context, M = b.gl, S = l.transform, P = l.depthModeForSublayer(0, s.DepthMode.ReadOnly), F = s.StencilMode.disabled, j = l.colorModeForRenderPass(), $ = S.projection.name === "globe", G = [s.mercatorXfromLng(S.center.lng), s.mercatorYfromLat(S.center.lat)], Z = [];
        for (let N = 0; N < u.length; N++) {
          const X = u[N], K = r.getTile(X), le = K.getBucket(o);
          if (!le || le.projection.name !== S.projection.name) continue;
          const ue = le.programConfigurations.get(o.id), ce = Ua(o);
          $ && ce.push("PROJECTION_GLOBE_VIEW");
          const ge = l.useProgram("circle", ue, ce), me = le.layoutVertexBuffer, Ee = le.globeExtVertexBuffer, Ge = le.indexBuffer, be = S.projection.createInversionMatrix(S, X.canonical), Oe = { programConfiguration: ue, program: ge, layoutVertexBuffer: me, globeExtVertexBuffer: Ee, indexBuffer: Ge, uniformValues: Fa(l, X, K, be, G, o), tile: K };
          if (x) {
            const Ce = le.segments.get();
            for (const Ve of Ce) Z.push({ segments: new s.SegmentVector([Ve]), sortKey: Ve.sortKey, state: Oe });
          } else Z.push({ segments: le.segments, sortKey: 0, state: Oe });
        }
        x && Z.sort((N, X) => N.sortKey - X.sortKey);
        const L = { useDepthForOcclusion: !$ };
        for (const N of Z) {
          const { programConfiguration: X, program: K, layoutVertexBuffer: le, globeExtVertexBuffer: ue, indexBuffer: ce, uniformValues: ge, tile: me } = N.state, Ee = N.segments;
          l.terrain && l.terrain.setupElevationDraw(me, K, L), l.prepareDrawProgram(b, K, me.tileID.toUnwrapped()), K.draw(b, M.TRIANGLES, P, F, j, s.CullFaceMode.disabled, ge, o.id, le, ce, Ee, o.paint, S.zoom, X, [ue]);
        }
      }, heatmap: function(l, r, o, u) {
        if (o.paint.get("heatmap-opacity") !== 0) if (l.renderPass === "offscreen") {
          const d = l.context, f = d.gl, g = s.StencilMode.disabled, x = new s.ColorMode([f.ONE, f.ONE], s.Color.transparent, [!0, !0, !0, !0]);
          (function(j, $, G, Z) {
            const L = j.gl, N = $.width * Z, X = $.height * Z;
            j.activeTexture.set(L.TEXTURE1), j.viewport.set([0, 0, N, X]);
            let K = G.heatmapFbo;
            if (!K || K && (K.width !== N || K.height !== X)) {
              K && K.destroy();
              const le = L.createTexture();
              L.bindTexture(L.TEXTURE_2D, le), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_WRAP_S, L.CLAMP_TO_EDGE), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_WRAP_T, L.CLAMP_TO_EDGE), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_MIN_FILTER, L.LINEAR), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_MAG_FILTER, L.LINEAR), K = G.heatmapFbo = j.createFramebuffer(N, X, !1), function(ue, ce, ge, me, Ee, Ge) {
                const be = ue.gl;
                be.texImage2D(be.TEXTURE_2D, 0, ue.isWebGL2 && ue.extRenderToTextureHalfFloat ? be.RGBA16F : be.RGBA, Ee, Ge, 0, be.RGBA, ue.extRenderToTextureHalfFloat ? ue.isWebGL2 ? be.HALF_FLOAT : ue.extTextureHalfFloat.HALF_FLOAT_OES : be.UNSIGNED_BYTE, null), me.colorAttachment.set(ge);
              }(j, 0, le, K, N, X);
            } else L.bindTexture(L.TEXTURE_2D, K.colorAttachment.get()), j.bindFramebuffer.set(K.framebuffer);
          })(d, l, o, l.transform.projection.name === "globe" ? 0.5 : 0.25), d.clear({ color: s.Color.transparent });
          const b = l.transform, M = b.projection.name === "globe", S = M ? ["PROJECTION_GLOBE_VIEW"] : null, P = M ? s.CullFaceMode.frontCCW : s.CullFaceMode.disabled, F = [s.mercatorXfromLng(b.center.lng), s.mercatorYfromLat(b.center.lat)];
          for (let j = 0; j < u.length; j++) {
            const $ = u[j];
            if (r.hasRenderableParent($)) continue;
            const G = r.getTile($), Z = G.getBucket(o);
            if (!Z || Z.projection.name !== b.projection.name) continue;
            const L = Z.programConfigurations.get(o.id), N = l.useProgram("heatmap", L, S), { zoom: X } = l.transform;
            l.terrain && l.terrain.setupElevationDraw(G, N), l.prepareDrawProgram(d, N, $.toUnwrapped());
            const K = b.projection.createInversionMatrix(b, $.canonical);
            N.draw(d, f.TRIANGLES, s.DepthMode.disabled, g, x, P, Oo(l, $, G, K, F, X, o.paint.get("heatmap-intensity")), o.id, Z.layoutVertexBuffer, Z.indexBuffer, Z.segments, o.paint, l.transform.zoom, L, M ? [Z.globeExtVertexBuffer] : null);
          }
          d.viewport.set([0, 0, l.width, l.height]);
        } else l.renderPass === "translucent" && (l.context.setColorMode(l.colorModeForRenderPass()), function(d, f) {
          const g = d.context, x = g.gl, b = f.heatmapFbo;
          if (!b) return;
          g.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, b.colorAttachment.get()), g.activeTexture.set(x.TEXTURE1);
          let M = f.colorRampTexture;
          M || (M = f.colorRampTexture = new s.Texture(g, f.colorRamp, x.RGBA)), M.bind(x.LINEAR, x.CLAMP_TO_EDGE), d.useProgram("heatmapTexture").draw(g, x.TRIANGLES, s.DepthMode.disabled, s.StencilMode.disabled, d.colorModeForRenderPass(), s.CullFaceMode.disabled, ((S, P, F, j) => ({ u_image: 0, u_color_ramp: 1, u_opacity: P.paint.get("heatmap-opacity") }))(0, f), f.id, d.viewportBuffer, d.quadTriangleIndexBuffer, d.viewportSegments, f.paint, d.transform.zoom);
        }(l, o));
      }, line: function(l, r, o, u) {
        if (l.renderPass !== "translucent") return;
        const d = o.paint.get("line-opacity"), f = o.paint.get("line-width");
        if (d.constantOr(1) === 0 || f.constantOr(1) === 0) return;
        const g = l.depthModeForSublayer(0, s.DepthMode.ReadOnly), x = l.colorModeForRenderPass(), b = l.terrain && l.terrain.renderingToTexture ? 1 : s.exported.devicePixelRatio, M = o.paint.get("line-dasharray"), S = M.constantOr(1), P = o.layout.get("line-cap"), F = o.paint.get("line-pattern"), j = F.constantOr(1), $ = o.paint.get("line-gradient"), G = j ? "linePattern" : "line", Z = l.context, L = Z.gl, N = ((K) => {
          const le = [];
          cs(K) && le.push("RENDER_LINE_DASH"), K.paint.get("line-gradient") && le.push("RENDER_LINE_GRADIENT");
          const ue = K.paint.get("line-trim-offset");
          ue[0] === 0 && ue[1] === 0 || le.push("RENDER_LINE_TRIM_OFFSET");
          const ce = K.paint.get("line-pattern").constantOr(1), ge = K.paint.get("line-opacity").constantOr(1) !== 1;
          return !ce && ge && le.push("RENDER_LINE_ALPHA_DISCARD"), le;
        })(o);
        let X = N.includes("RENDER_LINE_ALPHA_DISCARD");
        l.terrain && l.terrain.clipOrMaskOverlapStencilType() && (X = !1);
        for (const K of u) {
          const le = r.getTile(K);
          if (j && !le.patternsLoaded()) continue;
          const ue = le.getBucket(o);
          if (!ue) continue;
          l.prepareDrawTile();
          const ce = ue.programConfigurations.get(o.id), ge = l.useProgram(G, ce, N), me = F.constantOr(null);
          if (me && le.imageAtlas) {
            const Re = le.imageAtlas.patternPositions[me.toString()];
            Re && ce.setConstantPatternPositions(Re);
          }
          const Ee = M.constantOr(null), Ge = P.constantOr(null);
          if (!j && Ee && Ge && le.lineAtlas) {
            const Re = le.lineAtlas.getDash(Ee, Ge);
            Re && ce.setConstantPatternPositions(Re);
          }
          let [be, Oe] = o.paint.get("line-trim-offset");
          (Ge === "round" || Ge === "square") && be !== Oe && (be === 0 && (be -= 1), Oe === 1 && (Oe += 1));
          const Ce = l.terrain ? K.projMatrix : null, Ve = j ? on(l, le, o, Ce, b) : pc(l, le, o, Ce, ue.lineClipsArray.length, b, [be, Oe]);
          if ($) {
            const Re = ue.gradients[o.id];
            let We = Re.texture;
            if (o.gradientVersion !== Re.version) {
              let Ne = 256;
              if (o.stepInterpolant) {
                const He = r.getSource().maxzoom, wt = K.canonical.z === He ? Math.ceil(1 << l.transform.maxZoom - K.canonical.z) : 1;
                Ne = s.clamp(s.nextPowerOfTwo(ue.maxLineLength / s.EXTENT * 1024 * wt), 256, Z.maxTextureSize);
              }
              Re.gradient = s.renderColorRamp({ expression: o.gradientExpression(), evaluationKey: "lineProgress", resolution: Ne, image: Re.gradient || void 0, clips: ue.lineClipsArray }), Re.texture ? Re.texture.update(Re.gradient) : Re.texture = new s.Texture(Z, Re.gradient, L.RGBA), Re.version = o.gradientVersion, We = Re.texture;
            }
            Z.activeTexture.set(L.TEXTURE1), We.bind(o.stepInterpolant ? L.NEAREST : L.LINEAR, L.CLAMP_TO_EDGE);
          }
          S && (Z.activeTexture.set(L.TEXTURE0), le.lineAtlasTexture.bind(L.LINEAR, L.REPEAT), ce.updatePaintBuffers()), j && (Z.activeTexture.set(L.TEXTURE0), le.imageAtlasTexture.bind(L.LINEAR, L.CLAMP_TO_EDGE), ce.updatePaintBuffers()), l.prepareDrawProgram(Z, ge, K.toUnwrapped());
          const Te = (Re) => {
            ge.draw(Z, L.TRIANGLES, g, Re, x, s.CullFaceMode.disabled, Ve, o.id, ue.layoutVertexBuffer, ue.indexBuffer, ue.segments, o.paint, l.transform.zoom, ce, [ue.layoutVertexBuffer2]);
          };
          if (X) {
            const Re = l.stencilModeForClipping(K).ref;
            Re === 0 && l.terrain && Z.clear({ stencil: 0 });
            const We = { func: L.EQUAL, mask: 255 };
            Ve.u_alpha_discard_threshold = 0.8, Te(new s.StencilMode(We, Re, 255, L.KEEP, L.KEEP, L.INVERT)), Ve.u_alpha_discard_threshold = 0, Te(new s.StencilMode(We, Re, 255, L.KEEP, L.KEEP, L.KEEP));
          } else Te(l.stencilModeForClipping(K));
        }
        X && (l.resetStencilClippingMasks(), l.terrain && Z.clear({ stencil: 0 }));
      }, fill: function(l, r, o, u) {
        const d = o.paint.get("fill-color"), f = o.paint.get("fill-opacity");
        if (f.constantOr(1) === 0) return;
        const g = l.colorModeForRenderPass(), x = o.paint.get("fill-pattern"), b = l.opaquePassEnabledForLayer() && !x.constantOr(1) && d.constantOr(s.Color.transparent).a === 1 && f.constantOr(0) === 1 ? "opaque" : "translucent";
        if (l.renderPass === b) {
          const M = l.depthModeForSublayer(1, l.renderPass === "opaque" ? s.DepthMode.ReadWrite : s.DepthMode.ReadOnly);
          sn(l, r, o, u, M, g, !1);
        }
        if (l.renderPass === "translucent" && o.paint.get("fill-antialias")) {
          const M = l.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, s.DepthMode.ReadOnly);
          sn(l, r, o, u, M, g, !0);
        }
      }, "fill-extrusion": function(l, r, o, u) {
        const d = o.paint.get("fill-extrusion-opacity");
        if (d !== 0 && l.renderPass === "translucent") {
          const f = new s.DepthMode(l.context.gl.LEQUAL, s.DepthMode.ReadWrite, l.depthRangeFor3D);
          if (d !== 1 || o.paint.get("fill-extrusion-pattern").constantOr(1)) Ki(l, r, o, u, f, s.StencilMode.disabled, s.ColorMode.disabled), Ki(l, r, o, u, f, l.stencilModeFor3D(), l.colorModeForRenderPass()), l.resetStencilClippingMasks();
          else {
            const g = l.colorModeForRenderPass();
            Ki(l, r, o, u, f, s.StencilMode.disabled, g);
          }
        }
      }, hillshade: function(l, r, o, u) {
        if (l.renderPass !== "offscreen" && l.renderPass !== "translucent") return;
        const d = l.context, f = l.depthModeForSublayer(0, s.DepthMode.ReadOnly), g = l.colorModeForRenderPass(), x = l.terrain && l.terrain.renderingToTexture, [b, M] = l.renderPass !== "translucent" || x ? [{}, u] : l.stencilConfigForOverlap(u);
        for (const S of M) {
          const P = r.getTile(S);
          if (P.needsHillshadePrepare && l.renderPass === "offscreen") bl(l, P, o, f, s.StencilMode.disabled, g);
          else if (l.renderPass === "translucent") {
            const F = x && l.terrain ? l.terrain.stencilModeForRTTOverlap(S) : b[S.overscaledZ];
            fo(l, S, P, o, f, F, g);
          }
        }
        d.viewport.set([0, 0, l.width, l.height]), l.resetStencilClippingMasks();
      }, raster: function(l, r, o, u, d, f) {
        if (l.renderPass !== "translucent" || o.paint.get("raster-opacity") === 0 || !u.length) return;
        const g = l.context, x = g.gl, b = r.getSource(), M = l.useProgram("raster"), S = l.colorModeForRenderPass(), P = l.terrain && l.terrain.renderingToTexture, [F, j] = b instanceof Lt || P ? [{}, u] : l.stencilConfigForOverlap(u), $ = j[j.length - 1].overscaledZ, G = !l.options.moving;
        for (const Z of j) {
          const L = P ? s.DepthMode.disabled : l.depthModeForSublayer(Z.overscaledZ - $, o.paint.get("raster-opacity") === 1 ? s.DepthMode.ReadWrite : s.DepthMode.ReadOnly, x.LESS), N = Z.toUnwrapped(), X = r.getTile(Z);
          if (P && (!X || !X.hasData())) continue;
          const K = P ? Z.projMatrix : l.transform.calculateProjMatrix(N, G), le = l.terrain && P ? l.terrain.stencilModeForRTTOverlap(Z) : F[Z.overscaledZ], ue = f ? 0 : o.paint.get("raster-fade-duration");
          X.registerFadeDuration(ue);
          const ce = r.findLoadedParent(Z, 0), ge = Oa(X, ce, r, l.transform, ue);
          let me, Ee;
          l.terrain && l.terrain.prepareDrawTile();
          const Ge = o.paint.get("raster-resampling") === "nearest" ? x.NEAREST : x.LINEAR;
          g.activeTexture.set(x.TEXTURE0), X.texture.bind(Ge, x.CLAMP_TO_EDGE), g.activeTexture.set(x.TEXTURE1), ce ? (ce.texture.bind(Ge, x.CLAMP_TO_EDGE), me = Math.pow(2, ce.tileID.overscaledZ - X.tileID.overscaledZ), Ee = [X.tileID.canonical.x * me % 1, X.tileID.canonical.y * me % 1]) : X.texture.bind(Ge, x.CLAMP_TO_EDGE), X.texture.useMipmap && g.extTextureFilterAnisotropic && l.transform.pitch > 20 && x.texParameterf(x.TEXTURE_2D, g.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, g.extTextureFilterAnisotropicMax);
          const be = Na(K, Ee || [0, 0], me || 1, ge, o, b instanceof Lt ? b.perspectiveTransform : [0, 0]);
          if (l.prepareDrawProgram(g, M, N), b instanceof Lt) b.boundsBuffer && b.boundsSegments && M.draw(g, x.TRIANGLES, L, s.StencilMode.disabled, S, s.CullFaceMode.disabled, be, o.id, b.boundsBuffer, l.quadTriangleIndexBuffer, b.boundsSegments);
          else {
            const { tileBoundsBuffer: Oe, tileBoundsIndexBuffer: Ce, tileBoundsSegments: Ve } = l.getTileBoundsBuffers(X);
            M.draw(g, x.TRIANGLES, L, le, S, s.CullFaceMode.disabled, be, o.id, Oe, Ce, Ve);
          }
        }
        l.resetStencilClippingMasks();
      }, background: function(l, r, o, u) {
        const d = o.paint.get("background-color"), f = o.paint.get("background-opacity");
        if (f === 0) return;
        const g = l.context, x = g.gl, b = l.transform, M = b.tileSize, S = o.paint.get("background-pattern");
        if (l.isPatternMissing(S)) return;
        const P = !S && d.a === 1 && f === 1 && l.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (l.renderPass !== P) return;
        const F = s.StencilMode.disabled, j = l.depthModeForSublayer(0, P === "opaque" ? s.DepthMode.ReadWrite : s.DepthMode.ReadOnly), $ = l.colorModeForRenderPass(), G = l.useProgram(S ? "backgroundPattern" : "background");
        let Z, L = u;
        L || (Z = l.getBackgroundTiles(), L = Object.values(Z).map((N) => N.tileID)), S && (g.activeTexture.set(x.TEXTURE0), l.imageManager.bind(l.context));
        for (const N of L) {
          const X = N.toUnwrapped(), K = u ? N.projMatrix : l.transform.calculateProjMatrix(X);
          l.prepareDrawTile();
          const le = r ? r.getTile(N) : Z ? Z[N.key] : new s.Tile(N, M, b.zoom, l), ue = S ? Sl(K, f, l, S, { tileID: N, tileSize: M }) : Bo(K, f, d);
          l.prepareDrawProgram(g, G, X);
          const { tileBoundsBuffer: ce, tileBoundsIndexBuffer: ge, tileBoundsSegments: me } = l.getTileBoundsBuffers(le);
          G.draw(g, x.TRIANGLES, j, F, $, s.CullFaceMode.disabled, ue, o.id, ce, ge, me);
        }
      }, sky: function(l, r, o) {
        const u = l.transform, d = u.projection.name === "mercator" || u.projection.name === "globe" ? 1 : s.smoothstep(7, 8, u.zoom), f = o.paint.get("sky-opacity") * d;
        if (f === 0) return;
        const g = l.context, x = o.paint.get("sky-type"), b = new s.DepthMode(g.gl.LEQUAL, s.DepthMode.ReadOnly, [0, 1]), M = l.frameCounter / 1e3 % 1;
        x === "atmosphere" ? l.renderPass === "offscreen" ? o.needsSkyboxCapture(l) && (function(S, P, F, j) {
          const $ = S.context, G = $.gl;
          let Z = P.skyboxFbo;
          if (!Z) {
            Z = P.skyboxFbo = $.createFramebuffer(32, 32, !1), P.skyboxGeometry = new _i($), P.skyboxTexture = $.gl.createTexture(), G.bindTexture(G.TEXTURE_CUBE_MAP, P.skyboxTexture), G.texParameteri(G.TEXTURE_CUBE_MAP, G.TEXTURE_WRAP_S, G.CLAMP_TO_EDGE), G.texParameteri(G.TEXTURE_CUBE_MAP, G.TEXTURE_WRAP_T, G.CLAMP_TO_EDGE), G.texParameteri(G.TEXTURE_CUBE_MAP, G.TEXTURE_MIN_FILTER, G.LINEAR), G.texParameteri(G.TEXTURE_CUBE_MAP, G.TEXTURE_MAG_FILTER, G.LINEAR);
            for (let K = 0; K < 6; ++K) G.texImage2D(G.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, G.RGBA, 32, 32, 0, G.RGBA, G.UNSIGNED_BYTE, null);
          }
          $.bindFramebuffer.set(Z.framebuffer), $.viewport.set([0, 0, 32, 32]);
          const L = P.getCenter(S, !0), N = S.useProgram("skyboxCapture"), X = new Float64Array(16);
          s.identity(X), s.rotateY(X, X, 0.5 * -Math.PI), Lr($, P, N, X, L, 0), s.identity(X), s.rotateY(X, X, 0.5 * Math.PI), Lr($, P, N, X, L, 1), s.identity(X), s.rotateX(X, X, 0.5 * -Math.PI), Lr($, P, N, X, L, 2), s.identity(X), s.rotateX(X, X, 0.5 * Math.PI), Lr($, P, N, X, L, 3), s.identity(X), Lr($, P, N, X, L, 4), s.identity(X), s.rotateY(X, X, Math.PI), Lr($, P, N, X, L, 5), $.viewport.set([0, 0, S.width, S.height]);
        }(l, o), o.markSkyboxValid(l)) : l.renderPass === "sky" && function(S, P, F, j, $) {
          const G = S.context, Z = G.gl, L = S.transform, N = S.useProgram("skybox");
          G.activeTexture.set(Z.TEXTURE0), Z.bindTexture(Z.TEXTURE_CUBE_MAP, P.skyboxTexture);
          const X = /* @__PURE__ */ ((K, le, ue, ce, ge) => ({ u_matrix: K, u_sun_direction: le, u_cubemap: 0, u_opacity: ce, u_temporal_offset: ge }))(L.skyboxMatrix, P.getCenter(S, !1), 0, j, $);
          S.prepareDrawProgram(G, N), N.draw(G, Z.TRIANGLES, F, s.StencilMode.disabled, S.colorModeForRenderPass(), s.CullFaceMode.backCW, X, "skybox", P.skyboxGeometry.vertexBuffer, P.skyboxGeometry.indexBuffer, P.skyboxGeometry.segment);
        }(l, o, b, f, M) : x === "gradient" && l.renderPass === "sky" && function(S, P, F, j, $) {
          const G = S.context, Z = G.gl, L = S.transform, N = S.useProgram("skyboxGradient");
          P.skyboxGeometry || (P.skyboxGeometry = new _i(G)), G.activeTexture.set(Z.TEXTURE0);
          let X = P.colorRampTexture;
          X || (X = P.colorRampTexture = new s.Texture(G, P.colorRamp, Z.RGBA)), X.bind(Z.LINEAR, Z.CLAMP_TO_EDGE);
          const K = ((le, ue, ce, ge, me) => ({ u_matrix: le, u_color_ramp: 0, u_center_direction: ue, u_radius: s.degToRad(ce), u_opacity: ge, u_temporal_offset: me }))(L.skyboxMatrix, P.getCenter(S, !1), P.paint.get("sky-gradient-radius"), j, $);
          S.prepareDrawProgram(G, N), N.draw(G, Z.TRIANGLES, F, s.StencilMode.disabled, S.colorModeForRenderPass(), s.CullFaceMode.backCW, K, "skyboxGradient", P.skyboxGeometry.vertexBuffer, P.skyboxGeometry.indexBuffer, P.skyboxGeometry.segment);
        }(l, o, b, f, M);
      }, debug: function(l, r, o) {
        for (let u = 0; u < o.length; u++) sa(l, r, o[u]);
      }, custom: function(l, r, o, u) {
        const d = l.context, f = o.implementation;
        if (!l.transform.projection.unsupportedLayers || !l.transform.projection.unsupportedLayers.includes("custom") || l.terrain && (l.terrain.renderingToTexture || l.renderPass === "offscreen") && o.isLayerDraped()) {
          if (l.renderPass === "offscreen") {
            const g = f.prerender;
            if (g) {
              if (l.setCustomLayerDefaults(), d.setColorMode(l.colorModeForRenderPass()), l.transform.projection.name === "globe") {
                const x = l.transform.pointMerc;
                g.call(f, d.gl, l.transform.customLayerMatrix(), l.transform.getProjection(), l.transform.globeToMercatorMatrix(), s.globeToMercatorTransition(l.transform.zoom), [x.x, x.y], l.transform.pixelsPerMeterRatio);
              } else g.call(f, d.gl, l.transform.customLayerMatrix());
              d.setDirty(), l.setBaseState();
            }
          } else if (l.renderPass === "translucent") {
            if (l.terrain && l.terrain.renderingToTexture) {
              const x = f.renderToTile;
              if (x) {
                const b = u[0].canonical, M = new s.MercatorCoordinate(b.x + u[0].wrap * (1 << b.z), b.y, b.z);
                d.setDepthMode(s.DepthMode.disabled), d.setStencilMode(s.StencilMode.disabled), d.setColorMode(l.colorModeForRenderPass()), l.setCustomLayerDefaults(), x.call(f, d.gl, M), d.setDirty(), l.setBaseState();
              }
              return;
            }
            l.setCustomLayerDefaults(), d.setColorMode(l.colorModeForRenderPass()), d.setStencilMode(s.StencilMode.disabled);
            const g = f.renderingMode === "3d" ? new s.DepthMode(l.context.gl.LEQUAL, s.DepthMode.ReadWrite, l.depthRangeFor3D) : l.depthModeForSublayer(0, s.DepthMode.ReadOnly);
            if (d.setDepthMode(g), l.transform.projection.name === "globe") {
              const x = l.transform.pointMerc;
              f.render(d.gl, l.transform.customLayerMatrix(), l.transform.getProjection(), l.transform.globeToMercatorMatrix(), s.globeToMercatorTransition(l.transform.zoom), [x.x, x.y], l.transform.pixelsPerMeterRatio);
            } else f.render(d.gl, l.transform.customLayerMatrix());
            d.setDirty(), l.setBaseState(), d.bindFramebuffer.set(null);
          }
        } else s.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
      } };
      class Nr {
        constructor(r, o, u = !1) {
          this.context = new Xe(r, u), this.transform = o, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = s.SourceCache.maxUnderzooming + s.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
        }
        updateTerrain(r, o) {
          const u = !!r && !!r.terrain && this.transform.projection.supportsTerrain;
          if (!(u || this._terrain && this._terrain.enabled)) return;
          this._terrain || (this._terrain = new Ls(this, r));
          const d = this._terrain;
          this.transform.elevation = u ? d : null, d.update(r, this.transform, o);
        }
        _updateFog(r) {
          const o = r.fog;
          if (!o || this.transform.projection.name === "globe" || o.getOpacity(this.transform.pitch) < 1 || o.properties.get("horizon-blend") < 0.03) return void (this.transform.fogCullDistSq = null);
          const [u, d] = o.getFovAdjustedRange(this.transform._fov);
          if (u > d) return void (this.transform.fogCullDistSq = null);
          const f = u + 0.78 * (d - u);
          this.transform.fogCullDistSq = f * f;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
        }
        resize(r, o) {
          if (this.width = r * s.exported.devicePixelRatio, this.height = o * s.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const u of this.style.order) this.style._layers[u].resize();
        }
        setup() {
          const r = this.context, o = new s.StructArrayLayout2i4();
          o.emplaceBack(0, 0), o.emplaceBack(s.EXTENT, 0), o.emplaceBack(0, s.EXTENT), o.emplaceBack(s.EXTENT, s.EXTENT), this.tileExtentBuffer = r.createVertexBuffer(o, s.posAttributes.members), this.tileExtentSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2);
          const u = new s.StructArrayLayout2i4();
          u.emplaceBack(0, 0), u.emplaceBack(s.EXTENT, 0), u.emplaceBack(0, s.EXTENT), u.emplaceBack(s.EXTENT, s.EXTENT), this.debugBuffer = r.createVertexBuffer(u, s.posAttributes.members), this.debugSegments = s.SegmentVector.simpleSegment(0, 0, 4, 5);
          const d = new s.StructArrayLayout2i4();
          d.emplaceBack(-1, -1), d.emplaceBack(1, -1), d.emplaceBack(-1, 1), d.emplaceBack(1, 1), this.viewportBuffer = r.createVertexBuffer(d, s.posAttributes.members), this.viewportSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2);
          const f = new s.StructArrayLayout4i8();
          f.emplaceBack(0, 0, 0, 0), f.emplaceBack(s.EXTENT, 0, s.EXTENT, 0), f.emplaceBack(0, s.EXTENT, 0, s.EXTENT), f.emplaceBack(s.EXTENT, s.EXTENT, s.EXTENT, s.EXTENT), this.mercatorBoundsBuffer = r.createVertexBuffer(f, s.boundsAttributes.members), this.mercatorBoundsSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2);
          const g = new s.StructArrayLayout3ui6();
          g.emplaceBack(0, 1, 2), g.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = r.createIndexBuffer(g);
          const x = new s.StructArrayLayout1ui2();
          for (const M of [0, 1, 3, 2, 0]) x.emplaceBack(M);
          this.debugIndexBuffer = r.createIndexBuffer(x), this.emptyTexture = new s.Texture(r, new s.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), r.gl.RGBA), this.identityMat = s.create();
          const b = this.context.gl;
          this.stencilClearMode = new s.StencilMode({ func: b.ALWAYS, mask: 0 }, 0, 255, b.ZERO, b.ZERO, b.ZERO), this.loadTimeStamps.push(s.window.performance.now()), this.atmosphereBuffer = new aa(this.context);
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(r) {
          return r._makeTileBoundsBuffers(this.context, this.transform.projection), r._tileBoundsBuffer ? { tileBoundsBuffer: r._tileBoundsBuffer, tileBoundsIndexBuffer: r._tileBoundsIndexBuffer, tileBoundsSegments: r._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const r = this.context, o = r.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(r, o.TRIANGLES, s.DepthMode.disabled, this.stencilClearMode, s.ColorMode.disabled, s.CullFaceMode.disabled, Is(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(r, o, u) {
          if (!o || this.currentStencilSource === o.id || !r.isTileClipped() || !u || u.length === 0) return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let x = !1;
            for (const b of u) if (this._tileClippingMaskIDs[b.key] === void 0) {
              x = !0;
              break;
            }
            if (!x) return;
          }
          this.currentStencilSource = o.id;
          const d = this.context, f = d.gl;
          this.nextStencilID + u.length > 256 && this.clearStencil(), d.setColorMode(s.ColorMode.disabled), d.setDepthMode(s.DepthMode.disabled);
          const g = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const x of u) {
            const b = o.getTile(x), M = this._tileClippingMaskIDs[x.key] = this.nextStencilID++, { tileBoundsBuffer: S, tileBoundsIndexBuffer: P, tileBoundsSegments: F } = this.getTileBoundsBuffers(b);
            g.draw(d, f.TRIANGLES, s.DepthMode.disabled, new s.StencilMode({ func: f.ALWAYS, mask: 0 }, M, 255, f.KEEP, f.KEEP, f.REPLACE), s.ColorMode.disabled, s.CullFaceMode.disabled, Is(x.projMatrix), "$clipping", S, P, F);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const r = this.nextStencilID++, o = this.context.gl;
          return new s.StencilMode({ func: o.NOTEQUAL, mask: 255 }, r, 255, o.KEEP, o.KEEP, o.REPLACE);
        }
        stencilModeForClipping(r) {
          if (this.terrain) return this.terrain.stencilModeForRTTOverlap(r);
          const o = this.context.gl;
          return new s.StencilMode({ func: o.EQUAL, mask: 255 }, this._tileClippingMaskIDs[r.key], 0, o.KEEP, o.KEEP, o.REPLACE);
        }
        stencilConfigForOverlap(r) {
          const o = this.context.gl, u = r.sort((g, x) => x.overscaledZ - g.overscaledZ), d = u[u.length - 1].overscaledZ, f = u[0].overscaledZ - d + 1;
          if (f > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + f > 256 && this.clearStencil();
            const g = {};
            for (let x = 0; x < f; x++) g[x + d] = new s.StencilMode({ func: o.GEQUAL, mask: 255 }, x + this.nextStencilID, 255, o.KEEP, o.KEEP, o.REPLACE);
            return this.nextStencilID += f, [g, u];
          }
          return [{ [d]: s.StencilMode.disabled }, u];
        }
        colorModeForRenderPass() {
          const r = this.context.gl;
          return this._showOverdrawInspector ? new s.ColorMode([r.CONSTANT_COLOR, r.ONE], new s.Color(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? s.ColorMode.unblended : s.ColorMode.alphaBlended;
        }
        depthModeForSublayer(r, o, u) {
          if (!this.opaquePassEnabledForLayer()) return s.DepthMode.disabled;
          const d = 1 - ((1 + this.currentLayer) * this.numSublayers + r) * this.depthEpsilon;
          return new s.DepthMode(u || this.context.gl.LEQUAL, o, [d, d]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(r, o) {
          this.style = r, this.options = o, this.imageManager = r.imageManager, this.glyphManager = r.glyphManager, this.symbolFadeChange = r.placement.symbolFadeChange(s.exported.now()), this.imageManager.beginFrame();
          const u = this.style.order, d = this.style._sourceCaches;
          for (const M in d) {
            const S = d[M];
            S.used && S.prepare(this.context);
          }
          const f = {}, g = {}, x = {};
          for (const M in d) {
            const S = d[M];
            f[M] = S.getVisibleCoordinates(), g[M] = f[M].slice().reverse(), x[M] = S.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let M = 0; M < u.length; M++) if (this.style._layers[u[M]].is3D()) {
            this.opaquePassCutoff = M;
            break;
          }
          if (this.terrain && (this.terrain.updateTileBinding(x), this.opaquePassCutoff = 0), this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new s.GlobeSharedBuffers(this.context)), !s.isMapAuthenticated(this.context.gl)) return;
          this.renderPass = "offscreen";
          for (const M of u) {
            const S = this.style._layers[M], P = r._getLayerSourceCache(S);
            if (!S.hasOffscreenPass() || S.isHidden(this.transform.zoom)) continue;
            const F = P ? g[P.id] : void 0;
            (S.type === "custom" || S.isSky() || F && F.length) && this.renderLayer(this, P, S, F);
          }
          this.depthRangeFor3D = [0, 1 - (r.order.length + 2) * this.numSublayers * this.depthEpsilon];
          const b = this.terrain;
          if (b && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && b.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: o.showOverdrawInspector ? s.Color.black : s.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = o.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for (this.currentLayer = u.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const M = this.style._layers[u[this.currentLayer]], S = r._getLayerSourceCache(M);
            if (M.isSky()) continue;
            const P = S ? g[S.id] : void 0;
            this._renderTileClippingMasks(M, S, P), this.renderLayer(this, S, M, P);
          }
          if (this.style.fog && this.transform.projection.supportsFog && function(M, S) {
            const P = M.context, F = P.gl, j = M.transform, $ = new s.DepthMode(F.LEQUAL, s.DepthMode.ReadOnly, [0, 1]), G = M.useProgram("globeAtmosphere", null, j.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]), Z = s.globeToMercatorTransition(j.zoom), L = S.properties.get("color").toArray01(), N = S.properties.get("high-color").toArray01(), X = S.properties.get("space-color").toArray01PremultipliedAlpha(), K = s.identity$1([]);
            s.rotateY$1(K, K, -s.degToRad(j._center.lng)), s.rotateX$1(K, K, s.degToRad(j._center.lat)), s.rotateZ$1(K, K, j.angle), s.rotateX$1(K, K, -j._pitch);
            const le = s.fromQuat(new Float32Array(16), K), ue = s.mapValue(S.properties.get("star-intensity"), 0, 1, 0, 0.25), ce = 5e-4, ge = s.mapValue(S.properties.get("horizon-blend"), 0, 1, ce, 0.25), me = s.globeUseCustomAntiAliasing(M, P, j) && ge === ce ? j.worldSize / (2 * Math.PI * 1.025) - 1 : j.globeRadius, Ee = M.frameCounter / 1e3 % 1, Ge = s.length(j.globeCenterInViewSpace), be = Math.sqrt(Math.pow(Ge, 2) - Math.pow(me, 2)), Oe = Math.acos(be / Ge), Ce = ((Te, Re, We, Ne, He, wt, Dt, gt, Ct, ti, Yt, vt, vi, Ti) => ({ u_frustum_tl: Te, u_frustum_tr: Re, u_frustum_br: We, u_frustum_bl: Ne, u_horizon: He, u_transition: wt, u_fadeout_range: Dt, u_color: gt, u_high_color: Ct, u_space_color: ti, u_star_intensity: Yt, u_star_size: 5 * s.exported.devicePixelRatio, u_star_density: 0, u_temporal_offset: vt, u_horizon_angle: vi, u_rotation_matrix: Ti }))(j.frustumCorners.TL, j.frustumCorners.TR, j.frustumCorners.BR, j.frustumCorners.BL, j.frustumCorners.horizon, Z, ge, L, N, X, ue, Ee, Oe, le);
            M.prepareDrawProgram(P, G);
            const Ve = M.atmosphereBuffer;
            Ve && G.draw(P, F.TRIANGLES, $, s.StencilMode.disabled, s.ColorMode.alphaBlended, s.CullFaceMode.backCW, Ce, "skybox", Ve.vertexBuffer, Ve.indexBuffer, Ve.segments);
          }(this, this.style.fog), this.renderPass = "sky", (s.globeToMercatorTransition(this.transform.zoom) > 0 || this.transform.projection.name !== "globe") && this.transform.isHorizonVisible()) for (this.currentLayer = 0; this.currentLayer < u.length; this.currentLayer++) {
            const M = this.style._layers[u[this.currentLayer]], S = r._getLayerSourceCache(M);
            M.isSky() && this.renderLayer(this, S, M, S ? g[S.id] : void 0);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < u.length; ) {
            const M = this.style._layers[u[this.currentLayer]], S = r._getLayerSourceCache(M);
            if (M.isSky()) {
              ++this.currentLayer;
              continue;
            }
            if (this.terrain && this.style.isLayerDraped(M)) {
              if (M.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = this.terrain.renderBatch(this.currentLayer);
              continue;
            }
            const P = S ? (M.type === "symbol" ? x : g)[S.id] : void 0;
            this._renderTileClippingMasks(M, S, S ? f[S.id] : void 0), this.renderLayer(this, S, M, P), ++this.currentLayer;
          }
          if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
            let M = null;
            s.values(this.style._layers).forEach((S) => {
              const P = r._getLayerSourceCache(S);
              P && !S.isHidden(this.transform.zoom) && (!M || M.getSource().maxzoom < P.getSource().maxzoom) && (M = P);
            }), M && this.options.showTileBoundaries && xr.debug(this, M, M.getVisibleCoordinates());
          }
          this.options.showPadding && function(M) {
            const S = M.transform.padding;
            Fo(M, M.transform.height - (S.top || 0), 3, Ir), Fo(M, S.bottom || 0, 3, Jn), vo(M, S.left || 0, 3, Pr), vo(M, M.transform.width - (S.right || 0), 3, Yn);
            const P = M.transform.centerPoint;
            (function(F, j, $, G) {
              Uo(F, j - 1, $ - 10, 2, 20, G), Uo(F, j - 10, $ - 1, 20, 2, G);
            })(M, P.x, M.transform.height - P.y, hs);
          }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(s.window.performance.now()), this.saveCanvasCopy());
        }
        renderLayer(r, o, u, d) {
          u.isHidden(this.transform.zoom) || (u.type === "background" || u.type === "sky" || u.type === "custom" || d && d.length) && (this.id = u.id, this.gpuTimingStart(u), (!r.transform.projection.unsupportedLayers || !r.transform.projection.unsupportedLayers.includes(u.type) || r.terrain && u.type === "custom") && xr[u.type](r, o, u, d, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(r) {
          if (!this.options.gpuTiming) return;
          const o = this.context.extTimerQuery;
          let u = this.gpuTimers[r.id];
          u || (u = this.gpuTimers[r.id] = { calls: 0, cpuTime: 0, query: o.createQueryEXT() }), u.calls++, o.beginQueryEXT(o.TIME_ELAPSED_EXT, u.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const r = this.context.extTimerQuery, o = r.createQueryEXT();
            this.deferredRenderGpuTimeQueries.push(o), r.beginQueryEXT(r.TIME_ELAPSED_EXT, o);
          }
        }
        gpuTimingDeferredRenderEnd() {
          if (!this.options.gpuTimingDeferredRender) return;
          const r = this.context.extTimerQuery;
          r.endQueryEXT(r.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          if (!this.options.gpuTiming) return;
          const r = this.context.extTimerQuery;
          r.endQueryEXT(r.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const r = this.gpuTimers;
          return this.gpuTimers = {}, r;
        }
        collectDeferredRenderGpuQueries() {
          const r = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], r;
        }
        queryGpuTimers(r) {
          const o = {};
          for (const u in r) {
            const d = r[u], f = this.context.extTimerQuery, g = f.getQueryObjectEXT(d.query, f.QUERY_RESULT_EXT) / 1e6;
            f.deleteQueryEXT(d.query), o[u] = g;
          }
          return o;
        }
        queryGpuTimeDeferredRender(r) {
          if (!this.options.gpuTimingDeferredRender) return 0;
          const o = this.context.extTimerQuery;
          let u = 0;
          for (const d of r) u += o.getQueryObjectEXT(d, o.QUERY_RESULT_EXT) / 1e6, o.deleteQueryEXT(d);
          return u;
        }
        translatePosMatrix(r, o, u, d, f) {
          if (!u[0] && !u[1]) return r;
          const g = f ? d === "map" ? this.transform.angle : 0 : d === "viewport" ? -this.transform.angle : 0;
          if (g) {
            const M = Math.sin(g), S = Math.cos(g);
            u = [u[0] * S - u[1] * M, u[0] * M + u[1] * S];
          }
          const x = [f ? u[0] : er(o, u[0], this.transform.zoom), f ? u[1] : er(o, u[1], this.transform.zoom), 0], b = new Float32Array(16);
          return s.translate(b, r, x), b;
        }
        saveTileTexture(r) {
          const o = this._tileTextures[r.size[0]];
          o ? o.push(r) : this._tileTextures[r.size[0]] = [r];
        }
        getTileTexture(r) {
          const o = this._tileTextures[r];
          return o && o.length > 0 ? o.pop() : null;
        }
        isPatternMissing(r) {
          return r === null || r !== void 0 && !this.imageManager.getPattern(r.toString());
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
        }
        currentGlobalDefines() {
          const r = this.terrain && this.terrain.renderingToTexture, o = this.terrain && this.terrain.exaggeration() === 0, u = this.style && this.style.fog, d = [];
          return this.terrainRenderModeElevated() && d.push("TERRAIN"), this.transform.projection.name === "globe" && d.push("GLOBE"), o && d.push("ZERO_EXAGGERATION"), u && !r && u.getOpacity(this.transform.pitch) !== 0 && d.push("FOG"), r && d.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && d.push("OVERDRAW_INSPECTOR"), d;
        }
        useProgram(r, o, u) {
          this.cache = this.cache || {};
          const d = u || [], f = this.currentGlobalDefines().concat(d), g = Kt.cacheKey(ta[r], r, f, o);
          return this.cache[g] || (this.cache[g] = new Kt(this.context, r, ta[r], o, Va[r], f)), this.cache[g];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const r = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(r.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = s.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        prepareDrawProgram(r, o, u) {
          if (this.terrain && this.terrain.renderingToTexture) return;
          const d = this.style.fog;
          if (d) {
            const f = d.getOpacity(this.transform.pitch), g = ((x, b, M, S, P, F, j, $, G, Z, L) => {
              const N = x.transform, X = b.properties.get("color").toArray01();
              X[3] = S;
              const K = x.frameCounter / 1e3 % 1;
              return { u_fog_matrix: M ? N.calculateFogTileMatrix(M) : x.identityMat, u_fog_range: b.getFovAdjustedRange(N._fov), u_fog_color: X, u_fog_horizon_blend: b.properties.get("horizon-blend"), u_fog_temporal_offset: K, u_frustum_tl: P, u_frustum_tr: F, u_frustum_br: j, u_frustum_bl: $, u_globe_pos: G, u_globe_radius: Z, u_viewport: L, u_globe_transition: s.globeToMercatorTransition(N.zoom), u_is_globe: +(N.projection.name === "globe") };
            })(this, d, u, f, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * s.exported.devicePixelRatio, this.transform.height * s.exported.devicePixelRatio]);
            o.setFogUniformValues(r, g);
          }
        }
        setTileLoadedFlag(r) {
          this.tileLoaded = r;
        }
        saveCanvasCopy() {
          const r = this.canvasCopy();
          r && (this.frameCopies.push(r), this.tileLoaded = !1);
        }
        canvasCopy() {
          const r = this.context.gl, o = r.createTexture();
          return r.bindTexture(r.TEXTURE_2D, o), r.copyTexImage2D(r.TEXTURE_2D, 0, r.RGBA, 0, 0, r.drawingBufferWidth, r.drawingBufferHeight, 0), o;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation) return !1;
          const r = this.style && this.style.fog;
          return !!r && r.getOpacity(this.transform.pitch) !== 0;
        }
        getBackgroundTiles() {
          const r = this._backgroundTiles, o = this._backgroundTiles = {}, u = this.transform.coveringTiles({ tileSize: 512 });
          for (const d of u) o[d.key] = r[d.key] || new s.Tile(d, 512, this.transform.tileZoom, this);
          return o;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
      }
      class wn {
        constructor(r = 0, o = 0, u = 0, d = 0) {
          if (isNaN(r) || r < 0 || isNaN(o) || o < 0 || isNaN(u) || u < 0 || isNaN(d) || d < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = r, this.bottom = o, this.left = u, this.right = d;
        }
        interpolate(r, o, u) {
          return o.top != null && r.top != null && (this.top = s.number(r.top, o.top, u)), o.bottom != null && r.bottom != null && (this.bottom = s.number(r.bottom, o.bottom, u)), o.left != null && r.left != null && (this.left = s.number(r.left, o.left, u)), o.right != null && r.right != null && (this.right = s.number(r.right, o.right, u)), this;
        }
        getCenter(r, o) {
          const u = s.clamp((this.left + r - this.right) / 2, 0, r), d = s.clamp((this.top + o - this.bottom) / 2, 0, o);
          return new s.Point(u, d);
        }
        equals(r) {
          return this.top === r.top && this.bottom === r.bottom && this.left === r.left && this.right === r.right;
        }
        clone() {
          return new wn(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function bo(l, r) {
        const o = s.getColumn(l, 3);
        s.fromQuat(l, r), s.setColumn(l, 3, o);
      }
      function ii(l, r) {
        const o = s.identity$1([]);
        return s.rotateZ$1(o, o, -r), s.rotateX$1(o, o, -l), o;
      }
      function Ln(l, r) {
        const o = [l[0], l[1], 0], u = [r[0], r[1], 0];
        if (s.length(o) >= 1e-15) {
          const g = s.normalize([], o);
          s.scale$2(u, g, s.dot(u, g)), r[0] = u[0], r[1] = u[1];
        }
        const d = s.cross([], r, l);
        if (s.len(d) < 1e-15) return null;
        const f = Math.atan2(-d[1], d[0]);
        return ii(Math.atan2(Math.sqrt(l[0] * l[0] + l[1] * l[1]), -l[2]), f);
      }
      class wo {
        constructor(r, o) {
          this.position = r, this.orientation = o;
        }
        get position() {
          return this._position;
        }
        set position(r) {
          if (r) {
            const o = r instanceof s.MercatorCoordinate ? r : new s.MercatorCoordinate(r[0], r[1], r[2]);
            this._renderWorldCopies && (o.x = s.wrap(o.x, 0, 1)), this._position = o;
          } else this._position = null;
        }
        lookAtPoint(r, o) {
          if (this.orientation = null, !this.position) return;
          const u = this.position, d = this._elevation ? this._elevation.getAtPointOrZero(s.MercatorCoordinate.fromLngLat(r)) : 0, f = s.MercatorCoordinate.fromLngLat(r, d), g = [f.x - u.x, f.y - u.y, f.z - u.z];
          o || (o = [0, 0, 1]), o[2] = Math.abs(o[2]), this.orientation = Ln(g, o);
        }
        setPitchBearing(r, o) {
          this.orientation = ii(s.degToRad(r), s.degToRad(-o));
        }
      }
      class Os {
        constructor(r, o) {
          this._transform = s.identity([]), this.orientation = o, this.position = r;
        }
        get mercatorPosition() {
          const r = this.position;
          return new s.MercatorCoordinate(r[0], r[1], r[2]);
        }
        get position() {
          const r = s.getColumn(this._transform, 3);
          return [r[0], r[1], r[2]];
        }
        set position(r) {
          var o;
          r && s.setColumn(this._transform, 3, [(o = r)[0], o[1], o[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(r) {
          this._orientation = r || s.identity$1([]), r && bo(this._transform, this._orientation);
        }
        getPitchBearing() {
          const r = this.forward(), o = this.right();
          return { bearing: Math.atan2(-o[1], o[0]), pitch: Math.atan2(Math.sqrt(r[0] * r[0] + r[1] * r[1]), -r[2]) };
        }
        setPitchBearing(r, o) {
          this._orientation = ii(r, o), bo(this._transform, this._orientation);
        }
        forward() {
          const r = s.getColumn(this._transform, 2);
          return [-r[0], -r[1], -r[2]];
        }
        up() {
          const r = s.getColumn(this._transform, 1);
          return [-r[0], -r[1], -r[2]];
        }
        right() {
          const r = s.getColumn(this._transform, 0);
          return [r[0], r[1], r[2]];
        }
        getCameraToWorld(r, o) {
          const u = new Float64Array(16);
          return s.invert(u, this.getWorldToCamera(r, o)), u;
        }
        getWorldToCameraPosition(r, o, u) {
          const d = this.position;
          s.scale$2(d, d, -r);
          const f = new Float64Array(16);
          return s.fromScaling(f, [u, u, u]), s.translate(f, f, d), f[10] *= o, f;
        }
        getWorldToCamera(r, o) {
          const u = new Float64Array(16), d = new Float64Array(4), f = this.position;
          return s.conjugate(d, this._orientation), s.scale$2(f, f, -r), s.fromQuat(u, d), s.translate(u, u, f), u[1] *= -1, u[5] *= -1, u[9] *= -1, u[13] *= -1, u[8] *= o, u[9] *= o, u[10] *= o, u[11] *= o, u;
        }
        getCameraToClipPerspective(r, o, u, d) {
          const f = new Float64Array(16);
          return s.perspective(f, r, o, u, d), f;
        }
        getDistanceToElevation(r, o = !1) {
          const u = r === 0 ? 0 : s.mercatorZfromAltitude(r, o ? s.latFromMercatorY(this.position[1]) : this.position[1]), d = this.forward();
          return (u - this.position[2]) / d[2];
        }
        clone() {
          return new Os([...this.position], [...this.orientation]);
        }
      }
      function Qn(l, r) {
        const o = No(l.projection, l.zoom, l.width, l.height), u = function(f, g, x, b, M) {
          const S = new s.LngLat(x.lng - 180 * ln, x.lat), P = new s.LngLat(x.lng + 180 * ln, x.lat), F = f.project(S.lng, S.lat), j = f.project(P.lng, P.lat), $ = -Math.atan2(j.y - F.y, j.x - F.x), G = s.MercatorCoordinate.fromLngLat(x);
          G.y = s.clamp(G.y, -1 + ln, 1 - ln);
          const Z = G.toLngLat(), L = f.project(Z.lng, Z.lat), N = s.MercatorCoordinate.fromLngLat(Z);
          N.x += ln;
          const X = N.toLngLat(), K = f.project(X.lng, X.lat), le = jo(K.x - L.x, K.y - L.y, $), ue = s.MercatorCoordinate.fromLngLat(Z);
          ue.y += ln;
          const ce = ue.toLngLat(), ge = f.project(ce.lng, ce.lat), me = jo(ge.x - L.x, ge.y - L.y, $), Ee = Math.abs(le.x) / Math.abs(me.y), Ge = s.identity([]);
          s.rotateZ(Ge, Ge, -$ * (1 - (M ? 0 : b)));
          const be = s.identity([]);
          return s.scale(be, be, [1, 1 - (1 - Ee) * b, 1]), be[4] = -me.x / me.y * b, s.rotateZ(be, be, $), s.multiply(be, Ge, be), be;
        }(l.projection, 0, l.center, o, r), d = la(l);
        return s.scale(u, u, [d, d, 1]), u;
      }
      function la(l) {
        const r = l.projection, o = No(l.projection, l.zoom, l.width, l.height), u = Ga(r, l.center), d = Ga(r, s.LngLat.convert(r.center));
        return Math.pow(2, u * o + (1 - o) * d);
      }
      function No(l, r, o, u, d = 1 / 0) {
        const f = l.range;
        if (!f) return 0;
        const g = Math.min(d, Math.max(o, u)), x = Math.log(g / 1024) / Math.LN2;
        return s.smoothstep(f[0] + x, f[1] + x, r);
      }
      const ln = 1 / 4e4;
      function Ga(l, r) {
        const o = s.clamp(r.lat, -s.MAX_MERCATOR_LATITUDE, s.MAX_MERCATOR_LATITUDE), u = new s.LngLat(r.lng - 180 * ln, o), d = new s.LngLat(r.lng + 180 * ln, o), f = l.project(u.lng, o), g = l.project(d.lng, o), x = s.MercatorCoordinate.fromLngLat(u), b = s.MercatorCoordinate.fromLngLat(d), M = g.x - f.x, S = g.y - f.y, P = b.x - x.x, F = b.y - x.y, j = Math.sqrt((P * P + F * F) / (M * M + S * S));
        return Math.log(j) / Math.LN2;
      }
      function jo(l, r, o) {
        const u = Math.cos(o), d = Math.sin(o);
        return { x: l * u - r * d, y: l * d + r * u };
      }
      class eo {
        constructor(r, o, u, d, f, g, x) {
          this.tileSize = 512, this._renderWorldCopies = f === void 0 || f, this._minZoom = r || 0, this._maxZoom = o || 22, this._minPitch = u ?? 0, this._maxPitch = d ?? 60, this.setProjection(g), this.setMaxBounds(x), this.width = 0, this.height = 0, this._center = new s.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new wn(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Os(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1;
        }
        clone() {
          const r = new eo(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return r._elevation = this._elevation, r._centerAltitude = this._centerAltitude, r._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, r.tileSize = this.tileSize, r.mercatorFromTransition = this.mercatorFromTransition, r.width = this.width, r.height = this.height, r.cameraElevationReference = this.cameraElevationReference, r._center = this._center, r._setZoom(this.zoom), r._seaLevelZoom = this._seaLevelZoom, r.angle = this.angle, r._fov = this._fov, r._pitch = this._pitch, r._nearZ = this._nearZ, r._farZ = this._farZ, r._averageElevation = this._averageElevation, r._unmodified = this._unmodified, r._edgeInsets = this._edgeInsets.clone(), r._camera = this._camera.clone(), r._calcMatrices(), r.freezeTileCoverage = this.freezeTileCoverage, r.frustumCorners = this.frustumCorners, r;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(r) {
          this._elevation !== r && (this._elevation = r, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        updateElevation(r, o = !1) {
          const u = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (this._seaLevelZoom == null || u) && this._updateCameraOnTerrain(), (r || u) && this._constrainCamera(o), this._calcMatrices();
        }
        getProjection() {
          return s.pick(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(r) {
          this.projectionOptions = r || { name: "mercator" };
          const o = this.projection ? this.getProjection() : void 0;
          this.projection = s.getProjection(this.projectionOptions);
          const u = !re(o, this.getProjection());
          return u && this._calcMatrices(), this.mercatorFromTransition = !1, u;
        }
        setMercatorFromTransition() {
          const r = this.projection.name;
          this.mercatorFromTransition = !0, this.projectionOptions = { name: "mercator" }, this.projection = s.getProjection({ name: "mercator" });
          const o = r !== this.projection.name;
          return o && this._calcMatrices(), o;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(r) {
          this._minZoom !== r && (this._minZoom = r, this.zoom = Math.max(this.zoom, r));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(r) {
          this._maxZoom !== r && (this._maxZoom = r, this.zoom = Math.min(this.zoom, r));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(r) {
          this._minPitch !== r && (this._minPitch = r, this.pitch = Math.max(this.pitch, r));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(r) {
          this._maxPitch !== r && (this._maxPitch = r, this.pitch = Math.min(this.pitch, r));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && this.projection.supportsWorldCopies === !0;
        }
        set renderWorldCopies(r) {
          r === void 0 ? r = !0 : r === null && (r = !1), this._renderWorldCopies = r;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const r = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(r));
        }
        get cameraWorldSize() {
          const r = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(r));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return s.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new s.Point(this.width, this.height);
        }
        get bearing() {
          return s.wrap(this.rotation, -180, 180);
        }
        set bearing(r) {
          this.rotation = r;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(r) {
          const o = -r * Math.PI / 180;
          var u;
          this.angle !== o && (this._unmodified = !1, this.angle = o, this._calcMatrices(), this.rotationMatrix = (u = new s.ARRAY_TYPE(4), s.ARRAY_TYPE != Float32Array && (u[1] = 0, u[2] = 0), u[0] = 1, u[3] = 1, u), function(d, f, g) {
            var x = f[0], b = f[1], M = f[2], S = f[3], P = Math.sin(g), F = Math.cos(g);
            d[0] = x * F + M * P, d[1] = b * F + S * P, d[2] = x * -P + M * F, d[3] = b * -P + S * F;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(r) {
          const o = s.clamp(r, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== o && (this._unmodified = !1, this._pitch = o, this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const r = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / r);
        }
        set fov(r) {
          r = Math.max(0.01, Math.min(60, r)), this._fov !== r && (this._unmodified = !1, this._fov = s.degToRad(r), this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(r) {
          this._averageElevation = r, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(r) {
          const o = Math.min(Math.max(r, this.minZoom), this.maxZoom);
          this._zoom !== o && (this._unmodified = !1, this._setZoom(o), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(r) {
          this._zoom = r, this.scale = this.zoomScale(r), this.tileZoom = Math.floor(r), this.zoomFraction = r - this.tileZoom;
        }
        _updateCameraOnTerrain() {
          if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const r = this._elevation;
          this._centerAltitude = r.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = r.exaggeration(), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation) return 0;
          const r = this._elevation, o = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], u = this.horizonLineFromTop();
          let d = 0, f = 0;
          for (let g = 0; g < o.length; g++) {
            const x = new s.Point(o[g][0] * this.width, u + o[g][1] * (this.height - u)), b = r.pointCoordinate(x);
            if (!b) continue;
            const M = 1 / Math.hypot(b[0] - this._camera.position[0], b[1] - this._camera.position[1]);
            d += b[3] * M, f += M;
          }
          return f === 0 ? NaN : d / f;
        }
        get center() {
          return this._center;
        }
        set center(r) {
          r.lat === this._center.lat && r.lng === this._center.lng || (this._unmodified = !1, this._center = r, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (this._seaLevelZoom == null || !this._elevation) return;
          const r = this._seaLevelZoom, o = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), u = this.pixelsPerMeter / this.worldSize * o, d = this._mercatorZfromZoom(r), f = this._mercatorZfromZoom(this._maxZoom), g = Math.max(d - u, f);
          this._setZoom(this._zoomFromMercatorZ(g));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(r) {
          this._edgeInsets.equals(r) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, r, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(r) {
          const o = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, r.toAltitude()));
          let u;
          u = r.z < this._camera.position[2] ? [o.x, o.y, o.z] : [r.x, r.y, r.z];
          const d = s.length(s.sub([], this._camera.position, u));
          return s.clamp(this._zoomFromMercatorZ(d), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(r) {
          if (!this.height || !r.position && !r.orientation) return;
          this._updateCameraState();
          let o = !1;
          if (r.orientation && !s.exactEquals(r.orientation, this._camera.orientation) && (o = this._setCameraOrientation(r.orientation)), r.position) {
            const u = [r.position.x, r.position.y, r.position.z];
            s.exactEquals$1(u, this._camera.position) || (this._setCameraPosition(u), o = !0);
          }
          o && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const r = this._camera.position, o = new wo();
          return o.position = new s.MercatorCoordinate(r[0], r[1], r[2]), o.orientation = this._camera.orientation, o._elevation = this.elevation, o._renderWorldCopies = this.renderWorldCopies, o;
        }
        _setCameraOrientation(r) {
          if (!s.length$1(r)) return !1;
          s.normalize$1(r, r);
          const o = s.transformQuat([], [0, 0, -1], r), u = s.transformQuat([], [0, -1, 0], r);
          if (u[2] < 0) return !1;
          const d = Ln(o, u);
          return !!d && (this._camera.orientation = d, !0);
        }
        _setCameraPosition(r) {
          const o = this.zoomScale(this.minZoom) * this.tileSize, u = this.zoomScale(this.maxZoom) * this.tileSize, d = this.cameraToCenterDistance;
          r[2] = s.clamp(r[2], d / u, d / o), this._camera.position = r;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(r) {
          return this._edgeInsets.equals(r);
        }
        interpolatePadding(r, o, u) {
          this._unmodified = !1, this._edgeInsets.interpolate(r, o, u), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(r) {
          const o = (r.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / r.tileSize));
          return Math.max(0, o);
        }
        getVisibleUnwrappedCoordinates(r) {
          const o = [new s.UnwrappedTileID(0, r)];
          if (this.renderWorldCopies) {
            const u = this.pointCoordinate(new s.Point(0, 0)), d = this.pointCoordinate(new s.Point(this.width, 0)), f = this.pointCoordinate(new s.Point(this.width, this.height)), g = this.pointCoordinate(new s.Point(0, this.height)), x = Math.floor(Math.min(u.x, d.x, f.x, g.x)), b = Math.floor(Math.max(u.x, d.x, f.x, g.x)), M = 1;
            for (let S = x - M; S <= b + M; S++) S !== 0 && o.push(new s.UnwrappedTileID(S, r));
          }
          return o;
        }
        coveringTiles(r) {
          let o = this.coveringZoomLevel(r);
          const u = o, d = this.elevation && !r.isTerrainDEM, f = this.projection.name === "mercator";
          if (r.minzoom !== void 0 && o < r.minzoom) return [];
          r.maxzoom !== void 0 && o > r.maxzoom && (o = r.maxzoom);
          const g = this.locationCoordinate(this.center), x = this.center.lat, b = 1 << o, M = [b * g.x, b * g.y, 0], S = this.projection.name === "globe", P = !S, F = s.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, o, P), j = S ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), $ = b * s.mercatorZfromAltitude(1, this.center.lat), G = this._camera.position[2] / s.mercatorZfromAltitude(1, this.center.lat), Z = [b * j.x, b * j.y, G * (P ? 1 : $)], L = this.cameraToCenterDistance / r.tileSize * (r.roundZoom ? 1 : 0.502), N = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? o : 0, X = r.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, K = r.isTerrainDEM ? -X : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, le = this.projection.isReprojectedInTileSpace ? la(this) : 1, ue = (Te) => {
            const We = new s.MercatorCoordinate(Te.x + 25e-6, Te.y, Te.z), Ne = new s.MercatorCoordinate(Te.x, Te.y + 25e-6, Te.z), He = Te.toLngLat(), wt = We.toLngLat(), Dt = Ne.toLngLat(), gt = this.locationCoordinate(He), Ct = this.locationCoordinate(wt), ti = this.locationCoordinate(Dt), Yt = Math.hypot(Ct.x - gt.x, Ct.y - gt.y), vt = Math.hypot(ti.x - gt.x, ti.y - gt.y);
            return Math.sqrt(Yt * vt) * le / 25e-6;
          }, ce = (Te) => {
            const Re = X, We = K;
            return { aabb: s.tileAABB(this, b, 0, 0, 0, Te, We, Re, this.projection), zoom: 0, x: 0, y: 0, minZ: We, maxZ: Re, wrap: Te, fullyVisible: !1 };
          }, ge = [];
          let me = [];
          const Ee = o, Ge = r.reparseOverscaled ? u : o, be = (Te) => Te * Te, Oe = be((G - this._centerAltitude) * $), Ce = (Te) => {
            if (!this._elevation || !Te.tileID || !f) return;
            const Re = this._elevation.getMinMaxForTile(Te.tileID), We = Te.aabb;
            Re ? (We.min[2] = Re.min, We.max[2] = Re.max, We.center[2] = (We.min[2] + We.max[2]) / 2) : (Te.shouldSplit = Ve(Te), Te.shouldSplit || (We.min[2] = We.max[2] = We.center[2] = this._centerAltitude));
          }, Ve = (Te) => {
            if (Te.zoom < N) return !0;
            if (Te.zoom === Ee) return !1;
            if (Te.shouldSplit != null) return Te.shouldSplit;
            const Re = Te.aabb.distanceX(Z), We = Te.aabb.distanceY(Z);
            let Ne = Oe, He = 1;
            if (S) {
              Ne = be(Te.aabb.distanceZ(Z));
              const gt = Math.pow(2, Te.zoom), Ct = s.latFromMercatorY((Te.y + 1) / gt), ti = s.latFromMercatorY(Te.y / gt), Yt = Math.min(Math.max(x, Ct), ti), vt = s.circumferenceAtLatitude(Yt) / s.circumferenceAtLatitude(x);
              if (He = Yt === x ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, vt / this._mercatorScaleRatio), this.zoom <= s.GLOBE_ZOOM_THRESHOLD_MIN && Te.zoom === Ee - 1 && vt >= 0.9) return !0;
            } else if (d && (Ne = be(Te.aabb.distanceZ(Z) * $)), this.projection.isReprojectedInTileSpace && u <= 5) {
              const gt = Math.pow(2, Te.zoom), Ct = ue(new s.MercatorCoordinate((Te.x + 0.5) / gt, (Te.y + 0.5) / gt));
              He = Ct > 0.85 ? 1 : Ct;
            }
            const wt = Re * Re + We * We + Ne, Dt = be((1 << Ee - Te.zoom) * L * He * ((gt, Ct) => {
              if (Ct * be(0.707) < gt) return 1;
              const ti = Math.sqrt(Ct / gt);
              return ti / (1.4144271570014144 + (Math.pow(1.1, ti - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            })(Math.max(Ne, Oe), wt));
            return wt < Dt;
          };
          if (this.renderWorldCopies) for (let Te = 1; Te <= 3; Te++) ge.push(ce(-Te)), ge.push(ce(Te));
          for (ge.push(ce(0)); ge.length > 0; ) {
            const Te = ge.pop(), Re = Te.x, We = Te.y;
            let Ne = Te.fullyVisible;
            if (!Ne) {
              const He = Te.aabb.intersects(F);
              if (He === 0) continue;
              Ne = He === 2;
            }
            if (Te.zoom !== Ee && Ve(Te)) for (let He = 0; He < 4; He++) {
              const wt = (Re << 1) + He % 2, Dt = (We << 1) + (He >> 1), gt = { aabb: f ? Te.aabb.quadrant(He) : s.tileAABB(this, b, Te.zoom + 1, wt, Dt, Te.wrap, Te.minZ, Te.maxZ, this.projection), zoom: Te.zoom + 1, x: wt, y: Dt, wrap: Te.wrap, fullyVisible: Ne, tileID: void 0, shouldSplit: void 0, minZ: Te.minZ, maxZ: Te.maxZ };
              d && !S && (gt.tileID = new s.OverscaledTileID(Te.zoom + 1 === Ee ? Ge : Te.zoom + 1, Te.wrap, Te.zoom + 1, wt, Dt), Ce(gt)), ge.push(gt);
            }
            else {
              const He = Te.zoom === Ee ? Ge : Te.zoom;
              if (r.minzoom && r.minzoom > He) continue;
              const wt = M[0] - (0.5 + Re + (Te.wrap << Te.zoom)) * (1 << o - Te.zoom), Dt = M[1] - 0.5 - We, gt = Te.tileID ? Te.tileID : new s.OverscaledTileID(He, Te.wrap, Te.zoom, Re, We);
              me.push({ tileID: gt, distanceSq: wt * wt + Dt * Dt });
            }
          }
          if (this.fogCullDistSq) {
            const Te = this.fogCullDistSq, Re = this.horizonLineFromTop();
            me = me.filter((We) => {
              const Ne = [0, 0, 0, 1], He = [s.EXTENT, s.EXTENT, 0, 1], wt = this.calculateFogTileMatrix(We.tileID.toUnwrapped());
              s.transformMat4$1(Ne, Ne, wt), s.transformMat4$1(He, He, wt);
              const Dt = s.getAABBPointSquareDist(Ne, He);
              if (Dt === 0) return !0;
              let gt = !1;
              const Ct = this._elevation;
              if (Ct && Dt > Te && Re !== 0) {
                const ti = this.calculateProjMatrix(We.tileID.toUnwrapped());
                let Yt;
                r.isTerrainDEM || (Yt = Ct.getMinMaxForTile(We.tileID)), Yt || (Yt = { min: K, max: X });
                const vt = s.furthestTileCorner(this.rotation), vi = [vt[0] * s.EXTENT, vt[1] * s.EXTENT, Yt.max];
                s.transformMat4(vi, vi, ti), gt = (1 - vi[1]) * this.height * 0.5 < Re;
              }
              return Dt < Te || gt;
            });
          }
          return me.sort((Te, Re) => Te.distanceSq - Re.distanceSq).map((Te) => Te.tileID);
        }
        resize(r, o) {
          this.width = r, this.height = o, this.pixelsToGLUnits = [2 / r, -2 / o], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(r) {
          return Math.pow(2, r);
        }
        scaleZoom(r) {
          return Math.log(r) / Math.LN2;
        }
        project(r) {
          const o = s.clamp(r.lat, -s.MAX_MERCATOR_LATITUDE, s.MAX_MERCATOR_LATITUDE), u = this.projection.project(r.lng, o);
          return new s.Point(u.x * this.worldSize, u.y * this.worldSize);
        }
        unproject(r) {
          return this.projection.unproject(r.x / this.worldSize, r.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        get pointMerc() {
          return this.point._div(this.worldSize);
        }
        get pixelsPerMeterRatio() {
          return this.pixelsPerMeter / s.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
        }
        setLocationAtPoint(r, o) {
          let u, d;
          const f = this.centerPoint;
          if (this.projection.name === "globe") {
            const x = this.worldSize;
            u = (o.x - f.x) / x, d = (o.y - f.y) / x;
          } else {
            const x = this.pointCoordinate(o), b = this.pointCoordinate(f);
            u = x.x - b.x, d = x.y - b.y;
          }
          const g = this.locationCoordinate(r);
          this.setLocation(new s.MercatorCoordinate(g.x - u, g.y - d));
        }
        setLocation(r) {
          this.center = this.coordinateLocation(r), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(r) {
          return this.projection.locationPoint(this, r);
        }
        locationPoint3D(r) {
          return this.projection.locationPoint(this, r, !0);
        }
        pointLocation(r) {
          return this.coordinateLocation(this.pointCoordinate(r));
        }
        pointLocation3D(r) {
          return this.coordinateLocation(this.pointCoordinate3D(r));
        }
        locationCoordinate(r, o) {
          const u = o ? s.mercatorZfromAltitude(o, r.lat) : void 0, d = this.projection.project(r.lng, r.lat);
          return new s.MercatorCoordinate(d.x, d.y, u);
        }
        coordinateLocation(r) {
          return this.projection.unproject(r.x, r.y);
        }
        pointRayIntersection(r, o) {
          const u = o ?? this._centerAltitude, d = [r.x, r.y, 0, 1], f = [r.x, r.y, 1, 1];
          s.transformMat4$1(d, d, this.pixelMatrixInverse), s.transformMat4$1(f, f, this.pixelMatrixInverse);
          const g = f[3];
          s.scale$1(d, d, 1 / d[3]), s.scale$1(f, f, 1 / g);
          const x = d[2], b = f[2];
          return { p0: d, p1: f, t: x === b ? 0 : (u - x) / (b - x) };
        }
        screenPointToMercatorRay(r) {
          const o = [r.x, r.y, 0, 1], u = [r.x, r.y, 1, 1];
          return s.transformMat4$1(o, o, this.pixelMatrixInverse), s.transformMat4$1(u, u, this.pixelMatrixInverse), s.scale$1(o, o, 1 / o[3]), s.scale$1(u, u, 1 / u[3]), o[2] = s.mercatorZfromAltitude(o[2], this._center.lat) * this.worldSize, u[2] = s.mercatorZfromAltitude(u[2], this._center.lat) * this.worldSize, s.scale$1(o, o, 1 / this.worldSize), s.scale$1(u, u, 1 / this.worldSize), new s.Ray([o[0], o[1], o[2]], s.normalize([], s.sub([], u, o)));
        }
        rayIntersectionCoordinate(r) {
          const { p0: o, p1: u, t: d } = r, f = s.mercatorZfromAltitude(o[2], this._center.lat), g = s.mercatorZfromAltitude(u[2], this._center.lat);
          return new s.MercatorCoordinate(s.number(o[0], u[0], d) / this.worldSize, s.number(o[1], u[1], d) / this.worldSize, s.number(f, g, d));
        }
        pointCoordinate(r, o = this._centerAltitude) {
          return this.projection.pointCoordinate(this, r.x, r.y, o);
        }
        pointCoordinate3D(r) {
          if (!this.elevation) return this.pointCoordinate(r);
          let o = this.projection.pointCoordinate3D(this, r.x, r.y);
          if (o) return new s.MercatorCoordinate(o[0], o[1], o[2]);
          let u = 0, d = this.horizonLineFromTop();
          if (r.y > d) return this.pointCoordinate(r);
          const f = 0.02 * d, g = r.clone();
          for (let x = 0; x < 10 && d - u > f; x++) {
            g.y = s.number(u, d, 0.66);
            const b = this.projection.pointCoordinate3D(this, g.x, g.y);
            b ? (d = g.y, o = b) : u = g.y;
          }
          return o ? new s.MercatorCoordinate(o[0], o[1], o[2]) : this.pointCoordinate(r);
        }
        isPointAboveHorizon(r) {
          return this.projection.isPointAboveHorizon(this, r);
        }
        isPointOnSurface(r) {
          if (r.y < 0 || r.y > this.height || r.x < 0 || r.x > this.width) return !1;
          if (this.elevation || this.zoom >= s.GLOBE_ZOOM_THRESHOLD_MAX) return !this.isPointAboveHorizon(r);
          const o = this.pointCoordinate(r);
          return o.y >= 0 && o.y <= 1;
        }
        _coordinatePoint(r, o) {
          const u = o && this.elevation ? this.elevation.getAtPointOrZero(r, this._centerAltitude) : this._centerAltitude, d = [r.x * this.worldSize, r.y * this.worldSize, u + r.toAltitude(), 1];
          return s.transformMat4$1(d, d, this.pixelMatrix), d[3] > 0 ? new s.Point(d[0] / d[3], d[1] / d[3]) : new s.Point(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBoundsNonRectangular() {
          const { top: r, left: o } = this._edgeInsets, u = this.height - this._edgeInsets.bottom, d = this.width - this._edgeInsets.right, f = this.pointLocation3D(new s.Point(o, r)), g = this.pointLocation3D(new s.Point(d, r)), x = this.pointLocation3D(new s.Point(d, u)), b = this.pointLocation3D(new s.Point(o, u));
          let M = Math.min(f.lng, g.lng, x.lng, b.lng), S = Math.max(f.lng, g.lng, x.lng, b.lng), P = Math.min(f.lat, g.lat, x.lat, b.lat), F = Math.max(f.lat, g.lat, x.lat, b.lat);
          const j = Math.pow(2, -this.zoom) / 16 * 270, $ = this.projection.name === "globe" ? 1 : 4, G = (Z, L, N, X, K) => {
            const le = (Z + N) / 2, ue = (L + X) / 2, ce = new s.Point(le, ue), { lng: ge, lat: me } = this.pointLocation3D(ce), Ee = Math.max(0, M - ge, P - me, ge - S, me - F);
            M = Math.min(M, ge), S = Math.max(S, ge), P = Math.min(P, me), F = Math.max(F, me), (K < $ || Ee > j) && (G(Z, L, le, ue, K + 1), G(le, ue, N, X, K + 1));
          };
          if (G(o, r, d, r, 1), G(d, r, d, u, 1), G(d, u, o, u, 1), G(o, u, o, r, 1), this.projection.name === "globe") {
            const [Z, L] = s.polesInViewport(this);
            Z ? (F = 90, S = 180, M = -180) : L && (P = -90, S = 180, M = -180);
          }
          return new s.LngLatBounds(new s.LngLat(M, P), new s.LngLat(S, F));
        }
        _getBoundsRectangular(r, o) {
          const { top: u, left: d } = this._edgeInsets, f = this.height - this._edgeInsets.bottom, g = this.width - this._edgeInsets.right, x = new s.Point(d, u), b = new s.Point(g, u), M = new s.Point(g, f), S = new s.Point(d, f);
          let P = this.pointCoordinate(x, r), F = this.pointCoordinate(b, r);
          const j = this.pointCoordinate(M, o), $ = this.pointCoordinate(S, o), G = (Z, L) => (L.y - Z.y) / (L.x - Z.x);
          return P.y > 1 && F.y >= 0 ? P = new s.MercatorCoordinate((1 - $.y) / G($, P) + $.x, 1) : P.y < 0 && F.y <= 1 && (P = new s.MercatorCoordinate(-$.y / G($, P) + $.x, 0)), F.y > 1 && P.y >= 0 ? F = new s.MercatorCoordinate((1 - j.y) / G(j, F) + j.x, 1) : F.y < 0 && P.y <= 1 && (F = new s.MercatorCoordinate(-j.y / G(j, F) + j.x, 0)), new s.LngLatBounds().extend(this.coordinateLocation(P)).extend(this.coordinateLocation(F)).extend(this.coordinateLocation($)).extend(this.coordinateLocation(j));
        }
        _getBoundsRectangularTerrain() {
          const r = this.elevation;
          if (!r.visibleDemTiles.length || r.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
          const o = r.visibleDemTiles.reduce((u, d) => {
            if (d.dem) {
              const f = d.dem.tree;
              u.min = Math.min(u.min, f.minimums[0]), u.max = Math.max(u.max, f.maximums[0]);
            }
            return u;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBoundsRectangular(o.min * r.exaggeration(), o.max * r.exaggeration());
        }
        getBounds() {
          return this.projection.name === "mercator" || this.projection.name === "equirectangular" ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
        }
        horizonLineFromTop(r = !0) {
          const o = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, u = this.height / 2 - o * (1 - this._horizonShift);
          return r ? Math.max(0, u) : u;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(r) {
          this.maxBounds = r, this.minLat = -s.MAX_MERCATOR_LATITUDE, this.maxLat = s.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, r && (this.minLat = r.getSouth(), this.maxLat = r.getNorth(), this.minLng = r.getWest(), this.maxLng = r.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = s.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = s.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = s.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = s.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(r, o) {
          return this.projection.createTileMatrix(this, o, r);
        }
        calculateDistanceTileData(r) {
          const o = r.key, u = this._distanceTileDataCache;
          if (u[o]) return u[o];
          const d = r.canonical, f = 1 / this.height, g = this.cameraWorldSize, x = g / this.zoomScale(d.z), b = (d.x + Math.pow(2, d.z) * r.wrap) * x, M = d.y * x, S = this.point;
          S.x *= g / this.worldSize, S.y *= g / this.worldSize;
          const P = this.angle, F = Math.sin(-P), j = -Math.cos(-P);
          return u[o] = { bearing: [F, j], center: [(S.x - b) * f, (S.y - M) * f], scale: x / s.EXTENT * f }, u[o];
        }
        calculateFogTileMatrix(r) {
          const o = r.key, u = this._fogTileMatrixCache;
          if (u[o]) return u[o];
          const d = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, r);
          return s.multiply(d, this.worldToFogMatrix, d), u[o] = new Float32Array(d), u[o];
        }
        calculateProjMatrix(r, o = !1) {
          const u = r.key, d = o ? this._alignedProjMatrixCache : this._projMatrixCache;
          if (d[u]) return d[u];
          const f = this.calculatePosMatrix(r, this.worldSize);
          return s.multiply(f, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o ? this.alignedProjMatrix : this.projMatrix, f), d[u] = new Float32Array(f), d[u];
        }
        calculatePixelsToTileUnitsMatrix(r) {
          const o = r.tileID.key, u = this._pixelsToTileUnitsCache;
          if (u[o]) return u[o];
          const d = function(f, g) {
            const { scale: x } = f.tileTransform, b = x * s.EXTENT / (f.tileSize * Math.pow(2, g.zoom - f.tileID.overscaledZ + f.tileID.canonical.z));
            return M = new Float32Array(4), F = (S = g.inverseAdjustmentMatrix)[1], j = S[2], $ = S[3], Z = (P = [b, b])[1], M[0] = S[0] * (G = P[0]), M[1] = F * G, M[2] = j * Z, M[3] = $ * Z, M;
            var M, S, P, F, j, $, G, Z;
          }(r, this);
          return u[o] = d, u[o];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        globeToMercatorMatrix() {
          if (this.projection.name === "globe") {
            const r = 1 / this.worldSize, o = s.fromScaling([], [r, r, r]);
            return s.multiply(o, o, this.globeMatrix), o;
          }
        }
        recenterOnTerrain() {
          if (!this._elevation || this.projection.name === "globe") return;
          const r = this._elevation;
          this._updateCameraState();
          const o = s.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, u = this._computeCameraPosition(o), d = this._camera.forward(), f = s.mercatorZfromAltitude(1, this._center.lat);
          u[2] /= f, d[2] /= f, s.normalize(d, d);
          const g = r.raycast(u, d, r.exaggeration());
          if (g) {
            const x = s.scaleAndAdd([], u, d, g), b = new s.MercatorCoordinate(x[0], x[1], s.mercatorZfromAltitude(x[2], s.latFromMercatorY(x[1]))), M = (b.z + s.length([b.x - u[0], b.y - u[1], b.z - u[2] * f])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(M), this._centerAltitude = b.toAltitude(), this._center = this.coordinateLocation(b), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(r = !1) {
          if (!this._elevation) return;
          const o = this._elevation, u = s.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, d = this._computeCameraPosition(u), f = o.getAtPointOrZero(new s.MercatorCoordinate(...d)), g = this.pixelsPerMeter / this.worldSize * f, x = this._minimumHeightOverTerrain(), b = d[2] - g;
          if (b <= x) if (b < 0 || r) {
            const M = this.locationCoordinate(this._center, this._centerAltitude), S = [d[0], d[1], M.z - d[2]], P = s.length(S);
            S[2] -= (x - b) / this._pixelsPerMercatorPixel;
            const F = s.length(S);
            if (F === 0) return;
            s.scale$2(S, S, P / F * this._pixelsPerMercatorPixel), this._camera.position = [d[0], d[1], M.z * this._pixelsPerMercatorPixel - S[2]], this._updateStateFromCamera();
          } else this._isCameraConstrained = !0;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const r = this.projection.name === "globe" || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || r) {
            const F = this.center;
            return F.lat = s.clamp(F.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !r) && (F.lng = s.clamp(F.lng, this.minLng, this.maxLng)), this.center = F, void (this._constraining = !1);
          }
          const o = this._unmodified, { x: u, y: d } = this.point;
          let f = 0, g = u, x = d;
          const b = this.width / 2, M = this.height / 2, S = this.worldMinY * this.scale, P = this.worldMaxY * this.scale;
          if (d - M < S && (x = S + M), d + M > P && (x = P - M), P - S < this.height && (f = Math.max(f, this.height / (P - S)), x = (P + S) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const F = this.worldMinX * this.scale, j = this.worldMaxX * this.scale, $ = this.worldSize / 2 - (F + j) / 2;
            g = (u + $ + this.worldSize) % this.worldSize - $, g - b < F && (g = F + b), g + b > j && (g = j - b), j - F < this.width && (f = Math.max(f, this.width / (j - F)), g = (j + F) / 2);
          }
          g === u && x === d || (this.center = this.unproject(new s.Point(g, x))), f && (this.zoom += this.scaleZoom(f)), this._constrainCamera(), this._unmodified = o, this._constraining = !1;
        }
        _minZoomForBounds() {
          let r = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (r = Math.max(r, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), r;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height) return;
          const r = this.centerOffset, o = this.pixelsPerMeter;
          this.projection.name === "globe" && (this._mercatorScaleRatio = s.mercatorZfromAltitude(1, this.center.lat) / s.mercatorZfromAltitude(1, s.GLOBE_SCALE_MATCH_LATITUDE));
          const u = No(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, u), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const d = this.projection.zAxisUnit === "meters" ? o : 1, f = this._camera.getWorldToCamera(this.worldSize, d), g = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          g[8] = 2 * -r.x / this.width, g[9] = 2 * r.y / this.height;
          let x = s.mul([], g, f);
          if (this.projection.isReprojectedInTileSpace) {
            const ue = this.locationCoordinate(this.center), ce = s.identity([]);
            s.translate(ce, ce, [ue.x * this.worldSize, ue.y * this.worldSize, 0]), s.multiply(ce, ce, Qn(this)), s.translate(ce, ce, [-ue.x * this.worldSize, -ue.y * this.worldSize, 0]), s.multiply(x, x, ce), this.inverseAdjustmentMatrix = function(ge) {
              const me = Qn(ge, !0);
              return et([], [me[0], me[1], me[4], me[5]]);
            }(this);
          } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          this.mercatorMatrix = s.scale([], x, [this.worldSize, this.worldSize, this.worldSize / d, 1]), this.projMatrix = x, this.invProjMatrix = s.invert(new Float64Array(16), this.projMatrix);
          const b = s.invert([], g);
          this.frustumCorners = s.FrustumCorners.fromInvProjectionMatrix(b, this.horizonLineFromTop(), this.height);
          const M = new Float32Array(16);
          s.identity(M), s.scale(M, M, [1, -1, 1]), s.rotateX(M, M, this._pitch), s.rotateZ(M, M, this.angle);
          const S = s.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), P = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          S[8] = 2 * -r.x / this.width, S[9] = 2 * (r.y + P) / this.height, this.skyboxMatrix = s.multiply(M, S, M);
          const F = this.point, j = F.x, $ = F.y, G = this.width % 2 / 2, Z = this.height % 2 / 2, L = Math.cos(this.angle), N = Math.sin(this.angle), X = j - Math.round(j) + L * G + N * Z, K = $ - Math.round($) + L * Z + N * G, le = new Float64Array(x);
          if (s.translate(le, le, [X > 0.5 ? X - 1 : X, K > 0.5 ? K - 1 : K, 0]), this.alignedProjMatrix = le, x = s.create(), s.scale(x, x, [this.width / 2, -this.height / 2, 1]), s.translate(x, x, [1, -1, 0]), this.labelPlaneMatrix = x, x = s.create(), s.scale(x, x, [1, -1, 1]), s.translate(x, x, [-1, -1, 0]), s.scale(x, x, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = x, this.pixelMatrix = s.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, x = s.invert(new Float64Array(16), this.pixelMatrix), !x) throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = x, this.projection.name === "globe" || this.mercatorFromTransition) {
            this.globeMatrix = s.calculateGlobeMatrix(this);
            const ue = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = s.transformMat4(ue, ue, f), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else this.globeMatrix = x;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const r = this.cameraWorldSizeForFog, o = this.cameraPixelsPerMeter, u = this._camera.position, d = 1 / this.height / this._pixelsPerMercatorPixel, f = [r, r, o];
          s.scale$2(f, f, d), s.scale$2(u, u, -1), s.multiply$2(u, u, f);
          const g = s.create();
          s.translate(g, g, u), s.scale(g, g, f), this.mercatorFogMatrix = g, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(r, o, d);
        }
        _computeCameraPosition(r) {
          const o = (r = r || this.pixelsPerMeter) / this.pixelsPerMeter, u = this._camera.forward(), d = this.point, f = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * o - r / this.worldSize * this._centerAltitude;
          return [d.x / this.worldSize - u[0] * f, d.y / this.worldSize - u[1] * f, r / this.worldSize * this._centerAltitude - u[2] * f];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(r) {
          const o = this._maxCameraBoundsDistance() * Math.cos(this._pitch), u = this._camera.position[2], d = r[2];
          let f = 1;
          this.projection.wrap && (this.center = this.center.wrap()), d > 0 && (f = Math.min((o - u) / d, 1)), this._camera.position = s.scaleAndAdd([], this._camera.position, r, f), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const r = this._camera.position, o = this._camera.forward(), { pitch: u, bearing: d } = this._camera.getPitchBearing(), f = s.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, g = this._mercatorZfromZoom(this._maxZoom) * Math.cos(s.degToRad(this._maxPitch)), x = Math.max((r[2] - f) / Math.cos(u), g), b = this._zoomFromMercatorZ(x);
          s.scaleAndAdd(r, r, o, x), this._pitch = s.clamp(u, s.degToRad(this.minPitch), s.degToRad(this.maxPitch)), this.angle = s.wrap(d, -Math.PI, Math.PI), this._setZoom(s.clamp(b, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new s.MercatorCoordinate(r[0], r[1], r[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(r) {
          return Math.pow(2, r) * this.tileSize;
        }
        _mercatorZfromZoom(r) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(r);
        }
        _minimumHeightOverTerrain() {
          const r = Math.min((this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
          return this._mercatorZfromZoom(r);
        }
        _zoomFromMercatorZ(r) {
          return this.scaleZoom(this.cameraToCenterDistance / (r * this.tileSize));
        }
        zoomFromMercatorZAdjusted(r) {
          let o = 0, u = s.GLOBE_ZOOM_THRESHOLD_MAX, d = 0, f = 1 / 0;
          for (; u - o > 1e-6 && u > o; ) {
            const g = o + 0.5 * (u - o), x = this.tileSize * Math.pow(2, g), b = this.getCameraToCenterDistance(this.projection, g, x), M = this.scaleZoom(b / (r * this.tileSize)), S = Math.abs(g - M);
            S < f && (f = S, d = g), g < M ? o = g : u = g;
          }
          return d;
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (s.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(r, o) {
          const u = Math.min(r.x, o.x), d = Math.max(r.x, o.x), f = Math.min(r.y, o.y), g = Math.max(r.y, o.y);
          if (f < this.horizonLineFromTop(!1)) return !0;
          if (this.projection.name !== "mercator") return !1;
          const x = [new s.Point(u, f), new s.Point(d, g), new s.Point(u, g), new s.Point(d, f)], b = this.renderWorldCopies ? -3 : 0, M = this.renderWorldCopies ? 4 : 1;
          for (const S of x) {
            const P = this.pointRayIntersection(S);
            if (P.t < 0) return !0;
            const F = this.rayIntersectionCoordinate(P);
            if (F.x < b || F.y < 0 || F.x > M || F.y > 1) return !0;
          }
          return !1;
        }
        isHorizonVisible() {
          return this.pitch + s.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new s.Point(0, 0), new s.Point(this.width, this.height));
        }
        zoomDeltaToMovement(r, o) {
          const u = s.length(s.sub([], this._camera.position, r)), d = this._zoomFromMercatorZ(u) + o;
          return u - this._mercatorZfromZoom(d);
        }
        getCameraPoint() {
          if (this.projection.name === "globe") {
            const r = function([o, u, d], f) {
              const g = [o, u, d, 1];
              s.transformMat4$1(g, g, f);
              const x = g[3] = Math.max(g[3], 1e-6);
              return g[0] /= x, g[1] /= x, g[2] /= x, g;
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new s.Point(r[0], r[1]);
          }
          {
            const r = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.Point(0, r));
          }
        }
        getCameraToCenterDistance(r, o = this.zoom, u = this.worldSize) {
          const d = No(r, o, this.width, this.height, 1024), f = r.pixelSpaceConversion(this.center.lat, u, d);
          return 0.5 / Math.tan(0.5 * this._fov) * this.height * f;
        }
        getWorldToCameraMatrix() {
          const r = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? this.pixelsPerMeter : 1);
          return this.projection.name === "globe" && s.multiply(r, r, this.globeMatrix), r;
        }
      }
      function ca(l, r) {
        let o = !1, u = null;
        const d = () => {
          u = null, o && (l(), u = setTimeout(d, r), o = !1);
        };
        return () => (o = !0, u || d(), u);
      }
      class fc {
        constructor(r) {
          this._hashName = r && encodeURIComponent(r), s.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = ca(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(r) {
          return this._map = r, s.window.addEventListener("hashchange", this._onHashChange, !1), r.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), s.window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const r = this._map;
          if (!r) return "";
          const o = $a(r);
          if (this._hashName) {
            const u = this._hashName;
            let d = !1;
            const f = s.window.location.hash.slice(1).split("&").map((g) => {
              const x = g.split("=")[0];
              return x === u ? (d = !0, `${x}=${o}`) : g;
            }).filter((g) => g);
            return d || f.push(`${u}=${o}`), `#${f.join("&")}`;
          }
          return `#${o}`;
        }
        _getCurrentHash() {
          const r = s.window.location.hash.replace("#", "");
          if (this._hashName) {
            let o;
            return r.split("&").map((u) => u.split("=")).forEach((u) => {
              u[0] === this._hashName && (o = u);
            }), (o && o[1] || "").split("/");
          }
          return r.split("/");
        }
        _onHashChange() {
          const r = this._map;
          if (!r) return !1;
          const o = this._getCurrentHash();
          if (o.length >= 3 && !o.some((u) => isNaN(u))) {
            const u = r.dragRotate.isEnabled() && r.touchZoomRotate.isEnabled() ? +(o[3] || 0) : r.getBearing();
            return r.jumpTo({ center: [+o[2], +o[1]], zoom: +o[0], bearing: u, pitch: +(o[4] || 0) }), !0;
          }
          return !1;
        }
        _updateHashUnthrottled() {
          const r = s.window.location.href.replace(/(#.+)?$/, this.getHashString());
          s.window.history.replaceState(s.window.history.state, null, r);
        }
      }
      function $a(l, r) {
        const o = l.getCenter(), u = Math.round(100 * l.getZoom()) / 100, d = Math.ceil((u * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), f = Math.pow(10, d), g = Math.round(o.lng * f) / f, x = Math.round(o.lat * f) / f, b = l.getBearing(), M = l.getPitch();
        let S = r ? `/${g}/${x}/${u}` : `${u}/${x}/${g}`;
        return (b || M) && (S += "/" + Math.round(10 * b) / 10), M && (S += `/${Math.round(M)}`), S;
      }
      const Za = { linearity: 0.3, easing: s.bezier(0, 0, 0.3, 1) }, Al = s.extend({ deceleration: 2500, maxSpeed: 1400 }, Za), Il = s.extend({ deceleration: 20, maxSpeed: 1400 }, Za), pt = s.extend({ deceleration: 1e3, maxSpeed: 360 }, Za), to = s.extend({ deceleration: 1e3, maxSpeed: 90 }, Za);
      class _u {
        constructor(r) {
          this._map = r, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(r) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: s.exported.now(), settings: r });
        }
        _drainInertiaBuffer() {
          const r = this._inertiaBuffer, o = s.exported.now();
          for (; r.length > 0 && o - r[0].time > 160; ) r.shift();
        }
        _onMoveEnd(r) {
          if (this._map._prefersReducedMotion() || (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)) return;
          const o = { zoom: 0, bearing: 0, pitch: 0, pan: new s.Point(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: f } of this._inertiaBuffer) o.zoom += f.zoomDelta || 0, o.bearing += f.bearingDelta || 0, o.pitch += f.pitchDelta || 0, f.panDelta && o.pan._add(f.panDelta), f.around && (o.around = f.around), f.pinchAround && (o.pinchAround = f.pinchAround);
          const u = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, d = {};
          if (o.pan.mag()) {
            const f = Wa(o.pan.mag(), u, s.extend({}, Al, r || {}));
            d.offset = o.pan.mult(f.amount / o.pan.mag()), d.center = this._map.transform.center, qa(d, f);
          }
          if (o.zoom) {
            const f = Wa(o.zoom, u, Il);
            d.zoom = this._map.transform.zoom + f.amount, qa(d, f);
          }
          if (o.bearing) {
            const f = Wa(o.bearing, u, pt);
            d.bearing = this._map.transform.bearing + s.clamp(f.amount, -179, 179), qa(d, f);
          }
          if (o.pitch) {
            const f = Wa(o.pitch, u, to);
            d.pitch = this._map.transform.pitch + f.amount, qa(d, f);
          }
          if (d.zoom || d.bearing) {
            const f = o.pinchAround === void 0 ? o.around : o.pinchAround;
            d.around = f ? this._map.unproject(f) : this._map.getCenter();
          }
          return this.clear(), d.noMoveStart = !0, d;
        }
      }
      function qa(l, r) {
        (!l.duration || l.duration < r.duration) && (l.duration = r.duration, l.easing = r.easing);
      }
      function Wa(l, r, o) {
        const { maxSpeed: u, linearity: d, deceleration: f } = o, g = s.clamp(l * d / (r / 1e3), -u, u), x = Math.abs(g) / (f * d);
        return { easing: o.easing, duration: 1e3 * x, amount: g * (x / 2) };
      }
      class Tr extends s.Event {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(r, o, u, d = {}) {
          const f = ni(o.getCanvasContainer(), u), g = o.unproject(f);
          super(r, s.extend({ point: f, lngLat: g, originalEvent: u }, d)), this._defaultPrevented = !1, this.target = o;
        }
      }
      class Xa extends s.Event {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(r, o, u) {
          const d = r === "touchend" ? u.changedTouches : u.touches, f = Qr(o.getCanvasContainer(), d), g = f.map((b) => o.unproject(b)), x = f.reduce((b, M, S, P) => b.add(M.div(P.length)), new s.Point(0, 0));
          super(r, { points: f, point: x, lngLats: g, lngLat: o.unproject(x), originalEvent: u }), this._defaultPrevented = !1;
        }
      }
      class Pl extends s.Event {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(r, o, u) {
          super(r, { originalEvent: u }), this._defaultPrevented = !1;
        }
      }
      class mc {
        constructor(r, o) {
          this._map = r, this._clickTolerance = o.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(r) {
          return this._firePreventable(new Pl(r.type, this._map, r));
        }
        mousedown(r, o) {
          return this._mousedownPos = o, this._firePreventable(new Tr(r.type, this._map, r));
        }
        mouseup(r) {
          this._map.fire(new Tr(r.type, this._map, r));
        }
        preclick(r) {
          const o = s.extend({}, r);
          o.type = "preclick", this._map.fire(new Tr(o.type, this._map, o));
        }
        click(r, o) {
          this._mousedownPos && this._mousedownPos.dist(o) >= this._clickTolerance || (this.preclick(r), this._map.fire(new Tr(r.type, this._map, r)));
        }
        dblclick(r) {
          return this._firePreventable(new Tr(r.type, this._map, r));
        }
        mouseover(r) {
          this._map.fire(new Tr(r.type, this._map, r));
        }
        mouseout(r) {
          this._map.fire(new Tr(r.type, this._map, r));
        }
        touchstart(r) {
          return this._firePreventable(new Xa(r.type, this._map, r));
        }
        touchmove(r) {
          this._map.fire(new Xa(r.type, this._map, r));
        }
        touchend(r) {
          this._map.fire(new Xa(r.type, this._map, r));
        }
        touchcancel(r) {
          this._map.fire(new Xa(r.type, this._map, r));
        }
        _firePreventable(r) {
          if (this._map.fire(r), r.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Ll {
        constructor(r) {
          this._map = r;
        }
        reset() {
          this._delayContextMenu = !1, this._contextMenuEvent = void 0;
        }
        mousemove(r) {
          this._map.fire(new Tr(r.type, this._map, r));
        }
        mousedown() {
          this._delayContextMenu = !0;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Tr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(r) {
          this._delayContextMenu ? this._contextMenuEvent = r : this._map.fire(new Tr(r.type, this._map, r)), this._map.listens("contextmenu") && r.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class gu {
        constructor(r, o) {
          this._map = r, this._el = r.getCanvasContainer(), this._container = r.getContainer(), this._clickTolerance = o.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(r, o) {
          this.isEnabled() && r.shiftKey && r.button === 0 && (kt(), this._startPos = this._lastPos = o, this._active = !0);
        }
        mousemoveWindow(r, o) {
          if (!this._active) return;
          const u = o, d = this._startPos, f = this._lastPos;
          if (!d || !f || f.equals(u) || !this._box && u.dist(d) < this._clickTolerance) return;
          this._lastPos = u, this._box || (this._box = rt("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", r));
          const g = Math.min(d.x, u.x), x = Math.max(d.x, u.x), b = Math.min(d.y, u.y), M = Math.max(d.y, u.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = `translate(${g}px,${b}px)`, this._box.style.width = x - g + "px", this._box.style.height = M - b + "px");
          });
        }
        mouseupWindow(r, o) {
          if (!this._active) return;
          const u = this._startPos, d = o;
          if (u && r.button === 0) {
            if (this.reset(), It(), u.x !== d.x || u.y !== d.y) return this._map.fire(new s.Event("boxzoomend", { originalEvent: r })), { cameraAnimation: (f) => f.fitScreenCoordinates(u, d, this._map.getBearing(), { linear: !1 }) };
            this._fireEvent("boxzoomcancel", r);
          }
        }
        keydown(r) {
          this._active && r.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", r));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), Qt(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(r, o) {
          return this._map.fire(new s.Event(r, { originalEvent: o }));
        }
      }
      function zl(l, r) {
        const o = {};
        for (let u = 0; u < l.length; u++) o[l[u].identifier] = r[u];
        return o;
      }
      class ua {
        constructor(r) {
          this.reset(), this.numTouches = r.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
        }
        touchstart(r, o, u) {
          (this.centroid || u.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === 0 && (this.startTime = r.timeStamp), u.length === this.numTouches && (this.centroid = function(d) {
            const f = new s.Point(0, 0);
            for (const g of d) f._add(g);
            return f.div(d.length);
          }(o), this.touches = zl(u, o)));
        }
        touchmove(r, o, u) {
          if (this.aborted || !this.centroid) return;
          const d = zl(u, o);
          for (const f in this.touches) {
            const g = d[f];
            (!g || g.dist(this.touches[f]) > 30) && (this.aborted = !0);
          }
        }
        touchend(r, o, u) {
          if ((!this.centroid || r.timeStamp - this.startTime > 500) && (this.aborted = !0), u.length === 0) {
            const d = !this.aborted && this.centroid;
            if (this.reset(), d) return d;
          }
        }
      }
      class _c {
        constructor(r) {
          this.singleTap = new ua(r), this.numTaps = r.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(r, o, u) {
          this.singleTap.touchstart(r, o, u);
        }
        touchmove(r, o, u) {
          this.singleTap.touchmove(r, o, u);
        }
        touchend(r, o, u) {
          const d = this.singleTap.touchend(r, o, u);
          if (d) {
            const f = r.timeStamp - this.lastTime < 500, g = !this.lastTap || this.lastTap.dist(d) < 30;
            if (f && g || this.reset(), this.count++, this.lastTime = r.timeStamp, this.lastTap = d, this.count === this.numTaps) return this.reset(), d;
          }
        }
      }
      class Ah {
        constructor() {
          this._zoomIn = new _c({ numTouches: 1, numTaps: 2 }), this._zoomOut = new _c({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(r, o, u) {
          this._zoomIn.touchstart(r, o, u), this._zoomOut.touchstart(r, o, u);
        }
        touchmove(r, o, u) {
          this._zoomIn.touchmove(r, o, u), this._zoomOut.touchmove(r, o, u);
        }
        touchend(r, o, u) {
          const d = this._zoomIn.touchend(r, o, u), f = this._zoomOut.touchend(r, o, u);
          return d ? (this._active = !0, r.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (g) => g.easeTo({ duration: 300, zoom: g.getZoom() + 1, around: g.unproject(d) }, { originalEvent: r }) }) : f ? (this._active = !0, r.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (g) => g.easeTo({ duration: 300, zoom: g.getZoom() - 1, around: g.unproject(f) }, { originalEvent: r }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const yu = { 0: 1, 2: 2 };
      class ha {
        constructor(r) {
          this.reset(), this._clickTolerance = r.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(r, o) {
          return !1;
        }
        _move(r, o) {
          return {};
        }
        mousedown(r, o) {
          if (this._lastPoint) return;
          const u = ui(r);
          this._correctButton(r, u) && (this._lastPoint = o, this._eventButton = u);
        }
        mousemoveWindow(r, o) {
          const u = this._lastPoint;
          if (u) {
            if (r.preventDefault(), this._eventButton != null && function(d, f) {
              const g = yu[f];
              return d.buttons === void 0 || (d.buttons & g) !== g;
            }(r, this._eventButton)) this.reset();
            else if (this._moved || !(o.dist(u) < this._clickTolerance)) return this._moved = !0, this._lastPoint = o, this._move(u, o);
          }
        }
        mouseupWindow(r) {
          this._lastPoint && ui(r) === this._eventButton && (this._moved && It(), this.reset());
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class gc extends ha {
        mousedown(r, o) {
          super.mousedown(r, o), this._lastPoint && (this._active = !0);
        }
        _correctButton(r, o) {
          return o === 0 && !r.ctrlKey;
        }
        _move(r, o) {
          return { around: o, panDelta: o.sub(r) };
        }
      }
      class yc extends ha {
        _correctButton(r, o) {
          return o === 0 && r.ctrlKey || o === 2;
        }
        _move(r, o) {
          const u = 0.8 * (o.x - r.x);
          if (u) return this._active = !0, { bearingDelta: u };
        }
        contextmenu(r) {
          r.preventDefault();
        }
      }
      class xc extends ha {
        _correctButton(r, o) {
          return o === 0 && r.ctrlKey || o === 2;
        }
        _move(r, o) {
          const u = -0.5 * (o.y - r.y);
          if (u) return this._active = !0, { pitchDelta: u };
        }
        contextmenu(r) {
          r.preventDefault();
        }
      }
      class kl {
        constructor(r, o) {
          this._map = r, this._el = r.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = o.clickTolerance || 1, this.reset(), s.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new s.Point(0, 0);
        }
        touchstart(r, o, u) {
          return this._calculateTransform(r, o, u);
        }
        touchmove(r, o, u) {
          if (this._active && !(u.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (u.length === 1 && !s.isFullscreen()) return void this._showTouchPanBlockerAlert();
              this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return r.cancelable && r.preventDefault(), this._calculateTransform(r, o, u);
          }
        }
        touchend(r, o, u) {
          this._calculateTransform(r, o, u), this._active && u.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(r, o, u) {
          u.length > 0 && (this._active = !0);
          const d = zl(u, o), f = new s.Point(0, 0), g = new s.Point(0, 0);
          let x = 0;
          for (const M in d) {
            const S = d[M], P = this._touches[M];
            P && (f._add(S), g._add(S.sub(P)), x++, d[M] = S);
          }
          if (this._touches = d, x < this._minTouches || !g.mag()) return;
          const b = g.div(x);
          return this._sum._add(b), this._sum.mag() < this._clickTolerance ? void 0 : { around: f.div(x), panDelta: b };
        }
        enable() {
          this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = rt("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 500);
        }
      }
      class Ha {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, this._firstTwoTouches = void 0;
        }
        _start(r) {
        }
        _move(r, o, u) {
          return {};
        }
        touchstart(r, o, u) {
          this._firstTwoTouches || u.length < 2 || (this._firstTwoTouches = [u[0].identifier, u[1].identifier], this._start([o[0], o[1]]));
        }
        touchmove(r, o, u) {
          const d = this._firstTwoTouches;
          if (!d) return;
          r.preventDefault();
          const [f, g] = d, x = Ka(u, o, f), b = Ka(u, o, g);
          if (!x || !b) return;
          const M = this._aroundCenter ? null : x.add(b).div(2);
          return this._move([x, b], M, r);
        }
        touchend(r, o, u) {
          if (!this._firstTwoTouches) return;
          const [d, f] = this._firstTwoTouches, g = Ka(u, o, d), x = Ka(u, o, f);
          g && x || (this._active && It(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(r) {
          this._enabled = !0, this._aroundCenter = !!r && r.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Ka(l, r, o) {
        for (let u = 0; u < l.length; u++) if (l[u].identifier === o) return r[u];
      }
      function vc(l, r) {
        return Math.log(l / r) / Math.LN2;
      }
      class xu extends Ha {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(r) {
          this._startDistance = this._distance = r[0].dist(r[1]);
        }
        _move(r, o) {
          const u = this._distance;
          if (this._distance = r[0].dist(r[1]), this._active || !(Math.abs(vc(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: vc(this._distance, u), pinchAround: o };
        }
      }
      function bc(l, r) {
        return 180 * l.angleWith(r) / Math.PI;
      }
      class vu extends Ha {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(r) {
          this._startVector = this._vector = r[0].sub(r[1]), this._minDiameter = r[0].dist(r[1]);
        }
        _move(r, o) {
          const u = this._vector;
          if (this._vector = r[0].sub(r[1]), u && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, { bearingDelta: bc(this._vector, u), pinchAround: o };
        }
        _isBelowThreshold(r) {
          this._minDiameter = Math.min(this._minDiameter, r.mag());
          const o = 25 / (Math.PI * this._minDiameter) * 360, u = this._startVector;
          if (!u) return !1;
          const d = bc(r, u);
          return Math.abs(d) < o;
        }
      }
      function ds(l) {
        return Math.abs(l.y) > Math.abs(l.x);
      }
      class bu extends Ha {
        constructor(r) {
          super(), this._map = r;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(r) {
          this._lastPoints = r, ds(r[0].sub(r[1])) && (this._valid = !1);
        }
        _move(r, o, u) {
          const d = this._lastPoints;
          if (!d) return;
          const f = r[0].sub(d[0]), g = r[1].sub(d[1]);
          return this._map._cooperativeGestures && !s.isFullscreen() && u.touches.length < 3 || (this._valid = this.gestureBeginsVertically(f, g, u.timeStamp), !this._valid) ? void 0 : (this._lastPoints = r, this._active = !0, { pitchDelta: (f.y + g.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(r, o, u) {
          if (this._valid !== void 0) return this._valid;
          const d = r.mag() >= 2, f = o.mag() >= 2;
          if (!d && !f) return;
          if (!d || !f) return this._firstMove == null && (this._firstMove = u), u - this._firstMove < 100 && void 0;
          const g = r.y > 0 == o.y > 0;
          return ds(r) && ds(o) && g;
        }
      }
      const wu = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Ih {
        constructor() {
          const r = wu;
          this._panStep = r.panStep, this._bearingStep = r.bearingStep, this._pitchStep = r.pitchStep, this._rotationDisabled = !1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        keydown(r) {
          if (r.altKey || r.ctrlKey || r.metaKey) return;
          let o = 0, u = 0, d = 0, f = 0, g = 0;
          switch (r.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              o = 1;
              break;
            case 189:
            case 109:
            case 173:
              o = -1;
              break;
            case 37:
              r.shiftKey ? u = -1 : (r.preventDefault(), f = -1);
              break;
            case 39:
              r.shiftKey ? u = 1 : (r.preventDefault(), f = 1);
              break;
            case 38:
              r.shiftKey ? d = 1 : (r.preventDefault(), g = -1);
              break;
            case 40:
              r.shiftKey ? d = -1 : (r.preventDefault(), g = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (u = 0, d = 0), { cameraAnimation: (x) => {
            const b = x.getZoom();
            x.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Tu, zoom: o ? Math.round(b) + o * (r.shiftKey ? 2 : 1) : b, bearing: x.getBearing() + u * this._bearingStep, pitch: x.getPitch() + d * this._pitchStep, offset: [-f * this._panStep, -g * this._panStep], center: x.getCenter() }, { originalEvent: r });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Tu(l) {
        return l * (2 - l);
      }
      const wc = 4.000244140625;
      class Eu {
        constructor(r, o) {
          this._map = r, this._el = r.getCanvasContainer(), this._handler = o, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, s.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(r) {
          this._defaultZoomRate = r;
        }
        setWheelZoomRate(r) {
          this._wheelZoomRate = r;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(r) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!r && r.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(r) {
          if (!this.isEnabled()) return;
          if (this._map._cooperativeGestures) {
            if (!(r.ctrlKey || r.metaKey || this.isZooming() || s.isFullscreen())) return void this._showBlockerAlert();
            this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let o = r.deltaMode === s.window.WheelEvent.DOM_DELTA_LINE ? 40 * r.deltaY : r.deltaY;
          const u = s.exported.now(), d = u - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = u, o !== 0 && o % wc == 0 ? this._type = "wheel" : o !== 0 && Math.abs(o) < 4 ? this._type = "trackpad" : d > 400 ? (this._type = null, this._lastValue = o, this._timeout = setTimeout(this._onTimeout, 40, r)) : this._type || (this._type = Math.abs(d * o) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, o += this._lastValue)), r.shiftKey && o && (o /= 4), this._type && (this._lastWheelEvent = r, this._delta -= o, this._active || this._start(r)), r.preventDefault();
        }
        _onTimeout(r) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(r);
        }
        _start(r) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const o = ni(this._el, r);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : o, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const r = this._map.transform;
          this._type === "wheel" && r.projection.wrap && (r._center.lng >= 180 || r._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
          const o = () => r._terrainEnabled() && this._aroundCoord ? r.computeZoomRelativeTo(this._aroundCoord) : r.zoom;
          if (this._delta !== 0) {
            const b = this._type === "wheel" && Math.abs(this._delta) > wc ? this._wheelZoomRate : this._defaultZoomRate;
            let M = 2 / (1 + Math.exp(-Math.abs(this._delta * b)));
            this._delta < 0 && M !== 0 && (M = 1 / M);
            const S = o(), P = Math.pow(2, S), F = typeof this._targetZoom == "number" ? r.zoomScale(this._targetZoom) : P;
            this._targetZoom = Math.min(r.maxZoom, Math.max(r.minZoom, r.scaleZoom(F * M))), this._type === "wheel" && (this._startZoom = S, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const u = typeof this._targetZoom == "number" ? this._targetZoom : o(), d = this._startZoom, f = this._easing;
          let g, x = !1;
          if (this._type === "wheel" && d && f) {
            const b = Math.min((s.exported.now() - this._lastWheelEventTime) / 200, 1), M = f(b);
            g = s.number(d, u, M), b < 1 ? this._frameId || (this._frameId = !0) : x = !0;
          } else g = u, x = !0;
          return this._active = !0, x && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !x, zoomDelta: g - o(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(r) {
          let o = s.ease;
          if (this._prevEase) {
            const u = this._prevEase, d = (s.exported.now() - u.start) / u.duration, f = u.easing(d + 0.01) - u.easing(d), g = 0.27 / Math.sqrt(f * f + 1e-4) * 0.01, x = Math.sqrt(0.0729 - g * g);
            o = s.bezier(g, x, 0.25, 1);
          }
          return this._prevEase = { start: s.exported.now(), duration: r, easing: o }, o;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = rt("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(s.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 200);
        }
      }
      class Su {
        constructor(r, o) {
          this._clickZoom = r, this._tapZoom = o;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class jr {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        blur() {
          this.reset();
        }
        dblclick(r, o) {
          return r.preventDefault(), { cameraAnimation: (u) => {
            u.easeTo({ duration: 300, zoom: u.getZoom() + (r.shiftKey ? -1 : 1), around: u.unproject(o) }, { originalEvent: r });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ph {
        constructor() {
          this._tap = new _c({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(r, o, u) {
          this._swipePoint || (this._tapTime && r.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? u.length > 0 && (this._swipePoint = o[0], this._swipeTouch = u[0].identifier) : this._tap.touchstart(r, o, u));
        }
        touchmove(r, o, u) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (u[0].identifier !== this._swipeTouch) return;
              const d = o[0], f = d.y - this._swipePoint.y;
              return this._swipePoint = d, r.preventDefault(), this._active = !0, { zoomDelta: f / 128 };
            }
          } else this._tap.touchmove(r, o, u);
        }
        touchend(r, o, u) {
          this._tapTime ? this._swipePoint && u.length === 0 && this.reset() : this._tap.touchend(r, o, u) && (this._tapTime = r.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Mu {
        constructor(r, o, u) {
          this._el = r, this._mousePan = o, this._touchPan = u;
        }
        enable(r) {
          this._inertiaOptions = r || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class Lh {
        constructor(r, o, u) {
          this._pitchWithRotate = r.pitchWithRotate, this._mouseRotate = o, this._mousePitch = u;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class zh {
        constructor(r, o, u, d) {
          this._el = r, this._touchZoom = o, this._touchRotate = u, this._tapDragZoom = d, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(r) {
          this._touchZoom.enable(r), this._rotationDisabled || this._touchRotate.enable(r), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const zn = (l) => l.zoom || l.drag || l.pitch || l.rotate;
      class Cu extends s.Event {
      }
      class kh {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(r, o) {
          const u = s.sub([], o, r);
          this.radius = s.length(u[2] < 0 ? s.div([], u, this.constants) : [u[0], u[1], 0]);
        }
        projectRay(r) {
          s.div(r, r, this.constants), s.normalize(r, r), s.mul$1(r, r, this.constants);
          const o = s.scale$2([], r, this.radius);
          if (o[2] > 0) {
            const u = s.scale$2([], [0, 0, 1], s.dot(o, [0, 0, 1])), d = s.scale$2([], s.normalize([], [o[0], o[1], 0]), this.radius), f = s.add([], o, s.scale$2([], s.sub([], s.add([], d, u), o), 2));
            o[0] = f[0], o[1] = f[1];
          }
          return o;
        }
      }
      function io(l) {
        return l.panDelta && l.panDelta.mag() || l.zoomDelta || l.bearingDelta || l.pitchDelta;
      }
      class To {
        constructor(r, o) {
          this._map = r, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new _u(r), this._bearingSnap = o.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new kh(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(o), s.bindAll(["handleEvent", "handleWindowEvent"], this);
          const u = this._el;
          this._listeners = [[u, "touchstart", { passive: !0 }], [u, "touchmove", { passive: !1 }], [u, "touchend", void 0], [u, "touchcancel", void 0], [u, "mousedown", void 0], [u, "mousemove", void 0], [u, "mouseup", void 0], [s.window.document, "mousemove", { capture: !0 }], [s.window.document, "mouseup", void 0], [u, "mouseover", void 0], [u, "mouseout", void 0], [u, "dblclick", void 0], [u, "click", void 0], [u, "keydown", { capture: !1 }], [u, "keyup", void 0], [u, "wheel", { passive: !1 }], [u, "contextmenu", void 0], [s.window, "blur", void 0]];
          for (const [d, f, g] of this._listeners) d.addEventListener(f, d === s.window.document ? this.handleWindowEvent : this.handleEvent, g);
        }
        destroy() {
          for (const [r, o, u] of this._listeners) r.removeEventListener(o, r === s.window.document ? this.handleWindowEvent : this.handleEvent, u);
        }
        _addDefaultHandlers(r) {
          const o = this._map, u = o.getCanvasContainer();
          this._add("mapEvent", new mc(o, r));
          const d = o.boxZoom = new gu(o, r);
          this._add("boxZoom", d);
          const f = new Ah(), g = new jr();
          o.doubleClickZoom = new Su(g, f), this._add("tapZoom", f), this._add("clickZoom", g);
          const x = new Ph();
          this._add("tapDragZoom", x);
          const b = o.touchPitch = new bu(o);
          this._add("touchPitch", b);
          const M = new yc(r), S = new xc(r);
          o.dragRotate = new Lh(r, M, S), this._add("mouseRotate", M, ["mousePitch"]), this._add("mousePitch", S, ["mouseRotate"]);
          const P = new gc(r), F = new kl(o, r);
          o.dragPan = new Mu(u, P, F), this._add("mousePan", P), this._add("touchPan", F, ["touchZoom", "touchRotate"]);
          const j = new vu(), $ = new xu();
          o.touchZoomRotate = new zh(u, $, j, x), this._add("touchRotate", j, ["touchPan", "touchZoom"]), this._add("touchZoom", $, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new Ll(o));
          const G = o.scrollZoom = new Eu(o, this);
          this._add("scrollZoom", G, ["mousePan"]);
          const Z = o.keyboard = new Ih();
          this._add("keyboard", Z);
          for (const L of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) r.interactive && r[L] && o[L].enable(r[L]);
        }
        _add(r, o, u) {
          this._handlers.push({ handlerName: r, handler: o, allowed: u }), this._handlersById[r] = o;
        }
        stop(r) {
          if (!this._updatingCamera) {
            for (const { handler: o } of this._handlers) o.reset();
            this._inertia.clear(), this._fireEvents({}, {}, r), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: r } of this._handlers) if (r.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!zn(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(r, o, u) {
          for (const d in r) if (d !== u && (!o || o.indexOf(d) < 0)) return !0;
          return !1;
        }
        handleWindowEvent(r) {
          this.handleEvent(r, `${r.type}Window`);
        }
        _getMapTouches(r) {
          const o = [];
          for (const u of r) this._el.contains(u.target) && o.push(u);
          return o;
        }
        handleEvent(r, o) {
          this._updatingCamera = !0;
          const u = r.type === "renderFrame", d = u ? void 0 : r, f = { needsRenderFrame: !1 }, g = {}, x = {}, b = r.touches ? this._getMapTouches(r.touches) : void 0, M = b ? Qr(this._el, b) : u ? void 0 : ni(this._el, r);
          for (const { handlerName: F, handler: j, allowed: $ } of this._handlers) {
            if (!j.isEnabled()) continue;
            let G;
            this._blockedByActive(x, $, F) ? j.reset() : j[o || r.type] && (G = j[o || r.type](r, M, b), this.mergeHandlerResult(f, g, G, F, d), G && G.needsRenderFrame && this._triggerRenderFrame()), (G || j.isActive()) && (x[F] = j);
          }
          const S = {};
          for (const F in this._previousActiveHandlers) x[F] || (S[F] = d);
          this._previousActiveHandlers = x, (Object.keys(S).length || io(f)) && (this._changes.push([f, g, S]), this._triggerRenderFrame()), (Object.keys(x).length || io(f)) && this._map._stop(!0), this._updatingCamera = !1;
          const { cameraAnimation: P } = f;
          P && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], P(this._map));
        }
        mergeHandlerResult(r, o, u, d, f) {
          if (!u) return;
          s.extend(r, u);
          const g = { handlerName: d, originalEvent: u.originalEvent || f };
          u.zoomDelta !== void 0 && (o.zoom = g), u.panDelta !== void 0 && (o.drag = g), u.pitchDelta !== void 0 && (o.pitch = g), u.bearingDelta !== void 0 && (o.rotate = g);
        }
        _applyChanges() {
          const r = {}, o = {}, u = {};
          for (const [d, f, g] of this._changes) d.panDelta && (r.panDelta = (r.panDelta || new s.Point(0, 0))._add(d.panDelta)), d.zoomDelta && (r.zoomDelta = (r.zoomDelta || 0) + d.zoomDelta), d.bearingDelta && (r.bearingDelta = (r.bearingDelta || 0) + d.bearingDelta), d.pitchDelta && (r.pitchDelta = (r.pitchDelta || 0) + d.pitchDelta), d.around !== void 0 && (r.around = d.around), d.aroundCoord !== void 0 && (r.aroundCoord = d.aroundCoord), d.pinchAround !== void 0 && (r.pinchAround = d.pinchAround), d.noInertia && (r.noInertia = d.noInertia), s.extend(o, f), s.extend(u, g);
          this._updateMapTransform(r, o, u), this._changes = [];
        }
        _updateMapTransform(r, o, u) {
          const d = this._map, f = d.transform, g = (N) => [N.x, N.y, N.z];
          if (((N) => {
            const X = this._eventsInProgress.drag;
            return X && !this._handlersById[X.handlerName].isActive();
          })() && !io(r)) {
            const N = f.zoom;
            f.cameraElevationReference = "sea", f.recenterOnTerrain(), f.cameraElevationReference = "ground", N !== f.zoom && this._map._update(!0);
          }
          if (f._isCameraConstrained && d._stop(!0), !io(r)) return void this._fireEvents(o, u, !0);
          let { panDelta: x, zoomDelta: b, bearingDelta: M, pitchDelta: S, around: P, aroundCoord: F, pinchAround: j } = r;
          f._isCameraConstrained && (b > 0 && (b = 0), f._isCameraConstrained = !1), j !== void 0 && (P = j), (b || ((N) => o[N] && !this._eventsInProgress[N])("drag")) && P && (this._dragOrigin = g(f.pointCoordinate3D(P)), this._trackingEllipsoid.setup(f._camera.position, this._dragOrigin)), f.cameraElevationReference = "sea", d._stop(!0), P = P || d.transform.centerPoint, M && (f.bearing += M), S && (f.pitch += S), f._updateCameraState();
          const $ = [0, 0, 0];
          if (x) if (f.projection.name === "mercator") {
            const N = this._trackingEllipsoid.projectRay(f.screenPointToMercatorRay(P).dir), X = this._trackingEllipsoid.projectRay(f.screenPointToMercatorRay(P.sub(x)).dir);
            $[0] = X[0] - N[0], $[1] = X[1] - N[1];
          } else {
            const N = f.pointCoordinate(P);
            if (f.projection.name === "globe") {
              x = x.rotate(-f.angle);
              const X = f._pixelsPerMercatorPixel / f.worldSize;
              $[0] = -x.x * s.mercatorScale(s.latFromMercatorY(N.y)) * X, $[1] = -x.y * s.mercatorScale(f.center.lat) * X;
            } else {
              const X = f.pointCoordinate(P.sub(x));
              N && X && ($[0] = X.x - N.x, $[1] = X.y - N.y);
            }
          }
          const G = f.zoom, Z = [0, 0, 0];
          if (b) {
            const N = g(F || f.pointCoordinate3D(P)), X = { dir: s.normalize([], s.sub([], N, f._camera.position)) };
            if (X.dir[2] < 0) {
              const K = f.zoomDeltaToMovement(N, b);
              s.scale$2(Z, X.dir, K);
            }
          }
          const L = s.add($, $, Z);
          f._translateCameraConstrained(L), b && Math.abs(f.zoom - G) > 1e-4 && f.recenterOnTerrain(), f.cameraElevationReference = "ground", this._map._update(), r.noInertia || this._inertia.record(r), this._fireEvents(o, u, !0);
        }
        _fireEvents(r, o, u) {
          const d = zn(this._eventsInProgress), f = zn(r), g = {};
          for (const S in r) {
            const { originalEvent: P } = r[S];
            this._eventsInProgress[S] || (g[`${S}start`] = P), this._eventsInProgress[S] = r[S];
          }
          !d && f && this._fireEvent("movestart", f.originalEvent);
          for (const S in g) this._fireEvent(S, g[S]);
          f && this._fireEvent("move", f.originalEvent);
          for (const S in r) {
            const { originalEvent: P } = r[S];
            this._fireEvent(S, P);
          }
          const x = {};
          let b;
          for (const S in this._eventsInProgress) {
            const { handlerName: P, originalEvent: F } = this._eventsInProgress[S];
            this._handlersById[P].isActive() || (delete this._eventsInProgress[S], b = o[P] || F, x[`${S}end`] = b);
          }
          for (const S in x) this._fireEvent(S, x[S]);
          const M = zn(this._eventsInProgress);
          if (u && (d || f) && !M) {
            this._updatingCamera = !0;
            const S = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), P = (F) => F !== 0 && -this._bearingSnap < F && F < this._bearingSnap;
            S ? (P(S.bearing || this._map.getBearing()) && (S.bearing = 0), this._map.easeTo(S, { originalEvent: b })) : (this._map.fire(new s.Event("moveend", { originalEvent: b })), P(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
          }
        }
        _fireEvent(r, o) {
          this._map.fire(new s.Event(r, o ? { originalEvent: o } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((r) => {
            this._frameId = void 0, this.handleEvent(new Cu("renderFrame", { timeStamp: r })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      const Bs = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class Dl extends s.Evented {
        constructor(r, o) {
          super(), this._moving = !1, this._zooming = !1, this.transform = r, this._bearingSnap = o.bearingSnap, this._respectPrefersReducedMotion = o.respectPrefersReducedMotion !== !1, s.bindAll(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new s.LngLat(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(r, o) {
          return this.jumpTo({ center: r }, o);
        }
        panBy(r, o, u) {
          return r = s.Point.convert(r).mult(-1), this.panTo(this.transform.center, s.extend({ offset: r }, o), u);
        }
        panTo(r, o, u) {
          return this.easeTo(s.extend({ center: r }, o), u);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(r, o) {
          return this.jumpTo({ zoom: r }, o), this;
        }
        zoomTo(r, o, u) {
          return this.easeTo(s.extend({ zoom: r }, o), u);
        }
        zoomIn(r, o) {
          return this.zoomTo(this.getZoom() + 1, r, o), this;
        }
        zoomOut(r, o) {
          return this.zoomTo(this.getZoom() - 1, r, o), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(r, o) {
          return this.jumpTo({ bearing: r }, o), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(r, o) {
          return this.jumpTo({ padding: r }, o), this;
        }
        rotateTo(r, o, u) {
          return this.easeTo(s.extend({ bearing: r }, o), u);
        }
        resetNorth(r, o) {
          return this.rotateTo(0, s.extend({ duration: 1e3 }, r), o), this;
        }
        resetNorthPitch(r, o) {
          return this.easeTo(s.extend({ bearing: 0, pitch: 0, duration: 1e3 }, r), o), this;
        }
        snapToNorth(r, o) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(r, o) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(r, o) {
          return this.jumpTo({ pitch: r }, o), this;
        }
        cameraForBounds(r, o) {
          r = s.LngLatBounds.convert(r);
          const u = o && o.bearing || 0, d = o && o.pitch || 0, f = r.getNorthWest(), g = r.getSouthEast();
          return this._cameraForBounds(this.transform, f, g, u, d, o);
        }
        _extendCameraOptions(r) {
          const o = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (r = s.extend({ padding: o, offset: [0, 0], maxZoom: this.transform.maxZoom }, r)).padding == "number") {
            const u = r.padding;
            r.padding = { top: u, bottom: u, right: u, left: u };
          }
          return r.padding = s.extend(o, r.padding), r;
        }
        _minimumAABBFrustumDistance(r, o) {
          const u = o.max[0] - o.min[0], d = o.max[1] - o.min[1];
          return u / d > r.aspect ? u / (2 * Math.tan(0.5 * r.fovX) * r.aspect) : d / (2 * Math.tan(0.5 * r.fovY) * r.aspect);
        }
        _cameraForBoundsOnGlobe(r, o, u, d, f, g) {
          const x = r.clone(), b = this._extendCameraOptions(g);
          x.bearing = d, x.pitch = f;
          const M = s.LngLat.convert(o), S = s.LngLat.convert(u), P = 0.5 * (M.lat + S.lat), F = 0.5 * (M.lng + S.lng), j = s.latLngToECEF(P, F), $ = s.normalize([], j), G = s.normalize([], s.cross([], $, [0, 1, 0])), Z = s.cross([], G, $), L = [G[0], G[1], G[2], 0, Z[0], Z[1], Z[2], 0, $[0], $[1], $[2], 0, 0, 0, 0, 1], N = [j, s.latLngToECEF(M.lat, M.lng), s.latLngToECEF(S.lat, M.lng), s.latLngToECEF(S.lat, S.lng), s.latLngToECEF(M.lat, S.lng), s.latLngToECEF(P, M.lng), s.latLngToECEF(P, S.lng), s.latLngToECEF(M.lat, F), s.latLngToECEF(S.lat, F)];
          let X = s.Aabb.fromPoints(N.map((Ne) => [s.dot(G, Ne), s.dot(Z, Ne), s.dot($, Ne)]));
          const K = s.transformMat4([], X.center, L);
          s.squaredLength(K) === 0 && s.set(K, 0, 0, 1), s.normalize(K, K), s.scale$2(K, K, s.GLOBE_RADIUS), x.center = s.ecefToLatLng(K);
          const le = x.getWorldToCameraMatrix(), ue = s.invert(new Float64Array(16), le);
          X = s.Aabb.applyTransform(X, s.multiply([], le, L)), s.transformMat4(K, K, le);
          const ce = 0.5 * (X.max[2] - X.min[2]), ge = this._minimumAABBFrustumDistance(x, X), me = s.scale$2([], [0, 0, 1], ce), Ee = s.add(me, K, me), Ge = ge + (x.pitch === 0 ? 0 : s.distance(K, Ee)), be = x.globeCenterInViewSpace, Oe = s.sub([], K, [be[0], be[1], be[2]]);
          s.normalize(Oe, Oe), s.scale$2(Oe, Oe, Ge);
          const Ce = s.add([], K, Oe);
          s.transformMat4(Ce, Ce, ue);
          const Ve = s.earthRadius / s.GLOBE_RADIUS, Te = s.length(Ce), Re = s.mercatorZfromAltitude(Math.max(Te * Ve - s.earthRadius, Number.EPSILON), 0), We = Math.min(x.zoomFromMercatorZAdjusted(Re), b.maxZoom);
          return We > 0.5 * (s.GLOBE_ZOOM_THRESHOLD_MIN + s.GLOBE_ZOOM_THRESHOLD_MAX) ? (x.setProjection({ name: "mercator" }), x.zoom = We, this._cameraForBounds(x, o, u, d, f, g)) : { center: x.center, zoom: We, bearing: d, pitch: f };
        }
        queryTerrainElevation(r, o) {
          const u = this.transform.elevation;
          return u ? (o = s.extend({}, { exaggerated: !0 }, o), u.getAtPoint(s.MercatorCoordinate.fromLngLat(r), null, o.exaggerated)) : null;
        }
        _cameraForBounds(r, o, u, d, f, g) {
          if (r.projection.name === "globe") return this._cameraForBoundsOnGlobe(r, o, u, d, f, g);
          const x = r.clone(), b = this._extendCameraOptions(g), M = x.padding;
          x.bearing = d, x.pitch = f;
          const S = s.LngLat.convert(o), P = s.LngLat.convert(u), F = new s.LngLat(S.lng, P.lat), j = new s.LngLat(P.lng, S.lat), $ = x.project(S), G = x.project(P), Z = this.queryTerrainElevation(S), L = this.queryTerrainElevation(P), N = this.queryTerrainElevation(F), X = this.queryTerrainElevation(j), K = [[$.x, $.y, Math.min(Z || 0, L || 0, N || 0, X || 0)], [G.x, G.y, Math.max(Z || 0, L || 0, N || 0, X || 0)]];
          let le = s.Aabb.fromPoints(K);
          const ue = x.getWorldToCameraMatrix(), ce = s.invert(new Float64Array(16), ue);
          le = s.Aabb.applyTransform(le, ue);
          const ge = s.sub([], le.max, le.min), me = M.left || 0, Ee = M.right || 0, Ge = M.bottom || 0, be = M.top || 0, { left: Oe, right: Ce, top: Ve, bottom: Te } = b.padding, Re = 0.5 * (me + Ee), We = 0.5 * (be + Ge), Ne = Math.min(x.scaleZoom(x.scale * Math.min((x.width - (me + Ee + Oe + Ce)) / ge[0], (x.height - (Ge + be + Te + Ve)) / ge[1])), b.maxZoom), He = x.scale / x.zoomScale(Ne);
          le = new s.Aabb([le.min[0] - (Oe + Re) * He, le.min[1] - (Te + We) * He, le.min[2]], [le.max[0] + (Ce + Re) * He, le.max[1] + (Ve + We) * He, le.max[2]]);
          const wt = 0.5 * ge[2], Dt = this._minimumAABBFrustumDistance(x, le), gt = [0, 0, 1, 0];
          s.transformMat4$1(gt, gt, ue), s.normalize$2(gt, gt);
          const Ct = s.scale$2([], gt, Dt + wt), ti = s.add([], le.center, Ct), Yt = (typeof b.offset.x == "number" && typeof b.offset.y == "number" ? new s.Point(b.offset.x, b.offset.y) : s.Point.convert(b.offset)).rotate(-s.degToRad(d));
          le.center[0] -= Yt.x * He, le.center[1] += Yt.y * He, s.transformMat4(le.center, le.center, ce), s.transformMat4(ti, ti, ce);
          const vt = [le.center[0], le.center[1], ti[2] * x.pixelsPerMeter];
          s.scale$2(vt, vt, 1 / x.worldSize);
          const vi = s.lngFromMercatorX(vt[0]), Ti = s.latFromMercatorY(vt[1]), Ei = Math.min(x._zoomFromMercatorZ(vt[2]), b.maxZoom), Si = new s.LngLat(vi, Ti);
          return x.mercatorFromTransition && Ei < 0.5 * (s.GLOBE_ZOOM_THRESHOLD_MIN + s.GLOBE_ZOOM_THRESHOLD_MAX) ? (x.setProjection({ name: "globe" }), x.zoom = Ei, this._cameraForBounds(x, o, u, d, f, g)) : { center: Si, zoom: Ei, bearing: d, pitch: f };
        }
        fitBounds(r, o, u) {
          const d = this.cameraForBounds(r, o);
          return this._fitInternal(d, o, u);
        }
        fitScreenCoordinates(r, o, u, d, f) {
          const g = s.Point.convert(r), x = s.Point.convert(o), b = new s.Point(Math.min(g.x, x.x), Math.min(g.y, x.y)), M = new s.Point(Math.max(g.x, x.x), Math.max(g.y, x.y));
          if (this.transform.projection.name === "mercator" && this.transform.anyCornerOffEdge(g, x)) return this;
          const S = this.transform.pointLocation3D(b), P = this.transform.pointLocation3D(M), F = this.transform.pointLocation3D(new s.Point(b.x, M.y)), j = this.transform.pointLocation3D(new s.Point(M.x, b.y)), $ = [Math.min(S.lng, P.lng, F.lng, j.lng), Math.min(S.lat, P.lat, F.lat, j.lat)], G = [Math.max(S.lng, P.lng, F.lng, j.lng), Math.max(S.lat, P.lat, F.lat, j.lat)], Z = d && d.pitch ? d.pitch : this.getPitch(), L = this._cameraForBounds(this.transform, $, G, u, Z, d);
          return this._fitInternal(L, d, f);
        }
        _fitInternal(r, o, u) {
          return r ? (delete (o = s.extend(r, o)).padding, o.linear ? this.easeTo(o, u) : this.flyTo(o, u)) : this;
        }
        jumpTo(r, o) {
          this.stop();
          const u = r.preloadOnly ? this.transform.clone() : this.transform;
          let d = !1, f = !1, g = !1;
          return "zoom" in r && u.zoom !== +r.zoom && (d = !0, u.zoom = +r.zoom), r.center !== void 0 && (u.center = s.LngLat.convert(r.center)), "bearing" in r && u.bearing !== +r.bearing && (f = !0, u.bearing = +r.bearing), "pitch" in r && u.pitch !== +r.pitch && (g = !0, u.pitch = +r.pitch), r.padding == null || u.isPaddingEqual(r.padding) || (u.padding = r.padding), r.preloadOnly ? (this._preloadTiles(u), this) : (this.fire(new s.Event("movestart", o)).fire(new s.Event("move", o)), d && this.fire(new s.Event("zoomstart", o)).fire(new s.Event("zoom", o)).fire(new s.Event("zoomend", o)), f && this.fire(new s.Event("rotatestart", o)).fire(new s.Event("rotate", o)).fire(new s.Event("rotateend", o)), g && this.fire(new s.Event("pitchstart", o)).fire(new s.Event("pitch", o)).fire(new s.Event("pitchend", o)), this.fire(new s.Event("moveend", o)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || s.warnOnce(Bs), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(r, o) {
          const u = this.transform;
          if (!u.projection.supportsFreeCamera) return s.warnOnce(Bs), this;
          this.stop();
          const d = u.zoom, f = u.pitch, g = u.bearing;
          u.setFreeCameraOptions(r);
          const x = d !== u.zoom, b = f !== u.pitch, M = g !== u.bearing;
          return this.fire(new s.Event("movestart", o)).fire(new s.Event("move", o)), x && this.fire(new s.Event("zoomstart", o)).fire(new s.Event("zoom", o)).fire(new s.Event("zoomend", o)), M && this.fire(new s.Event("rotatestart", o)).fire(new s.Event("rotate", o)).fire(new s.Event("rotateend", o)), b && this.fire(new s.Event("pitchstart", o)).fire(new s.Event("pitch", o)).fire(new s.Event("pitchend", o)), this.fire(new s.Event("moveend", o)), this;
        }
        easeTo(r, o) {
          this._stop(!1, r.easeId), ((r = s.extend({ offset: [0, 0], duration: 500, easing: s.ease }, r)).animate === !1 || this._prefersReducedMotion(r)) && (r.duration = 0);
          const u = this.transform, d = this.getZoom(), f = this.getBearing(), g = this.getPitch(), x = this.getPadding(), b = "zoom" in r ? +r.zoom : d, M = "bearing" in r ? this._normalizeBearing(r.bearing, f) : f, S = "pitch" in r ? +r.pitch : g, P = "padding" in r ? r.padding : u.padding, F = s.Point.convert(r.offset);
          let j, $, G;
          if (u.projection.name === "globe") {
            const me = s.MercatorCoordinate.fromLngLat(u.center), Ee = F.rotate(-u.angle);
            me.x += Ee.x / u.worldSize, me.y += Ee.y / u.worldSize;
            const Ge = me.toLngLat(), be = s.LngLat.convert(r.center || Ge);
            this._normalizeCenter(be), j = u.centerPoint.add(Ee), $ = new s.Point(me.x, me.y).mult(u.worldSize), G = new s.Point(s.mercatorXfromLng(be.lng), s.mercatorYfromLat(be.lat)).mult(u.worldSize).sub($);
          } else {
            j = u.centerPoint.add(F);
            const me = u.pointLocation(j), Ee = s.LngLat.convert(r.center || me);
            this._normalizeCenter(Ee), $ = u.project(me), G = u.project(Ee).sub($);
          }
          const Z = u.zoomScale(b - d);
          let L, N;
          r.around && (L = s.LngLat.convert(r.around), N = u.locationPoint(L));
          const X = this._zooming || b !== d, K = this._rotating || f !== M, le = this._pitching || S !== g, ue = !u.isPaddingEqual(P), ce = (me) => (Ee) => {
            if (X && (me.zoom = s.number(d, b, Ee)), K && (me.bearing = s.number(f, M, Ee)), le && (me.pitch = s.number(g, S, Ee)), ue && (me.interpolatePadding(x, P, Ee), j = me.centerPoint.add(F)), L) me.setLocationAtPoint(L, N);
            else {
              const Ge = me.zoomScale(me.zoom - d), be = b > d ? Math.min(2, Z) : Math.max(0.5, Z), Oe = Math.pow(be, 1 - Ee), Ce = me.unproject($.add(G.mult(Ee * Oe)).mult(Ge));
              me.setLocationAtPoint(me.renderWorldCopies ? Ce.wrap() : Ce, j);
            }
            return r.preloadOnly || this._fireMoveEvents(o), me;
          };
          if (r.preloadOnly) {
            const me = this._emulate(ce, r.duration, u);
            return this._preloadTiles(me), this;
          }
          const ge = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = X, this._rotating = K, this._pitching = le, this._padding = ue, this._easeId = r.easeId, this._prepareEase(o, r.noMoveStart, ge), this._ease(ce(u), (me) => {
            u.recenterOnTerrain(), this._afterEase(o, me);
          }, r), this;
        }
        _prepareEase(r, o, u = {}) {
          this._moving = !0, this.transform.cameraElevationReference = "sea", o || u.moving || this.fire(new s.Event("movestart", r)), this._zooming && !u.zooming && this.fire(new s.Event("zoomstart", r)), this._rotating && !u.rotating && this.fire(new s.Event("rotatestart", r)), this._pitching && !u.pitching && this.fire(new s.Event("pitchstart", r));
        }
        _fireMoveEvents(r) {
          this.fire(new s.Event("move", r)), this._zooming && this.fire(new s.Event("zoom", r)), this._rotating && this.fire(new s.Event("rotate", r)), this._pitching && this.fire(new s.Event("pitch", r));
        }
        _afterEase(r, o) {
          if (this._easeId && o && this._easeId === o) return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const u = this._zooming, d = this._rotating, f = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, u && this.fire(new s.Event("zoomend", r)), d && this.fire(new s.Event("rotateend", r)), f && this.fire(new s.Event("pitchend", r)), this.fire(new s.Event("moveend", r));
        }
        flyTo(r, o) {
          if (this._prefersReducedMotion(r)) {
            const Ne = s.pick(r, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(Ne, o);
          }
          this.stop(), r = s.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.ease }, r);
          const u = this.transform, d = this.getZoom(), f = this.getBearing(), g = this.getPitch(), x = this.getPadding(), b = "zoom" in r ? s.clamp(+r.zoom, u.minZoom, u.maxZoom) : d, M = "bearing" in r ? this._normalizeBearing(r.bearing, f) : f, S = "pitch" in r ? +r.pitch : g, P = "padding" in r ? r.padding : u.padding, F = u.zoomScale(b - d), j = s.Point.convert(r.offset);
          let $ = u.centerPoint.add(j);
          const G = u.pointLocation($), Z = s.LngLat.convert(r.center || G);
          this._normalizeCenter(Z);
          const L = u.project(G), N = u.project(Z).sub(L);
          let X = r.curve;
          const K = Math.max(u.width, u.height), le = K / F, ue = N.mag();
          if ("minZoom" in r) {
            const Ne = s.clamp(Math.min(r.minZoom, d, b), u.minZoom, u.maxZoom), He = K / u.zoomScale(Ne - d);
            X = Math.sqrt(He / ue * 2);
          }
          const ce = X * X;
          function ge(Ne) {
            const He = (le * le - K * K + (Ne ? -1 : 1) * ce * ce * ue * ue) / (2 * (Ne ? le : K) * ce * ue);
            return Math.log(Math.sqrt(He * He + 1) - He);
          }
          function me(Ne) {
            return (Math.exp(Ne) - Math.exp(-Ne)) / 2;
          }
          function Ee(Ne) {
            return (Math.exp(Ne) + Math.exp(-Ne)) / 2;
          }
          const Ge = ge(0);
          let be = function(Ne) {
            return Ee(Ge) / Ee(Ge + X * Ne);
          }, Oe = function(Ne) {
            return K * ((Ee(Ge) * (me(He = Ge + X * Ne) / Ee(He)) - me(Ge)) / ce) / ue;
            var He;
          }, Ce = (ge(1) - Ge) / X;
          if (Math.abs(ue) < 1e-6 || !isFinite(Ce)) {
            if (Math.abs(K - le) < 1e-6) return this.easeTo(r, o);
            const Ne = le < K ? -1 : 1;
            Ce = Math.abs(Math.log(le / K)) / X, Oe = function() {
              return 0;
            }, be = function(He) {
              return Math.exp(Ne * X * He);
            };
          }
          r.duration = "duration" in r ? +r.duration : 1e3 * Ce / ("screenSpeed" in r ? +r.screenSpeed / X : +r.speed), r.maxDuration && r.duration > r.maxDuration && (r.duration = 0);
          const Ve = f !== M, Te = S !== g, Re = !u.isPaddingEqual(P), We = (Ne) => (He) => {
            const wt = He * Ce, Dt = 1 / be(wt);
            Ne.zoom = He === 1 ? b : d + Ne.scaleZoom(Dt), Ve && (Ne.bearing = s.number(f, M, He)), Te && (Ne.pitch = s.number(g, S, He)), Re && (Ne.interpolatePadding(x, P, He), $ = Ne.centerPoint.add(j));
            const gt = He === 1 ? Z : Ne.unproject(L.add(N.mult(Oe(wt))).mult(Dt));
            return Ne.setLocationAtPoint(Ne.renderWorldCopies ? gt.wrap() : gt, $), Ne._updateCameraOnTerrain(), r.preloadOnly || this._fireMoveEvents(o), Ne;
          };
          if (r.preloadOnly) {
            const Ne = this._emulate(We, r.duration, u);
            return this._preloadTiles(Ne), this;
          }
          return this._zooming = !0, this._rotating = Ve, this._pitching = Te, this._padding = Re, this._prepareEase(o, !1), this._ease(We(u), () => this._afterEase(o), r), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(r, o) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const u = this._onEaseEnd;
            this._onEaseEnd = void 0, u.call(this, o);
          }
          if (!r) {
            const u = this.handlers;
            u && u.stop(!1);
          }
          return this;
        }
        _ease(r, o, u) {
          u.animate === !1 || u.duration === 0 ? (r(1), o()) : (this._easeStart = s.exported.now(), this._easeOptions = u, this._onEaseFrame = r, this._onEaseEnd = o, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const r = Math.min((s.exported.now() - this._easeStart) / this._easeOptions.duration, 1), o = this._onEaseFrame;
          o && o(this._easeOptions.easing(r)), r < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(r, o) {
          r = s.wrap(r, -180, 180);
          const u = Math.abs(r - o);
          return Math.abs(r - 360 - o) < u && (r -= 360), Math.abs(r + 360 - o) < u && (r += 360), r;
        }
        _normalizeCenter(r) {
          const o = this.transform;
          if (!o.renderWorldCopies || o.maxBounds) return;
          const u = r.lng - o.center.lng;
          r.lng += u > 180 ? -360 : u < -180 ? 360 : 0;
        }
        _prefersReducedMotion(r) {
          return this._respectPrefersReducedMotion && s.exported.prefersReducedMotion && !(r && r.essential);
        }
        _emulate(r, o, u) {
          const d = Math.ceil(15 * o / 1e3), f = [], g = r(u.clone());
          for (let x = 0; x <= d; x++) {
            const b = g(x / d);
            f.push(b.clone());
          }
          return f;
        }
      }
      class _t {
        constructor(r = {}) {
          this.options = r, s.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(r) {
          const o = this.options && this.options.compact;
          return this._map = r, this._container = rt("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = rt("button", "mapboxgl-ctrl-attrib-button", this._container), rt("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = rt("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), o && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), o === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(r, o) {
          const u = this._map._getUIString(`AttributionControl.${o}`);
          r.setAttribute("aria-label", u), r.removeAttribute("title"), r.firstElementChild && r.firstElementChild.setAttribute("title", u);
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let r = this._editLink;
          r || (r = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const o = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || s.config.ACCESS_TOKEN }];
          if (r) {
            const u = o.reduce((d, f, g) => (f.value && (d += `${f.key}=${f.value}${g < o.length - 1 ? "&" : ""}`), d), "?");
            r.href = `${s.config.FEEDBACK_URL}/${u}#${$a(this._map, !0)}`, r.rel = "noopener nofollow", this._setElementTitle(r, "MapFeedback");
          }
        }
        _updateData(r) {
          !r || r.sourceDataType !== "metadata" && r.sourceDataType !== "visibility" && r.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let r = [];
          if (this._map.style.stylesheet) {
            const d = this._map.style.stylesheet;
            this.styleOwner = d.owner, this.styleId = d.id;
          }
          const o = this._map.style._sourceCaches;
          for (const d in o) {
            const f = o[d];
            if (f.used) {
              const g = f.getSource();
              g.attribution && r.indexOf(g.attribution) < 0 && r.push(g.attribution);
            }
          }
          r.sort((d, f) => d.length - f.length), r = r.filter((d, f) => {
            for (let g = f + 1; g < r.length; g++) if (r[g].indexOf(d) >= 0) return !1;
            return !0;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? r = [...this.options.customAttribution, ...r] : r.unshift(this.options.customAttribution));
          const u = r.join(" | ");
          u !== this._attribHTML && (this._attribHTML = u, r.length ? (this._innerContainer.innerHTML = u, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class Tc {
        constructor() {
          s.bindAll(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(r) {
          this._map = r, this._container = rt("div", "mapboxgl-ctrl");
          const o = rt("a", "mapboxgl-ctrl-logo");
          return o.target = "_blank", o.rel = "noopener nofollow", o.href = "https://www.mapbox.com/", o.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), o.setAttribute("rel", "noopener nofollow"), this._container.appendChild(o), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(r) {
          r && r.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style) return !0;
          const r = this._map.style._sourceCaches;
          if (Object.entries(r).length === 0) return !0;
          for (const o in r) {
            const u = r[o].getSource();
            if (u.hasOwnProperty("mapbox_logo") && !u.mapbox_logo) return !1;
          }
          return !0;
        }
        _updateCompact() {
          const r = this._container.children;
          if (r.length) {
            const o = r[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? o.classList.add("mapboxgl-compact") : o.classList.remove("mapboxgl-compact");
          }
        }
      }
      class Ec {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(r) {
          const o = ++this._id;
          return this._queue.push({ callback: r, id: o, cancelled: !1 }), o;
        }
        remove(r) {
          const o = this._currentlyRunning, u = o ? this._queue.concat(o) : this._queue;
          for (const d of u) if (d.id === r) return void (d.cancelled = !0);
        }
        run(r = 0) {
          const o = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const u of o) if (!u.cancelled && (u.callback(r), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      function da(l, r, o) {
        if (l = new s.LngLat(l.lng, l.lat), r) {
          const u = new s.LngLat(l.lng - 360, l.lat), d = new s.LngLat(l.lng + 360, l.lat), f = 360 * Math.ceil(Math.abs(l.lng - o.center.lng) / 360), g = o.locationPoint(l).distSqr(r), x = r.x < 0 || r.y < 0 || r.x > o.width || r.y > o.height;
          o.locationPoint(u).distSqr(r) < g && (x || Math.abs(u.lng - o.center.lng) < f) ? l = u : o.locationPoint(d).distSqr(r) < g && (x || Math.abs(d.lng - o.center.lng) < f) && (l = d);
        }
        for (; Math.abs(l.lng - o.center.lng) > 180; ) {
          const u = o.locationPoint(l);
          if (u.x >= 0 && u.y >= 0 && u.x <= o.width && u.y <= o.height) break;
          l.lng > o.center.lng ? l.lng -= 360 : l.lng += 360;
        }
        return l;
      }
      const Fs = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class ct extends s.Evented {
        constructor(r, o) {
          if (super(), (r instanceof s.window.HTMLElement || o) && (r = s.extend({ element: r }, o)), s.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = r && r.anchor || "center", this._color = r && r.color || "#3FB1CE", this._scale = r && r.scale || 1, this._draggable = r && r.draggable || !1, this._clickTolerance = r && r.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = r && r.rotation || 0, this._rotationAlignment = r && r.rotationAlignment || "auto", this._pitchAlignment = r && r.pitchAlignment && r.pitchAlignment || "auto", this._updateMoving = () => this._update(!0), this._occludedOpacity = r && r.occludedOpacity || 0.2, r && r.element) this._element = r.element, this._offset = s.Point.convert(r && r.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = rt("div");
            const d = 41, f = 27, g = ut("svg", { display: "block", height: d * this._scale + "px", width: f * this._scale + "px", viewBox: `0 0 ${f} ${d}` }, this._element), x = ut("radialGradient", { id: "shadowGradient" }, ut("defs", {}, g));
            ut("stop", { offset: "10%", "stop-opacity": 0.4 }, x), ut("stop", { offset: "100%", "stop-opacity": 0.05 }, x), ut("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, g), ut("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, g), ut("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, g), ut("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, g), this._offset = s.Point.convert(r && r.offset || [0, -14]);
          }
          this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (d) => {
            d.preventDefault();
          }), this._element.addEventListener("mousedown", (d) => {
            d.preventDefault();
          });
          const u = this._element.classList;
          for (const d in Fs) u.remove(`mapboxgl-marker-anchor-${d}`);
          u.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
        }
        addTo(r) {
          return r === this._map || (this.remove(), this._map = r, r.getCanvasContainer().appendChild(this._element), r.on("move", this._updateMoving), r.on("moveend", this._update), r.on("remove", this._clearFadeTimer), r._addMarker(this), this.setDraggable(this._draggable), this._update(), r.on("click", this._onMapClick)), this;
        }
        remove() {
          const r = this._map;
          return r && (r.off("click", this._onMapClick), r.off("move", this._updateMoving), r.off("moveend", this._update), r.off("mousedown", this._addDragHandler), r.off("touchstart", this._addDragHandler), r.off("mouseup", this._onUp), r.off("touchend", this._onUp), r.off("mousemove", this._onMove), r.off("touchmove", this._onMove), r.off("remove", this._clearFadeTimer), r._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(r) {
          return this._lngLat = s.LngLat.convert(r), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(r) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), r) {
            if (!("offset" in r.options)) {
              const d = Math.sqrt(Math.pow(13.5, 2) / 2);
              r.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [d, -1 * (38.1 - 13.5 + d)], "bottom-right": [-d, -1 * (38.1 - 13.5 + d)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = r, r._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(r) {
          const o = r.code, u = r.charCode || r.keyCode;
          o !== "Space" && o !== "Enter" && u !== 32 && u !== 13 || this.togglePopup();
        }
        _onMapClick(r) {
          const o = r.originalEvent.target, u = this._element;
          this._popup && (o === u || u.contains(o)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const r = this._popup;
          return r ? (r.isOpen() ? (r.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (r.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const r = this._map, o = this._pos;
          if (!r || !o) return !1;
          const u = r.unproject(o), d = r.getFreeCameraOptions();
          if (!d.position) return !1;
          const f = d.position.toLngLat();
          return f.distanceTo(u) < 0.9 * f.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const r = this._map;
          if (!r) return;
          const o = this._pos;
          if (!o || o.x < 0 || o.x > r.transform.width || o.y < 0 || o.y > r.transform.height) return void this._clearFadeTimer();
          const u = r.unproject(o);
          let d;
          r._showingGlobe() && s.isLngLatBehindGlobe(r.transform, this._lngLat) ? d = 0 : (d = 1 - r._queryFogOpacity(u), r.transform._terrainEnabled() && r.getTerrain() && this._behindTerrain() && (d *= this._occludedOpacity)), this._element.style.opacity = `${d}`, this._element.style.pointerEvents = d > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(d), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const r = this._pos;
          if (!r || !this._map) return;
          const o = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${r.x}px,${r.y}px)
            ${Fs[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${o.x}px,${o.y}px)
        `;
        }
        _calculateXYTransform() {
          const r = this._pos, o = this._map, u = this.getPitchAlignment();
          if (!o || !r || u !== "map") return "";
          if (!o._showingGlobe()) {
            const b = o.getPitch();
            return b ? `rotateX(${b}deg)` : "";
          }
          const d = s.radToDeg(s.globeTiltAtLngLat(o.transform, this._lngLat)), f = r.sub(s.globeCenterToScreenPoint(o.transform)), g = Math.abs(f.x) + Math.abs(f.y);
          if (g === 0) return "";
          const x = d / g;
          return `rotateX(${-f.y * x}deg) rotateY(${f.x * x}deg)`;
        }
        _calculateZTransform() {
          const r = this._pos, o = this._map;
          if (!o || !r) return "";
          let u = 0;
          const d = this.getRotationAlignment();
          if (d === "map") if (o._showingGlobe()) {
            const f = o.project(new s.LngLat(this._lngLat.lng, this._lngLat.lat + 1e-3)), g = o.project(new s.LngLat(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(f);
            u = s.radToDeg(Math.atan2(g.y, g.x)) - 90;
          } else u = -o.getBearing();
          else if (d === "horizon") {
            const f = s.smoothstep(4, 6, o.getZoom()), g = s.globeCenterToScreenPoint(o.transform);
            g.y += f * o.transform.height;
            const x = r.sub(g), b = s.radToDeg(Math.atan2(x.y, x.x));
            u = (b > 90 ? b - 270 : b + 90) * (1 - f);
          }
          return u += this._rotation, u ? `rotateZ(${u}deg)` : "";
        }
        _update(r) {
          s.window.cancelAnimationFrame(this._updateFrameId);
          const o = this._map;
          o && (o.transform.renderWorldCopies && (this._lngLat = da(this._lngLat, this._pos, o.transform)), this._pos = o.project(this._lngLat), r === !0 ? this._updateFrameId = s.window.requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), o._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (o._showingGlobe() || o.getTerrain() || o.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(r) {
          return this._offset = s.Point.convert(r), this._update(), this;
        }
        _onMove(r) {
          const o = this._map;
          if (!o) return;
          const u = this._pointerdownPos, d = this._positionDelta;
          if (u && d) {
            if (!this._isDragging) {
              const f = this._clickTolerance || o._clickTolerance;
              if (r.point.dist(u) < f) return;
              this._isDragging = !0;
            }
            this._pos = r.point.sub(d), this._lngLat = o.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.Event("dragstart"))), this.fire(new s.Event("drag"));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
          const r = this._map;
          r && (r.off("mousemove", this._onMove), r.off("touchmove", this._onMove)), this._state === "active" && this.fire(new s.Event("dragend")), this._state = "inactive";
        }
        _addDragHandler(r) {
          const o = this._map, u = this._pos;
          o && u && this._element.contains(r.originalEvent.target) && (r.preventDefault(), this._positionDelta = r.point.sub(u), this._pointerdownPos = r.point, this._state = "pending", o.on("mousemove", this._onMove), o.on("touchmove", this._onMove), o.once("mouseup", this._onUp), o.once("touchend", this._onUp));
        }
        setDraggable(r) {
          this._draggable = !!r;
          const o = this._map;
          return o && (r ? (o.on("mousedown", this._addDragHandler), o.on("touchstart", this._addDragHandler)) : (o.off("mousedown", this._addDragHandler), o.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(r) {
          return this._rotation = r || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(r) {
          return this._rotationAlignment = r || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(r) {
          return this._pitchAlignment = r || "auto", this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(r) {
          return this._occludedOpacity = r || 0.2, this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const Sc = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, Dh = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function Au(l = new s.Point(0, 0), r = "bottom") {
        if (typeof l == "number") {
          const o = Math.round(Math.sqrt(0.5 * Math.pow(l, 2)));
          switch (r) {
            case "top":
              return new s.Point(0, l);
            case "top-left":
              return new s.Point(o, o);
            case "top-right":
              return new s.Point(-o, o);
            case "bottom":
              return new s.Point(0, -l);
            case "bottom-left":
              return new s.Point(o, -o);
            case "bottom-right":
              return new s.Point(-o, -o);
            case "left":
              return new s.Point(l, 0);
            case "right":
              return new s.Point(-l, 0);
          }
          return new s.Point(0, 0);
        }
        return l instanceof s.Point || Array.isArray(l) ? s.Point.convert(l) : s.Point.convert(l[r] || [0, 0]);
      }
      class Mc {
        constructor(r) {
          this.jumpTo(r);
        }
        getValue(r) {
          if (r <= this._startTime) return this._start;
          if (r >= this._endTime) return this._end;
          const o = s.easeCubicInOut((r - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - o) + this._end * o;
        }
        isEasing(r) {
          return r >= this._startTime && r <= this._endTime;
        }
        jumpTo(r) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = r, this._end = r;
        }
        easeTo(r, o, u) {
          this._start = this.getValue(o), this._end = r, this._startTime = o, this._endTime = o + u;
        }
      }
      const Iu = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, Pu = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, performanceMetricsCollection: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, optimizeForTerrain: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: !0, crossSourceCollisions: !0 }, Rh = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class Oh {
        constructor(r, o, u = !1) {
          this._clickTolerance = 10, this.element = o, this.mouseRotate = new yc({ clickTolerance: r.dragRotate._mouseRotate._clickTolerance }), this.map = r, u && (this.mousePitch = new xc({ clickTolerance: r.dragRotate._mousePitch._clickTolerance })), s.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), o.addEventListener("mousedown", this.mousedown), o.addEventListener("touchstart", this.touchstart, { passive: !1 }), o.addEventListener("touchmove", this.touchmove), o.addEventListener("touchend", this.touchend), o.addEventListener("touchcancel", this.reset);
        }
        down(r, o) {
          this.mouseRotate.mousedown(r, o), this.mousePitch && this.mousePitch.mousedown(r, o), kt();
        }
        move(r, o) {
          const u = this.map, d = this.mouseRotate.mousemoveWindow(r, o), f = d && d.bearingDelta;
          if (f && u.setBearing(u.getBearing() + f), this.mousePitch) {
            const g = this.mousePitch.mousemoveWindow(r, o), x = g && g.pitchDelta;
            x && u.setPitch(u.getPitch() + x);
          }
        }
        off() {
          const r = this.element;
          r.removeEventListener("mousedown", this.mousedown), r.removeEventListener("touchstart", this.touchstart, { passive: !1 }), r.removeEventListener("touchmove", this.touchmove), r.removeEventListener("touchend", this.touchend), r.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          Qt(), s.window.removeEventListener("mousemove", this.mousemove), s.window.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(r) {
          this.down(s.extend({}, r, { ctrlKey: !0, preventDefault: () => r.preventDefault() }), ni(this.element, r)), s.window.addEventListener("mousemove", this.mousemove), s.window.addEventListener("mouseup", this.mouseup);
        }
        mousemove(r) {
          this.move(r, ni(this.element, r));
        }
        mouseup(r) {
          this.mouseRotate.mouseupWindow(r), this.mousePitch && this.mousePitch.mouseupWindow(r), this.offTemp();
        }
        touchstart(r) {
          r.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = Qr(this.element, r.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => r.preventDefault() }, this._startPos));
        }
        touchmove(r) {
          r.targetTouches.length !== 1 ? this.reset() : (this._lastPos = Qr(this.element, r.targetTouches)[0], this.move({ preventDefault: () => r.preventDefault() }, this._lastPos));
        }
        touchend(r) {
          r.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      const Cc = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0, showUserHeading: !1 }, Ac = { maxWidth: 100, unit: "metric" }, Ic = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, pa = { version: s.version, supported: Be, setRTLTextPlugin: s.setRTLTextPlugin, getRTLTextPluginStatus: s.getRTLTextPluginStatus, Map: class extends Dl {
        constructor(l) {
          if (s.LivePerformanceUtils.mark(s.PerformanceMarkers.create), (l = s.extend({}, Pu, l)).minZoom != null && l.maxZoom != null && l.minZoom > l.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (l.minPitch != null && l.maxPitch != null && l.minPitch > l.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (l.minPitch != null && l.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (l.maxPitch != null && l.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (l.antialias && s.isSafariWithAntialiasingBug(s.window) && (l.antialias = !1, s.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new eo(l.minZoom, l.maxZoom, l.minPitch, l.maxPitch, l.renderWorldCopies), l), this._interactive = l.interactive, this._minTileCacheSize = l.minTileCacheSize, this._maxTileCacheSize = l.maxTileCacheSize, this._failIfMajorPerformanceCaveat = l.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = l.preserveDrawingBuffer, this._antialias = l.antialias, this._useWebGL2 = l.useWebGL2, this._trackResize = l.trackResize, this._bearingSnap = l.bearingSnap, this._refreshExpiredTiles = l.refreshExpiredTiles, this._fadeDuration = l.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = l.crossSourceCollisions, this._collectResourceTiming = l.collectResourceTiming, this._optimizeForTerrain = l.optimizeForTerrain, this._language = this._parseLanguage(l.language), this._worldview = l.worldview, this._renderTaskQueue = new Ec(), this._domRenderTaskQueue = new Ec(), this._controls = [], this._markers = [], this._popups = [], this._mapId = s.uniqueId(), this._locale = s.extend({}, Iu, l.locale), this._clickTolerance = l.clickTolerance, this._cooperativeGestures = l.cooperativeGestures, this._performanceMetricsCollection = l.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Mc(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._requestManager = new s.RequestManager(l.transformRequest, l.accessToken, l.testMode), this._silenceAuthErrors = !!l.testMode, typeof l.container == "string") {
            if (this._container = s.window.document.getElementById(l.container), !this._container) throw new Error(`Container '${l.container}' not found.`);
          } else {
            if (!(l.container instanceof s.window.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = l.container;
          }
          if (this._container.childNodes.length > 0 && s.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), l.maxBounds && this.setMaxBounds(l.maxBounds), s.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0) throw new Error("Failed to initialize WebGL.");
          this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), s.window !== void 0 && (s.window.addEventListener("online", this._onWindowOnline, !1), s.window.addEventListener("resize", this._onWindowResize, !1), s.window.addEventListener("orientationchange", this._onWindowResize, !1), s.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1), s.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)), this.handlers = new To(this, l), this._localFontFamily = l.localFontFamily, this._localIdeographFontFamily = l.localIdeographFontFamily, l.style && this.setStyle(l.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), l.projection && this.setProjection(l.projection), this._hash = l.hash && new fc(typeof l.hash == "string" && l.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: l.center, zoom: l.zoom, bearing: l.bearing, pitch: l.pitch }), l.bounds && (this.resize(), this.fitBounds(l.bounds, s.extend({}, l.fitBoundsOptions, { duration: 0 })))), this.resize(), l.attributionControl && this.addControl(new _t({ customAttribution: l.customAttribution })), this._logoControl = new Tc(), this.addControl(this._logoControl, l.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (r) => {
            this._update(r.dataType === "style"), this.fire(new s.Event(`${r.dataType}data`, r));
          }), this.on("dataloading", (r) => {
            this.fire(new s.Event(`${r.dataType}dataloading`, r));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(l, r) {
          if (r === void 0 && (r = l.getDefaultPosition ? l.getDefaultPosition() : "top-right"), !l || !l.onAdd) return this.fire(new s.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const o = l.onAdd(this);
          this._controls.push(l);
          const u = this._controlPositions[r];
          return r.indexOf("bottom") !== -1 ? u.insertBefore(o, u.firstChild) : u.appendChild(o), this;
        }
        removeControl(l) {
          if (!l || !l.onRemove) return this.fire(new s.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const r = this._controls.indexOf(l);
          return r > -1 && this._controls.splice(r, 1), l.onRemove(this), this;
        }
        hasControl(l) {
          return this._controls.indexOf(l) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(l) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const r = !this._moving;
          return r && this.fire(new s.Event("movestart", l)).fire(new s.Event("move", l)), this.fire(new s.Event("resize", l)), r && this.fire(new s.Event("moveend", l)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(l) {
          return this.transform.setMaxBounds(s.LngLatBounds.convert(l)), this._update();
        }
        setMinZoom(l) {
          if ((l = l ?? -2) >= -2 && l <= this.transform.maxZoom) return this.transform.minZoom = l, this._update(), this.getZoom() < l ? this.setZoom(l) : this.fire(new s.Event("zoomstart")).fire(new s.Event("zoom")).fire(new s.Event("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(l) {
          if ((l = l ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = l, this._update(), this.getZoom() > l ? this.setZoom(l) : this.fire(new s.Event("zoomstart")).fire(new s.Event("zoom")).fire(new s.Event("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(l) {
          if ((l = l ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (l >= 0 && l <= this.transform.maxPitch) return this.transform.minPitch = l, this._update(), this.getPitch() < l ? this.setPitch(l) : this.fire(new s.Event("pitchstart")).fire(new s.Event("pitch")).fire(new s.Event("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(l) {
          if ((l = l ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (l >= this.transform.minPitch) return this.transform.maxPitch = l, this._update(), this.getPitch() > l ? this.setPitch(l) : this.fire(new s.Event("pitchstart")).fire(new s.Event("pitch")).fire(new s.Event("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(l) {
          return this.transform.renderWorldCopies = l, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(l) {
          return l === "auto" ? s.window.navigator.language : Array.isArray(l) ? l.length === 0 ? void 0 : l.map((r) => r === "auto" ? s.window.navigator.language : r) : l;
        }
        setLanguage(l) {
          const r = this._parseLanguage(l);
          if (!this.style || r === this._language) return this;
          this._language = r, this.style._reloadSources();
          for (const o of this._controls) o._setLanguage && o._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(l) {
          return this.style && l !== this._worldview ? (this._worldview = l, this.style._reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return this.transform.projection.name === "globe";
        }
        setProjection(l) {
          return this._lazyInitEmptyStyle(), l ? typeof l == "string" && (l = { name: l }) : l = null, this._useExplicitProjection = !!l, this._prioritizeAndUpdateProjection(l, this.style.stylesheet ? this.style.stylesheet.projection : null);
        }
        _updateProjectionTransition() {
          if (this.getProjection().name !== "globe") return;
          const l = this.transform, r = l.projection.name;
          let o;
          r === "globe" && l.zoom >= s.GLOBE_ZOOM_THRESHOLD_MAX ? (l.setMercatorFromTransition(), o = !0) : r === "mercator" && l.zoom < s.GLOBE_ZOOM_THRESHOLD_MAX && (l.setProjection({ name: "globe" }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(l, r) {
          return this._updateProjection(l || r || { name: "mercator" });
        }
        _updateProjection(l) {
          let r;
          if (r = l.name === "globe" && this.transform.zoom >= s.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(l), this.style.applyProjectionUpdate(), r) {
            this.painter.clearBackgroundTiles();
            for (const o in this.style._sourceCaches) this.style._sourceCaches[o].clearTiles();
            this._update(!0), this._forceMarkerAndPopupUpdate(!0);
          }
          return this;
        }
        project(l) {
          return this.transform.locationPoint3D(s.LngLat.convert(l));
        }
        unproject(l) {
          return this.transform.pointLocation3D(s.Point.convert(l));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || !1;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || !1;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || !1;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || !1;
        }
        _createDelegatedListener(l, r, o) {
          if (l === "mouseenter" || l === "mouseover") {
            let u = !1;
            const d = (g) => {
              const x = r.filter((M) => this.getLayer(M)), b = x.length ? this.queryRenderedFeatures(g.point, { layers: x }) : [];
              b.length ? u || (u = !0, o.call(this, new Tr(l, this, g.originalEvent, { features: b }))) : u = !1;
            }, f = () => {
              u = !1;
            };
            return { layers: new Set(r), listener: o, delegates: { mousemove: d, mouseout: f } };
          }
          if (l === "mouseleave" || l === "mouseout") {
            let u = !1;
            const d = (g) => {
              const x = r.filter((b) => this.getLayer(b));
              (x.length ? this.queryRenderedFeatures(g.point, { layers: x }) : []).length ? u = !0 : u && (u = !1, o.call(this, new Tr(l, this, g.originalEvent)));
            }, f = (g) => {
              u && (u = !1, o.call(this, new Tr(l, this, g.originalEvent)));
            };
            return { layers: new Set(r), listener: o, delegates: { mousemove: d, mouseout: f } };
          }
          {
            const u = (d) => {
              const f = r.filter((x) => this.getLayer(x)), g = f.length ? this.queryRenderedFeatures(d.point, { layers: f }) : [];
              g.length && (d.features = g, o.call(this, d), delete d.features);
            };
            return { layers: new Set(r), listener: o, delegates: { [l]: u } };
          }
        }
        on(l, r, o) {
          if (o === void 0) return super.on(l, r);
          Array.isArray(r) || (r = [r]);
          const u = this._createDelegatedListener(l, r, o);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[l] = this._delegatedListeners[l] || [], this._delegatedListeners[l].push(u);
          for (const d in u.delegates) this.on(d, u.delegates[d]);
          return this;
        }
        once(l, r, o) {
          if (o === void 0) return super.once(l, r);
          Array.isArray(r) || (r = [r]);
          const u = this._createDelegatedListener(l, r, o);
          for (const d in u.delegates) this.once(d, u.delegates[d]);
          return this;
        }
        off(l, r, o) {
          if (o === void 0) return super.off(l, r);
          r = new Set(Array.isArray(r) ? r : [r]);
          const u = (f, g) => {
            if (f.size !== g.size) return !1;
            for (const x of f) if (!g.has(x)) return !1;
            return !0;
          }, d = this._delegatedListeners ? this._delegatedListeners[l] : void 0;
          return d && ((f) => {
            for (let g = 0; g < f.length; g++) {
              const x = f[g];
              if (x.listener === o && u(x.layers, r)) {
                for (const b in x.delegates) this.off(b, x.delegates[b]);
                return f.splice(g, 1), this;
              }
            }
          })(d), this;
        }
        queryRenderedFeatures(l, r) {
          return this.style ? (r !== void 0 || l === void 0 || l instanceof s.Point || Array.isArray(l) || (r = l, l = void 0), this.style.queryRenderedFeatures(l = l || [[0, 0], [this.transform.width, this.transform.height]], r = r || {}, this.transform)) : [];
        }
        querySourceFeatures(l, r) {
          return this.style.querySourceFeatures(l, r);
        }
        isPointOnSurface(l) {
          const { name: r } = this.transform.projection;
          return r !== "globe" && r !== "mercator" && s.warnOnce(`${r} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(s.Point.convert(l));
        }
        setStyle(l, r) {
          return (r = s.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, r)).diff !== !1 && r.localIdeographFontFamily === this._localIdeographFontFamily && r.localFontFamily === this._localFontFamily && this.style && l ? (this._diffStyle(l, r), this) : (this._localIdeographFontFamily = r.localIdeographFontFamily, this._localFontFamily = r.localFontFamily, this._updateStyle(l, r));
        }
        _getUIString(l) {
          const r = this._locale[l];
          if (r == null) throw new Error(`Missing UI string '${l}'`);
          return r;
        }
        _updateStyle(l, r) {
          return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), l && (this.style = new vn(this, r || {}), this.style.setEventedParent(this, { style: this.style }), typeof l == "string" ? this.style.loadURL(l) : this.style.loadJSON(l)), this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new vn(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(l, r) {
          if (typeof l == "string") {
            const o = this._requestManager.normalizeStyleURL(l), u = this._requestManager.transformRequest(o, s.ResourceType.Style);
            s.getJSON(u, (d, f) => {
              d ? this.fire(new s.ErrorEvent(d)) : f && this._updateDiff(f, r);
            });
          } else typeof l == "object" && this._updateDiff(l, r);
        }
        _updateDiff(l, r) {
          try {
            this.style.setState(l) && this._update(!0);
          } catch (o) {
            s.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(l, r);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (s.warnOnce("There is no style added to the map."), !1);
        }
        addSource(l, r) {
          return this._lazyInitEmptyStyle(), this.style.addSource(l, r), this._update(!0);
        }
        isSourceLoaded(l) {
          return !!this.style && this.style._isSourceCacheLoaded(l);
        }
        areTilesLoaded() {
          const l = this.style && this.style._sourceCaches;
          for (const r in l) {
            const o = l[r]._tiles;
            for (const u in o) {
              const d = o[u];
              if (d.state !== "loaded" && d.state !== "errored") return !1;
            }
          }
          return !0;
        }
        addSourceType(l, r, o) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(l, r, o);
        }
        removeSource(l) {
          return this.style.removeSource(l), this._updateTerrain(), this._update(!0);
        }
        getSource(l) {
          return this.style.getSource(l);
        }
        addImage(l, r, { pixelRatio: o = 1, sdf: u = !1, stretchX: d, stretchY: f, content: g } = {}) {
          if (this._lazyInitEmptyStyle(), r instanceof s.window.HTMLImageElement || s.window.ImageBitmap && r instanceof s.window.ImageBitmap) {
            const { width: x, height: b, data: M } = s.exported.getImageData(r);
            this.style.addImage(l, { data: new s.RGBAImage({ width: x, height: b }, M), pixelRatio: o, stretchX: d, stretchY: f, content: g, sdf: u, version: 0 });
          } else if (r.width === void 0 || r.height === void 0) this.fire(new s.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: x, height: b } = r, M = r;
            this.style.addImage(l, { data: new s.RGBAImage({ width: x, height: b }, new Uint8Array(M.data)), pixelRatio: o, stretchX: d, stretchY: f, content: g, sdf: u, version: 0, userImage: M }), M.onAdd && M.onAdd(this, l);
          }
        }
        updateImage(l, r) {
          const o = this.style.getImage(l);
          if (!o) return void this.fire(new s.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const u = r instanceof s.window.HTMLImageElement || s.window.ImageBitmap && r instanceof s.window.ImageBitmap ? s.exported.getImageData(r) : r, { width: d, height: f } = u;
          d !== void 0 && f !== void 0 ? d === o.data.width && f === o.data.height ? (o.data.replace(u.data, !(r instanceof s.window.HTMLImageElement || s.window.ImageBitmap && r instanceof s.window.ImageBitmap)), this.style.updateImage(l, o)) : this.fire(new s.ErrorEvent(new Error(`The width and height of the updated image (${d}, ${f})
                must be that same as the previous version of the image
                (${o.data.width}, ${o.data.height})`))) : this.fire(new s.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
        }
        hasImage(l) {
          return l ? !!this.style.getImage(l) : (this.fire(new s.ErrorEvent(new Error("Missing required image id"))), !1);
        }
        removeImage(l) {
          this.style.removeImage(l);
        }
        loadImage(l, r) {
          s.getImage(this._requestManager.transformRequest(l, s.ResourceType.Image), (o, u) => {
            r(o, u instanceof s.window.HTMLImageElement ? s.exported.getImageData(u) : u);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(l, r) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(l, r), this._update(!0);
        }
        moveLayer(l, r) {
          return this.style.moveLayer(l, r), this._update(!0);
        }
        removeLayer(l) {
          return this.style.removeLayer(l), this._update(!0);
        }
        getLayer(l) {
          return this.style.getLayer(l);
        }
        setLayerZoomRange(l, r, o) {
          return this.style.setLayerZoomRange(l, r, o), this._update(!0);
        }
        setFilter(l, r, o = {}) {
          return this.style.setFilter(l, r, o), this._update(!0);
        }
        getFilter(l) {
          return this.style.getFilter(l);
        }
        setPaintProperty(l, r, o, u = {}) {
          return this.style.setPaintProperty(l, r, o, u), this._update(!0);
        }
        getPaintProperty(l, r) {
          return this.style.getPaintProperty(l, r);
        }
        setLayoutProperty(l, r, o, u = {}) {
          return this.style.setLayoutProperty(l, r, o, u), this._update(!0);
        }
        getLayoutProperty(l, r) {
          return this.style.getLayoutProperty(l, r);
        }
        setLight(l, r = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(l, r), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setTerrain(l) {
          return this._lazyInitEmptyStyle(), !l && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(l), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(l) {
          return this._lazyInitEmptyStyle(), this.style.setFog(l), this._update(!0);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        _queryFogOpacity(l) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(s.LngLat.convert(l), this.transform) : 0;
        }
        setFeatureState(l, r) {
          return this.style.setFeatureState(l, r), this._update();
        }
        removeFeatureState(l, r) {
          return this.style.removeFeatureState(l, r), this._update();
        }
        getFeatureState(l) {
          return this.style.getFeatureState(l);
        }
        _updateContainerDimensions() {
          if (!this._container) return;
          const l = this._container.getBoundingClientRect().width || 400, r = this._container.getBoundingClientRect().height || 300;
          let o, u, d, f = this._container;
          for (; f && (!u || !d); ) {
            const g = s.window.getComputedStyle(f).transform;
            g && g !== "none" && (o = g.match(/matrix.*\((.+)\)/)[1].split(", "), o[0] && o[0] !== "0" && o[0] !== "1" && (u = o[0]), o[3] && o[3] !== "0" && o[3] !== "1" && (d = o[3])), f = f.parentElement;
          }
          this._containerWidth = u ? Math.abs(l / u) : l, this._containerHeight = d ? Math.abs(r / d) : r;
        }
        _detectMissingCSS() {
          s.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && s.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const l = this._container;
          l.classList.add("mapboxgl-map"), (this._missingCSSCanary = rt("div", "mapboxgl-canary", l)).style.visibility = "hidden", this._detectMissingCSS();
          const r = this._canvasContainer = rt("div", "mapboxgl-canvas-container", l);
          this._interactive && r.classList.add("mapboxgl-interactive"), this._canvas = rt("canvas", "mapboxgl-canvas", r), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const o = this._controlContainer = rt("div", "mapboxgl-control-container", l), u = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((d) => {
            u[d] = rt("div", `mapboxgl-ctrl-${d}`, o);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(l, r) {
          const o = s.exported.devicePixelRatio || 1;
          this._canvas.width = o * Math.ceil(l), this._canvas.height = o * Math.ceil(r), this._canvas.style.width = `${l}px`, this._canvas.style.height = `${r}px`;
        }
        _addMarker(l) {
          this._markers.push(l);
        }
        _removeMarker(l) {
          const r = this._markers.indexOf(l);
          r !== -1 && this._markers.splice(r, 1);
        }
        _addPopup(l) {
          this._popups.push(l);
        }
        _removePopup(l) {
          const r = this._popups.indexOf(l);
          r !== -1 && this._popups.splice(r, 1);
        }
        _setupPainter() {
          const l = s.extend({}, Be.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), r = this._useWebGL2 && this._canvas.getContext("webgl2", l), o = r || this._canvas.getContext("webgl", l) || this._canvas.getContext("experimental-webgl", l);
          o ? (this._useWebGL2 && !r && s.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), s.storeAuthState(o, !0), this.painter = new Nr(o, this.transform, !!r), this.on("data", (u) => {
            u.dataType === "source" && this.painter.setTileLoadedFlag(!0);
          }), s.exported$1.testSupport(o)) : this.fire(new s.ErrorEvent(new Error("Failed to initialize WebGL")));
        }
        _contextLost(l) {
          l.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new s.Event("webglcontextlost", { originalEvent: l }));
        }
        _contextRestored(l) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new s.Event("webglcontextrestored", { originalEvent: l }));
        }
        _onMapScroll(l) {
          if (l.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(l) {
          return this.style ? (this._styleDirty = this._styleDirty || l, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(l) {
          return this._update(), this._renderTaskQueue.add(l);
        }
        _cancelRenderFrame(l) {
          this._renderTaskQueue.remove(l);
        }
        _requestDomTask(l) {
          !this.loaded() || this.loaded() && !this.isMoving() ? l() : this._domRenderTaskQueue.add(l);
        }
        _render(l) {
          let r;
          const o = this.painter.context.extTimerQuery, u = s.exported.now();
          if (this.listens("gpu-timing-frame") && (r = o.createQueryEXT(), o.beginQueryEXT(o.TIME_ELAPSED_EXT, r)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], s.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], s.window.performance.now())), this._renderTaskQueue.run(l), this._domRenderTaskQueue.run(l), this._removed) return;
          this._updateProjectionTransition();
          const d = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const x = this.transform.zoom, b = this.transform.pitch, M = s.exported.now(), S = new s.EvaluationParameters(x, { now: M, fadeDuration: d, pitch: b, transition: this.style.getTransition() });
            this.style.update(S);
          }
          this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
          let f = !1;
          if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), f = this._updateAverageElevation(u), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : f = this._updateAverageElevation(u), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, d, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: d, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new s.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new s.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), r) {
            const x = s.exported.now() - u;
            o.endQueryEXT(o.TIME_ELAPSED_EXT, r), setTimeout(() => {
              const b = o.getQueryObjectEXT(r, o.QUERY_RESULT_EXT) / 1e6;
              o.deleteQueryEXT(r), this.fire(new s.Event("gpu-timing-frame", { cpuTime: x, gpuTime: b })), s.window.performance.mark("frame-gpu", { startTime: u, detail: { gpuTime: b } });
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const x = this.painter.collectGpuTimers();
            setTimeout(() => {
              const b = this.painter.queryGpuTimers(x);
              this.fire(new s.Event("gpu-timing-layer", { layerTimes: b }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const x = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const b = this.painter.queryGpuTimeDeferredRender(x);
              this.fire(new s.Event("gpu-timing-deferred-render", { gpuTime: b }));
            }, 50);
          }
          const g = this._sourcesDirty || this._styleDirty || this._placementDirty || f;
          if (g || this._repaint) this.triggerRepaint();
          else {
            const x = !this.isMoving() && this.loaded();
            if (x && (f = this._updateAverageElevation(u, !0)), f) this.triggerRepaint();
            else if (this._triggerFrame(!1), x && (this.fire(new s.Event("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
              const b = this._calculateSpeedIndex();
              this.fire(new s.Event("speedindexcompleted", { speedIndex: b })), this.speedIndexTiming = !1;
            }
          }
          !this._loaded || this._fullyLoaded || g || (this._fullyLoaded = !0, s.LivePerformanceUtils.mark(s.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && s.postPerformanceEvent(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(l) {
          for (const r of this._markers) l && !this.getRenderWorldCopies() && (r._lngLat = r._lngLat.wrap()), r._update();
          for (const r of this._popups) !l || this.getRenderWorldCopies() || r._trackPointer || (r._lngLat = r._lngLat.wrap()), r._update();
        }
        _updateAverageElevation(l, r = !1) {
          const o = (u) => (this.transform.averageElevation = u, this._update(!1), !0);
          if (!this.painter.averageElevationNeedsEasing()) return this.transform.averageElevation !== 0 && o(0);
          if ((r || l - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(l)) {
            const u = this.transform.averageElevation;
            let d = this.transform.sampleAverageElevation(), f = !1;
            this.transform.elevation && (f = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(d) ? d = 0 : this._averageElevationLastSampledAt = l;
            const g = Math.abs(u - d);
            if (g > 1) {
              if (this._isInitialLoad || f) return this._averageElevation.jumpTo(d), o(d);
              this._averageElevation.easeTo(d, l, 300);
            } else if (g > 1e-4) return this._averageElevation.jumpTo(d), o(d);
          }
          return !!this._averageElevation.isEasing(l) && o(this._averageElevation.getValue(l));
        }
        _authenticate() {
          s.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (l) => {
            if (l && (l.message === s.AUTH_ERR_MSG || l.status === 401)) {
              const r = this.painter.context.gl;
              s.storeAuthState(r, !1), this._logoControl instanceof Tc && this._logoControl._updateLogo(), r && r.clear(r.DEPTH_BUFFER_BIT | r.COLOR_BUFFER_BIT | r.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new s.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), s.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _updateTerrain() {
          const l = this._isDragging();
          this.painter.updateTerrain(this.style, l);
        }
        _calculateSpeedIndex() {
          const l = this.painter.canvasCopy(), r = this.painter.getCanvasCopiesAndTimestamps();
          r.timeStamps.push(performance.now());
          const o = this.painter.context.gl, u = o.createFramebuffer();
          function d(f) {
            o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, f, 0);
            const g = new Uint8Array(o.drawingBufferWidth * o.drawingBufferHeight * 4);
            return o.readPixels(0, 0, o.drawingBufferWidth, o.drawingBufferHeight, o.RGBA, o.UNSIGNED_BYTE, g), g;
          }
          return o.bindFramebuffer(o.FRAMEBUFFER, u), this._canvasPixelComparison(d(l), r.canvasCopies.map(d), r.timeStamps);
        }
        _canvasPixelComparison(l, r, o) {
          let u = o[1] - o[0];
          const d = l.length / 4;
          for (let f = 0; f < r.length; f++) {
            const g = r[f];
            let x = 0;
            for (let b = 0; b < g.length; b += 4) g[b] === l[b] && g[b + 1] === l[b + 1] && g[b + 2] === l[b + 2] && g[b + 3] === l[b + 3] && (x += 1);
            u += (o[f + 2] - o[f + 1]) * (1 - x / d);
          }
          return u;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const r of this._controls) r.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), s.window !== void 0 && (s.window.removeEventListener("resize", this._onWindowResize, !1), s.window.removeEventListener("orientationchange", this._onWindowResize, !1), s.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1), s.window.removeEventListener("online", this._onWindowOnline, !1), s.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));
          const l = this.painter.context.gl.getExtension("WEBGL_lose_context");
          l && l.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), s.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new s.Event("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(!0);
        }
        _triggerFrame(l) {
          this._renderNextFrame = this._renderNextFrame || l, this.style && !this._frame && (this._frame = s.exported.frame((r) => {
            const o = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, o && this._render(r);
          }));
        }
        _preloadTiles(l) {
          const r = this.style ? Object.values(this.style._sourceCaches) : [];
          return s.asyncAll(r, (o, u) => o._preloadTiles(l, u), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(l) {
          this._trackResize && this.resize({ originalEvent: l })._update();
        }
        _onVisibilityChange() {
          s.window.document.visibilityState === "hidden" && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(l) {
          this._showTileBoundaries !== l && (this._showTileBoundaries = l, this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(l) {
          this._showTerrainWireframe !== l && (this._showTerrainWireframe = l, this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(l) {
          this._speedIndexTiming !== l && (this._speedIndexTiming = l, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(l) {
          this._showPadding !== l && (this._showPadding = l, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(l) {
          this._showCollisionBoxes !== l && (this._showCollisionBoxes = l, l ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(l) {
          this._showOverdrawInspector !== l && (this._showOverdrawInspector = l, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(l) {
          this._repaint !== l && (this._repaint = l, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(l) {
          this._vertices = l, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(l) {
          this._showTileAABBs !== l && (this._showTileAABBs = l, l && this._update());
        }
        _setCacheLimits(l, r) {
          s.setCacheLimits(l, r);
        }
        get version() {
          return s.version;
        }
      }, NavigationControl: class {
        constructor(l) {
          this.options = s.extend({}, Rh, l), this._container = rt("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (r) => r.preventDefault()), this.options.showZoom && (s.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (r) => {
            this._map && this._map.zoomIn({}, { originalEvent: r });
          }), rt("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (r) => {
            this._map && this._map.zoomOut({}, { originalEvent: r });
          }), rt("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (s.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (r) => {
            const o = this._map;
            o && (this.options.visualizePitch ? o.resetNorthPitch({}, { originalEvent: r }) : o.resetNorth({}, { originalEvent: r }));
          }), this._compassIcon = rt("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const l = this._map;
          if (!l) return;
          const r = l.getZoom(), o = r === l.getMaxZoom(), u = r === l.getMinZoom();
          this._zoomInButton.disabled = o, this._zoomOutButton.disabled = u, this._zoomInButton.setAttribute("aria-disabled", o.toString()), this._zoomOutButton.setAttribute("aria-disabled", u.toString());
        }
        _rotateCompassArrow() {
          const l = this._map;
          if (!l) return;
          const r = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(l.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${l.transform.pitch}deg) rotateZ(${l.transform.angle * (180 / Math.PI)}deg)` : `rotate(${l.transform.angle * (180 / Math.PI)}deg)`;
          l._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = r);
          });
        }
        onAdd(l) {
          return this._map = l, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), l.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && l.on("pitch", this._rotateCompassArrow), l.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Oh(l, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const l = this._map;
          l && (this._container.remove(), this.options.showZoom && l.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && l.off("pitch", this._rotateCompassArrow), l.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(l, r) {
          const o = rt("button", l, this._container);
          return o.type = "button", o.addEventListener("click", r), o;
        }
        _setButtonTitle(l, r) {
          if (!this._map) return;
          const o = this._map._getUIString(`NavigationControl.${r}`);
          l.setAttribute("aria-label", o), l.firstElementChild && l.firstElementChild.setAttribute("title", o);
        }
      }, GeolocateControl: class extends s.Evented {
        constructor(l) {
          super(), this.options = s.extend({ geolocation: s.window.navigator.geolocation }, Cc, l), s.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = ca(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(l) {
          return this._map = l, this._container = rt("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
        }
        _checkGeolocationSupport(l) {
          const r = (o = !!this.options.geolocation) => {
            this._supportsGeolocation = o, l(o);
          };
          this._supportsGeolocation !== void 0 ? l(this._supportsGeolocation) : s.window.navigator.permissions !== void 0 ? s.window.navigator.permissions.query({ name: "geolocation" }).then((o) => r(o.state !== "denied")).catch(() => r()) : r();
        }
        _isOutOfMapMaxBounds(l) {
          const r = this._map.getMaxBounds(), o = l.coords;
          return !!r && (o.longitude < r.getWest() || o.longitude > r.getEast() || o.latitude < r.getSouth() || o.latitude > r.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(l) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(l)) return this._setErrorState(), this.fire(new s.Event("outofmaxbounds", l)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation) switch (this._lastKnownPosition = l, this._watchState) {
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "BACKGROUND":
              case "BACKGROUND_ERROR":
                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
            }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(l), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(l), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new s.Event("geolocate", l)), this._finish();
          }
        }
        _updateCamera(l) {
          const r = new s.LngLat(l.coords.longitude, l.coords.latitude), o = l.coords.accuracy, u = this._map.getBearing(), d = s.extend({ bearing: u }, this.options.fitBoundsOptions);
          this._map.fitBounds(r.toBounds(o), d, { geolocateSource: !0 });
        }
        _updateMarker(l) {
          if (l) {
            const r = new s.LngLat(l.coords.longitude, l.coords.latitude);
            this._accuracyCircleMarker.setLngLat(r).addTo(this._map), this._userLocationDotMarker.setLngLat(r).addTo(this._map), this._accuracy = l.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const l = this._map.transform, r = s.mercatorZfromAltitude(1, l._center.lat) * l.worldSize, o = Math.ceil(2 * this._accuracy * r);
          this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(l) {
          if (this._map) {
            if (this.options.trackUserLocation) if (l.code === 1) {
              this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
              const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.setAttribute("aria-label", r), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", r), this._geolocationWatchID !== void 0 && this._clearWatch();
            } else {
              if (l.code === 3 && this._noTimeout) return;
              this._setErrorState();
            }
            this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new s.Event("error", l)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(l) {
          if (this._map !== void 0) {
            if (this._container.addEventListener("contextmenu", (r) => r.preventDefault()), this._geolocateButton = rt("button", "mapboxgl-ctrl-geolocate", this._container), rt("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", l === !1) {
              s.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
              const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", r), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", r);
            } else {
              const r = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", r), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", r);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = rt("div", "mapboxgl-user-location"), this._dotElement.appendChild(rt("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(rt("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new ct({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = rt("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ct({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (r) => {
              r.geolocateSource || this._watchState !== "ACTIVE_LOCK" || r.originalEvent && r.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new s.Event("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(l) {
          this._userLocationDotMarker && (l.webkitCompassHeading ? this._heading = l.webkitCompassHeading : l.absolute === !0 && (this._heading = -1 * l.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup) return s.warnOnce("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new s.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new s.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let l;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (l = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = !0) : (l = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, l), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _addDeviceOrientationListener() {
          const l = () => {
            s.window.addEventListener("ondeviceorientationabsolute" in s.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
          };
          s.window.DeviceMotionEvent !== void 0 && typeof s.window.DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then((r) => {
            r === "granted" && l();
          }).catch(console.error) : l();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), s.window.removeEventListener("deviceorientation", this._onDeviceOrientation), s.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: _t, ScaleControl: class {
        constructor(l) {
          this.options = s.extend({}, Ac, l), this._isNumberFormatSupported = function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), !0;
            } catch {
              return !1;
            }
          }(), s.bindAll(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const l = this.options.maxWidth || 100, r = this._map, o = r._containerHeight / 2, u = r._containerWidth / 2 - l / 2, d = r.unproject([u, o]), f = r.unproject([u + l, o]), g = d.distanceTo(f);
          if (this.options.unit === "imperial") {
            const x = 3.2808 * g;
            x > 5280 ? this._setScale(l, x / 5280, "mile") : this._setScale(l, x, "foot");
          } else this.options.unit === "nautical" ? this._setScale(l, g / 1852, "nautical-mile") : g >= 1e3 ? this._setScale(l, g / 1e3, "kilometer") : this._setScale(l, g, "meter");
        }
        _setScale(l, r, o) {
          this._map._requestDomTask(() => {
            const u = function(f) {
              const g = Math.pow(10, `${Math.floor(f)}`.length - 1);
              let x = f / g;
              return x = x >= 10 ? 10 : x >= 5 ? 5 : x >= 3 ? 3 : x >= 2 ? 2 : x >= 1 ? 1 : function(b) {
                const M = Math.pow(10, Math.ceil(-Math.log(b) / Math.LN10));
                return Math.round(b * M) / M;
              }(x), g * x;
            }(r), d = u / r;
            this._container.innerHTML = this._isNumberFormatSupported && o !== "nautical-mile" ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: o }).format(u) : `${u}&nbsp;${Ic[o]}`, this._container.style.width = l * d + "px";
          });
        }
        onAdd(l) {
          return this._map = l, this._language = l.getLanguage(), this._container = rt("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", l.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(l) {
          this._language = l, this._update();
        }
        setUnit(l) {
          this.options.unit = l, this._update();
        }
      }, FullscreenControl: class {
        constructor(l) {
          this._fullscreen = !1, l && l.container && (l.container instanceof s.window.HTMLElement ? this._container = l.container : s.warnOnce("Full screen control 'container' must be a DOM element.")), s.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in s.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in s.window.document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(l) {
          return this._map = l, this._container || (this._container = this._map.getContainer()), this._controlContainer = rt("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", s.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, s.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!s.window.document.fullscreenEnabled && !s.window.document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const l = this._fullscreenButton = rt("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          rt("span", "mapboxgl-ctrl-icon", l).setAttribute("aria-hidden", "true"), l.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), s.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const l = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", l), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", l);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (s.window.document.fullscreenElement || s.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? s.window.document.exitFullscreen ? s.window.document.exitFullscreen() : s.window.document.webkitCancelFullScreen && s.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends s.Evented {
        constructor(l) {
          super(), this.options = s.extend(Object.create(Sc), l), s.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(l && l.className ? l.className.trim().split(/\s+/) : []);
        }
        addTo(l) {
          return this._map && this.remove(), this._map = l, this.options.closeOnClick && l.on("preclick", this._onClose), this.options.closeOnMove && l.on("move", this._onClose), l.on("remove", this.remove), this._update(), l._addPopup(this), this._focusFirstElement(), this._trackPointer ? (l.on("mousemove", this._onMouseEvent), l.on("mouseup", this._onMouseEvent), l._canvasContainer.classList.add("mapboxgl-track-pointer")) : l.on("move", this._update), this.fire(new s.Event("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const l = this._map;
          return l && (l.off("move", this._update), l.off("move", this._onClose), l.off("preclick", this._onClose), l.off("click", this._onClose), l.off("remove", this.remove), l.off("mousemove", this._onMouseEvent), l.off("mouseup", this._onMouseEvent), l.off("drag", this._onMouseEvent), l._canvasContainer && l._canvasContainer.classList.remove("mapboxgl-track-pointer"), l._removePopup(this), this._map = void 0), this.fire(new s.Event("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(l) {
          this._lngLat = s.LngLat.convert(l), this._pos = null, this._trackPointer = !1, this._update();
          const r = this._map;
          return r && (r.on("move", this._update), r.off("mousemove", this._onMouseEvent), r._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = !0, this._pos = null, this._update();
          const l = this._map;
          return l && (l.off("move", this._update), l.on("mousemove", this._onMouseEvent), l.on("drag", this._onMouseEvent), l._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(l) {
          return this.setDOMContent(s.window.document.createTextNode(l));
        }
        setHTML(l) {
          const r = s.window.document.createDocumentFragment(), o = s.window.document.createElement("body");
          let u;
          for (o.innerHTML = l; u = o.firstChild, u; ) r.appendChild(u);
          return this.setDOMContent(r);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(l) {
          return this.options.maxWidth = l, this._update(), this;
        }
        setDOMContent(l) {
          let r = this._content;
          if (r) for (; r.hasChildNodes(); ) r.firstChild && r.removeChild(r.firstChild);
          else r = this._content = rt("div", "mapboxgl-popup-content", this._container || void 0);
          if (r.appendChild(l), this.options.closeButton) {
            const o = this._closeButton = rt("button", "mapboxgl-popup-close-button", r);
            o.type = "button", o.setAttribute("aria-label", "Close popup"), o.setAttribute("aria-hidden", "true"), o.innerHTML = "&#215;", o.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(l) {
          return this._classList.add(l), this._updateClassList(), this;
        }
        removeClassName(l) {
          return this._classList.delete(l), this._updateClassList(), this;
        }
        setOffset(l) {
          return this.options.offset = l, this._update(), this;
        }
        toggleClassName(l) {
          let r;
          return this._classList.delete(l) ? r = !1 : (this._classList.add(l), r = !0), this._updateClassList(), r;
        }
        _onMouseEvent(l) {
          this._update(l.point);
        }
        _getAnchor(l) {
          if (this.options.anchor) return this.options.anchor;
          const r = this._map, o = this._container, u = this._pos;
          if (!r || !o || !u) return "bottom";
          const d = o.offsetWidth, f = o.offsetHeight, g = u.x < d / 2, x = u.x > r.transform.width - d / 2;
          if (u.y + l < f) return g ? "top-left" : x ? "top-right" : "top";
          if (u.y > r.transform.height - f) {
            if (g) return "bottom-left";
            if (x) return "bottom-right";
          }
          return g ? "left" : x ? "right" : "bottom";
        }
        _updateClassList() {
          const l = this._container;
          if (!l) return;
          const r = [...this._classList];
          r.push("mapboxgl-popup"), this._anchor && r.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && r.push("mapboxgl-popup-track-pointer"), l.className = r.join(" ");
        }
        _update(l) {
          const r = this._map, o = this._content;
          if (!r || !this._lngLat && !this._trackPointer || !o) return;
          let u = this._container;
          if (u || (u = this._container = rt("div", "mapboxgl-popup", r.getContainer()), this._tip = rt("div", "mapboxgl-popup-tip", u), u.appendChild(o)), this.options.maxWidth && u.style.maxWidth !== this.options.maxWidth && (u.style.maxWidth = this.options.maxWidth), r.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = da(this._lngLat, this._pos, r.transform)), !this._trackPointer || l) {
            const d = this._pos = this._trackPointer && l ? l : r.project(this._lngLat), f = Au(this.options.offset), g = this._anchor = this._getAnchor(f.y), x = Au(this.options.offset, g), b = d.add(x).round();
            r._requestDomTask(() => {
              this._container && g && (this._container.style.transform = `${Fs[g]} translate(${b.x}px,${b.y}px)`);
            });
          }
          if (!this._marker && r._showingGlobe()) {
            const d = s.isLngLatBehindGlobe(r.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(d);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const l = this._container.querySelector(Dh);
          l && l.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(l) {
          this._container && (this._container.style.opacity = `${l}`), this._content && (this._content.style.pointerEvents = l ? "auto" : "none");
        }
      }, Marker: ct, Style: vn, LngLat: s.LngLat, LngLatBounds: s.LngLatBounds, Point: s.Point, MercatorCoordinate: s.MercatorCoordinate, FreeCameraOptions: wo, Evented: s.Evented, config: s.config, prewarm: function() {
        is().acquire(In);
      }, clearPrewarmedResources: function() {
        const l = wi;
        l && (l.isPreloaded() && l.numActive() === 1 ? (l.release(In), wi = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return s.config.ACCESS_TOKEN;
      }, set accessToken(l) {
        s.config.ACCESS_TOKEN = l;
      }, get baseApiUrl() {
        return s.config.API_URL;
      }, set baseApiUrl(l) {
        s.config.API_URL = l;
      }, get workerCount() {
        return gr.workerCount;
      }, set workerCount(l) {
        gr.workerCount = l;
      }, get maxParallelImageRequests() {
        return s.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(l) {
        s.config.MAX_PARALLEL_IMAGE_REQUESTS = l;
      }, clearStorage(l) {
        s.clearTileCache(l);
      }, workerUrl: "", workerClass: null, setNow: s.exported.setNow, restoreNow: s.exported.restoreNow };
      return pa;
    });
    var he = J;
    return he;
  });
})(D_);
var up = D_.exports;
const O_ = /* @__PURE__ */ b_(up), Hv = /* @__PURE__ */ ev({
  __proto__: null,
  default: O_
}, [up]), Kv = Sa.createContext(null);
function Jv(I, k) {
  const B = Array.isArray(I) ? I[0] : I ? I.x : 0, V = Array.isArray(I) ? I[1] : I ? I.y : 0, J = Array.isArray(k) ? k[0] : k ? k.x : 0, ee = Array.isArray(k) ? k[1] : k ? k.y : 0;
  return B === J && V === ee;
}
function so(I, k) {
  if (I === k)
    return !0;
  if (!I || !k)
    return !1;
  if (Array.isArray(I)) {
    if (!Array.isArray(k) || I.length !== k.length)
      return !1;
    for (let B = 0; B < I.length; B++)
      if (!so(I[B], k[B]))
        return !1;
    return !0;
  } else if (Array.isArray(k))
    return !1;
  if (typeof I == "object" && typeof k == "object") {
    const B = Object.keys(I), V = Object.keys(k);
    if (B.length !== V.length)
      return !1;
    for (const J of B)
      if (!k.hasOwnProperty(J) || !so(I[J], k[J]))
        return !1;
    return !0;
  }
  return !1;
}
function Yv(I) {
  const k = I.clone();
  return k.pixelsToGLUnits = I.pixelsToGLUnits, k;
}
function Jm(I, k) {
  if (!I.getProjection)
    return;
  const B = I.getProjection(), V = k.getProjection();
  so(B, V) || k.setProjection(B);
}
function Ym(I) {
  return {
    longitude: I.center.lng,
    latitude: I.center.lat,
    zoom: I.zoom,
    pitch: I.pitch,
    bearing: I.bearing,
    padding: I.padding
  };
}
function Qm(I, k) {
  const B = k.viewState || k;
  let V = !1;
  if ("longitude" in B && "latitude" in B) {
    const J = I.center;
    I.center = new J.constructor(B.longitude, B.latitude), V = V || J !== I.center;
  }
  if ("zoom" in B) {
    const J = I.zoom;
    I.zoom = B.zoom, V = V || J !== I.zoom;
  }
  if ("bearing" in B) {
    const J = I.bearing;
    I.bearing = B.bearing, V = V || J !== I.bearing;
  }
  if ("pitch" in B) {
    const J = I.pitch;
    I.pitch = B.pitch, V = V || J !== I.pitch;
  }
  return B.padding && !I.isPaddingEqual(B.padding) && (V = !0, I.padding = B.padding), V;
}
const Qv = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function e_(I) {
  if (!I)
    return null;
  if (typeof I == "string" || ("toJS" in I && (I = I.toJS()), !I.layers))
    return I;
  const k = {};
  for (const V of I.layers)
    k[V.id] = V;
  const B = I.layers.map((V) => {
    let J = null;
    "interactive" in V && (J = Object.assign({}, V), delete J.interactive);
    const ee = k[V.ref];
    if (ee) {
      J = J || Object.assign({}, V), delete J.ref;
      for (const he of Qv)
        he in ee && (J[he] = ee[he]);
    }
    return J || V;
  });
  return { ...I, layers: B };
}
const t_ = { version: 8, sources: {}, layers: [] }, i_ = {
  mousedown: "onMouseDown",
  mouseup: "onMouseUp",
  mouseover: "onMouseOver",
  mousemove: "onMouseMove",
  click: "onClick",
  dblclick: "onDblClick",
  mouseenter: "onMouseEnter",
  mouseleave: "onMouseLeave",
  mouseout: "onMouseOut",
  contextmenu: "onContextMenu",
  touchstart: "onTouchStart",
  touchend: "onTouchEnd",
  touchmove: "onTouchMove",
  touchcancel: "onTouchCancel"
}, Xd = {
  movestart: "onMoveStart",
  move: "onMove",
  moveend: "onMoveEnd",
  dragstart: "onDragStart",
  drag: "onDrag",
  dragend: "onDragEnd",
  zoomstart: "onZoomStart",
  zoom: "onZoom",
  zoomend: "onZoomEnd",
  rotatestart: "onRotateStart",
  rotate: "onRotate",
  rotateend: "onRotateEnd",
  pitchstart: "onPitchStart",
  pitch: "onPitch",
  pitchend: "onPitchEnd"
}, r_ = {
  wheel: "onWheel",
  boxzoomstart: "onBoxZoomStart",
  boxzoomend: "onBoxZoomEnd",
  boxzoomcancel: "onBoxZoomCancel",
  resize: "onResize",
  load: "onLoad",
  render: "onRender",
  idle: "onIdle",
  remove: "onRemove",
  data: "onData",
  styledata: "onStyleData",
  sourcedata: "onSourceData",
  error: "onError"
}, e0 = [
  "minZoom",
  "maxZoom",
  "minPitch",
  "maxPitch",
  "maxBounds",
  "projection",
  "renderWorldCopies"
], t0 = [
  "scrollZoom",
  "boxZoom",
  "dragRotate",
  "dragPan",
  "keyboard",
  "doubleClickZoom",
  "touchZoomRotate",
  "touchPitch"
];
class ac {
  constructor(k, B, V) {
    this._map = null, this._internalUpdate = !1, this._inRender = !1, this._hoveredFeatures = null, this._deferredEvents = {
      move: !1,
      zoom: !1,
      pitch: !1,
      rotate: !1
    }, this._onEvent = (J) => {
      const ee = this.props[r_[J.type]];
      ee ? ee(J) : J.type === "error" && console.error(J.error);
    }, this._onPointerEvent = (J) => {
      (J.type === "mousemove" || J.type === "mouseout") && this._updateHover(J);
      const ee = this.props[i_[J.type]];
      ee && (this.props.interactiveLayerIds && J.type !== "mouseover" && J.type !== "mouseout" && (J.features = this._hoveredFeatures || this._queryRenderedFeatures(J.point)), ee(J), delete J.features);
    }, this._onCameraEvent = (J) => {
      if (!this._internalUpdate) {
        const ee = this.props[Xd[J.type]];
        ee && ee(J);
      }
      J.type in this._deferredEvents && (this._deferredEvents[J.type] = !1);
    }, this._MapClass = k, this.props = B, this._initialize(V);
  }
  get map() {
    return this._map;
  }
  get transform() {
    return this._renderTransform;
  }
  setProps(k) {
    const B = this.props;
    this.props = k;
    const V = this._updateSettings(k, B);
    V && this._createShadowTransform(this._map);
    const J = this._updateSize(k), ee = this._updateViewState(k, !0);
    this._updateStyle(k, B), this._updateStyleComponents(k, B), this._updateHandlers(k, B), (V || J || ee && !this._map.isMoving()) && this.redraw();
  }
  static reuse(k, B) {
    const V = ac.savedMaps.pop();
    if (!V)
      return null;
    const J = V.map, ee = J.getContainer();
    for (B.className = ee.className; ee.childNodes.length > 0; )
      B.appendChild(ee.childNodes[0]);
    J._container = B;
    const he = J._resizeObserver;
    he && (he.disconnect(), he.observe(B)), V.setProps({ ...k, styleDiffing: !1 }), J.resize();
    const { initialViewState: s } = k;
    return s && (s.bounds ? J.fitBounds(s.bounds, { ...s.fitBoundsOptions, duration: 0 }) : V._updateViewState(s, !1)), J.isStyleLoaded() ? J.fire("load") : J.once("styledata", () => J.fire("load")), J._update(), V;
  }
  /* eslint-disable complexity,max-statements */
  _initialize(k) {
    const { props: B } = this, { mapStyle: V = t_ } = B, J = {
      ...B,
      ...B.initialViewState,
      accessToken: B.mapboxAccessToken || i0() || null,
      container: k,
      style: e_(V)
    }, ee = J.initialViewState || J.viewState || J;
    if (Object.assign(J, {
      center: [ee.longitude || 0, ee.latitude || 0],
      zoom: ee.zoom || 0,
      pitch: ee.pitch || 0,
      bearing: ee.bearing || 0
    }), B.gl) {
      const Qe = HTMLCanvasElement.prototype.getContext;
      HTMLCanvasElement.prototype.getContext = () => (HTMLCanvasElement.prototype.getContext = Qe, B.gl);
    }
    const he = new this._MapClass(J);
    ee.padding && he.setPadding(ee.padding), B.cursor && (he.getCanvas().style.cursor = B.cursor), this._createShadowTransform(he);
    const s = he._render;
    he._render = (Qe) => {
      this._inRender = !0, s.call(he, Qe), this._inRender = !1;
    };
    const re = he._renderTaskQueue.run;
    he._renderTaskQueue.run = (Qe) => {
      re.call(he._renderTaskQueue, Qe), this._onBeforeRepaint();
    }, he.on("render", () => this._onAfterRepaint());
    const Be = he.fire;
    he.fire = this._fireEvent.bind(this, Be), he.on("resize", () => {
      this._renderTransform.resize(he.transform.width, he.transform.height);
    }), he.on("styledata", () => {
      this._updateStyleComponents(this.props, {}), Jm(he.transform, this._renderTransform);
    }), he.on("sourcedata", () => this._updateStyleComponents(this.props, {}));
    for (const Qe in i_)
      he.on(Qe, this._onPointerEvent);
    for (const Qe in Xd)
      he.on(Qe, this._onCameraEvent);
    for (const Qe in r_)
      he.on(Qe, this._onEvent);
    this._map = he;
  }
  /* eslint-enable complexity,max-statements */
  recycle() {
    const B = this.map.getContainer().querySelector("[mapboxgl-children]");
    B == null || B.remove(), ac.savedMaps.push(this);
  }
  destroy() {
    this._map.remove();
  }
  // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next
  // render cycle, which is managed by Mapbox's animation loop.
  // This removes the synchronization issue caused by requestAnimationFrame.
  redraw() {
    const k = this._map;
    !this._inRender && k.style && (k._frame && (k._frame.cancel(), k._frame = null), k._render());
  }
  _createShadowTransform(k) {
    const B = Yv(k.transform);
    k.painter.transform = B, this._renderTransform = B;
  }
  /* Trigger map resize if size is controlled
     @param {object} nextProps
     @returns {bool} true if size has changed
   */
  _updateSize(k) {
    const { viewState: B } = k;
    if (B) {
      const V = this._map;
      if (B.width !== V.transform.width || B.height !== V.transform.height)
        return V.resize(), !0;
    }
    return !1;
  }
  // Adapted from map.jumpTo
  /* Update camera to match props
     @param {object} nextProps
     @param {bool} triggerEvents - should fire camera events
     @returns {bool} true if anything is changed
   */
  _updateViewState(k, B) {
    if (this._internalUpdate)
      return !1;
    const V = this._map, J = this._renderTransform, { zoom: ee, pitch: he, bearing: s } = J, re = V.isMoving();
    re && (J.cameraElevationReference = "sea");
    const Be = Qm(J, {
      ...Ym(V.transform),
      ...k
    });
    if (re && (J.cameraElevationReference = "ground"), Be && B) {
      const Qe = this._deferredEvents;
      Qe.move = !0, Qe.zoom || (Qe.zoom = ee !== J.zoom), Qe.rotate || (Qe.rotate = s !== J.bearing), Qe.pitch || (Qe.pitch = he !== J.pitch);
    }
    return re || Qm(V.transform, k), Be;
  }
  /* Update camera constraints and projection settings to match props
     @param {object} nextProps
     @param {object} currProps
     @returns {bool} true if anything is changed
   */
  _updateSettings(k, B) {
    const V = this._map;
    let J = !1;
    for (const ee of e0)
      if (ee in k && !so(k[ee], B[ee])) {
        J = !0;
        const he = V[`set${ee[0].toUpperCase()}${ee.slice(1)}`];
        he == null || he.call(V, k[ee]);
      }
    return J;
  }
  /* Update map style to match props
     @param {object} nextProps
     @param {object} currProps
     @returns {bool} true if style is changed
   */
  _updateStyle(k, B) {
    if (k.cursor !== B.cursor && (this._map.getCanvas().style.cursor = k.cursor || ""), k.mapStyle !== B.mapStyle) {
      const { mapStyle: V = t_, styleDiffing: J = !0 } = k, ee = {
        diff: J
      };
      return "localIdeographFontFamily" in k && (ee.localIdeographFontFamily = k.localIdeographFontFamily), this._map.setStyle(e_(V), ee), !0;
    }
    return !1;
  }
  /* Update fog, light and terrain to match props
     @param {object} nextProps
     @param {object} currProps
     @returns {bool} true if anything is changed
   */
  _updateStyleComponents(k, B) {
    const V = this._map;
    let J = !1;
    return V.isStyleLoaded() && ("light" in k && V.setLight && !so(k.light, B.light) && (J = !0, V.setLight(k.light)), "fog" in k && V.setFog && !so(k.fog, B.fog) && (J = !0, V.setFog(k.fog)), "terrain" in k && V.setTerrain && !so(k.terrain, B.terrain) && (!k.terrain || V.getSource(k.terrain.source)) && (J = !0, V.setTerrain(k.terrain))), J;
  }
  /* Update interaction handlers to match props
     @param {object} nextProps
     @param {object} currProps
     @returns {bool} true if anything is changed
   */
  _updateHandlers(k, B) {
    var V, J;
    const ee = this._map;
    let he = !1;
    for (const s of t0) {
      const re = (V = k[s]) !== null && V !== void 0 ? V : !0, Be = (J = B[s]) !== null && J !== void 0 ? J : !0;
      so(re, Be) || (he = !0, re ? ee[s].enable(re) : ee[s].disable());
    }
    return he;
  }
  _queryRenderedFeatures(k) {
    const B = this._map, V = B.transform, { interactiveLayerIds: J = [] } = this.props;
    try {
      return B.transform = this._renderTransform, B.queryRenderedFeatures(k, {
        layers: J.filter(B.getLayer.bind(B))
      });
    } catch {
      return [];
    } finally {
      B.transform = V;
    }
  }
  _updateHover(k) {
    var B;
    const { props: V } = this;
    if (V.interactiveLayerIds && (V.onMouseMove || V.onMouseEnter || V.onMouseLeave)) {
      const ee = k.type, he = ((B = this._hoveredFeatures) === null || B === void 0 ? void 0 : B.length) > 0, s = this._queryRenderedFeatures(k.point), re = s.length > 0;
      !re && he && (k.type = "mouseleave", this._onPointerEvent(k)), this._hoveredFeatures = s, re && !he && (k.type = "mouseenter", this._onPointerEvent(k)), k.type = ee;
    } else
      this._hoveredFeatures = null;
  }
  _fireEvent(k, B, V) {
    const J = this._map, ee = J.transform, he = typeof B == "string" ? B : B.type;
    return he === "move" && this._updateViewState(this.props, !1), he in Xd && (typeof B == "object" && (B.viewState = Ym(ee)), this._map.isMoving()) ? (J.transform = this._renderTransform, k.call(J, B, V), J.transform = ee, J) : (k.call(J, B, V), J);
  }
  // All camera manipulations are complete, ready to repaint
  _onBeforeRepaint() {
    const k = this._map;
    this._internalUpdate = !0;
    for (const V in this._deferredEvents)
      this._deferredEvents[V] && k.fire(V);
    this._internalUpdate = !1;
    const B = this._map.transform;
    k.transform = this._renderTransform, this._onAfterRepaint = () => {
      Jm(this._renderTransform, B), k.transform = B;
    };
  }
}
ac.savedMaps = [];
function i0() {
  let I = null;
  if (typeof location < "u") {
    const k = /access_token=([^&\/]*)/.exec(location.search);
    I = k && k[1];
  }
  try {
    I = I || process.env.MapboxAccessToken;
  } catch {
  }
  try {
    I = I || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;
  } catch {
  }
  return I;
}
const r0 = [
  "setMaxBounds",
  "setMinZoom",
  "setMaxZoom",
  "setMinPitch",
  "setMaxPitch",
  "setRenderWorldCopies",
  "setProjection",
  "setStyle",
  "addSource",
  "removeSource",
  "addLayer",
  "removeLayer",
  "setLayerZoomRange",
  "setFilter",
  "setPaintProperty",
  "setLayoutProperty",
  "setLight",
  "setTerrain",
  "setFog",
  "remove"
];
function n0(I) {
  if (!I)
    return null;
  const k = I.map, B = {
    getMap: () => k,
    // Overwrite getters to use our shadow transform
    getCenter: () => I.transform.center,
    getZoom: () => I.transform.zoom,
    getBearing: () => I.transform.bearing,
    getPitch: () => I.transform.pitch,
    getPadding: () => I.transform.padding,
    getBounds: () => I.transform.getBounds(),
    project: (V) => {
      const J = k.transform;
      k.transform = I.transform;
      const ee = k.project(V);
      return k.transform = J, ee;
    },
    unproject: (V) => {
      const J = k.transform;
      k.transform = I.transform;
      const ee = k.unproject(V);
      return k.transform = J, ee;
    },
    // options diverge between mapbox and maplibre
    queryTerrainElevation: (V, J) => {
      const ee = k.transform;
      k.transform = I.transform;
      const he = k.queryTerrainElevation(V, J);
      return k.transform = ee, he;
    },
    queryRenderedFeatures: (V, J) => {
      const ee = k.transform;
      k.transform = I.transform;
      const he = k.queryRenderedFeatures(V, J);
      return k.transform = ee, he;
    }
  };
  for (const V of o0(k))
    !(V in B) && !r0.includes(V) && (B[V] = k[V].bind(k));
  return B;
}
function o0(I) {
  const k = /* @__PURE__ */ new Set();
  let B = I;
  for (; B; ) {
    for (const V of Object.getOwnPropertyNames(B))
      V[0] !== "_" && typeof I[V] == "function" && V !== "fire" && V !== "setEventedParent" && k.add(V);
    B = Object.getPrototypeOf(B);
  }
  return Array.from(k);
}
const s0 = typeof document < "u" ? Yx : nr, a0 = [
  "baseApiUrl",
  "maxParallelImageRequests",
  "workerClass",
  "workerCount",
  "workerUrl"
];
function l0(I, k) {
  for (const V of a0)
    V in k && (I[V] = k[V]);
  const { RTLTextPlugin: B = "https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js" } = k;
  B && I.getRTLTextPluginStatus && I.getRTLTextPluginStatus() === "unavailable" && I.setRTLTextPlugin(B, (V) => {
    V && console.error(V);
  }, !0);
}
const cc = Sa.createContext(null);
function c0(I, k, B) {
  const V = lc(Kv), [J, ee] = pl(null), he = Yr(), { current: s } = Yr({ mapLib: null, map: null });
  nr(() => {
    const Qe = I.mapLib;
    let Ie = !0, rt;
    return Promise.resolve(Qe || B).then((ut) => {
      if (!Ie)
        return;
      if (!ut)
        throw new Error("Invalid mapLib");
      const lt = "Map" in ut ? ut : ut.default;
      if (!lt.Map)
        throw new Error("Invalid mapLib");
      if (l0(lt, I), !lt.supported || lt.supported(I))
        I.reuseMaps && (rt = ac.reuse(I, he.current)), rt || (rt = new ac(lt.Map, I, he.current)), s.map = n0(rt), s.mapLib = lt, ee(rt), V == null || V.onMapMount(s.map, I.id);
      else
        throw new Error("Map is not supported by this browser");
    }).catch((ut) => {
      const { onError: lt } = I;
      lt ? lt({
        type: "error",
        target: null,
        originalEvent: null,
        error: ut
      }) : console.error(ut);
    }), () => {
      Ie = !1, rt && (V == null || V.onMapUnmount(I.id), I.reuseMaps ? rt.recycle() : rt.destroy());
    };
  }, []), s0(() => {
    J && J.setProps(I);
  }), Sh(k, () => s.map, [J]);
  const re = Hs(() => ({
    position: "relative",
    width: "100%",
    height: "100%",
    ...I.style
  }), [I.style]), Be = {
    height: "100%"
  };
  return Sa.createElement("div", { id: I.id, ref: he, style: re }, J && Sa.createElement(
    cc.Provider,
    { value: s },
    Sa.createElement("div", { "mapboxgl-children": "", style: Be }, I.children)
  ));
}
const u0 = /box|flex|grid|column|lineHeight|fontWeight|opacity|order|tabSize|zIndex/;
function gl(I, k) {
  if (!I || !k)
    return;
  const B = I.style;
  for (const V in k) {
    const J = k[V];
    Number.isFinite(J) && !u0.test(V) ? B[V] = `${J}px` : B[V] = J;
  }
}
function h0(I, k) {
  const { map: B, mapLib: V } = lc(cc), J = Yr({ props: I });
  J.current.props = I;
  const ee = Hs(() => {
    let Ke = !1;
    Sa.Children.forEach(I.children, (Qt) => {
      Qt && (Ke = !0);
    });
    const mt = {
      ...I,
      element: Ke ? document.createElement("div") : null
    }, kt = new V.Marker(mt);
    return kt.setLngLat([I.longitude, I.latitude]), kt.getElement().addEventListener("click", (Qt) => {
      var St, It;
      (It = (St = J.current.props).onClick) === null || It === void 0 || It.call(St, {
        type: "click",
        target: kt,
        originalEvent: Qt
      });
    }), kt.on("dragstart", (Qt) => {
      var St, It;
      const ni = Qt;
      ni.lngLat = ee.getLngLat(), (It = (St = J.current.props).onDragStart) === null || It === void 0 || It.call(St, ni);
    }), kt.on("drag", (Qt) => {
      var St, It;
      const ni = Qt;
      ni.lngLat = ee.getLngLat(), (It = (St = J.current.props).onDrag) === null || It === void 0 || It.call(St, ni);
    }), kt.on("dragend", (Qt) => {
      var St, It;
      const ni = Qt;
      ni.lngLat = ee.getLngLat(), (It = (St = J.current.props).onDragEnd) === null || It === void 0 || It.call(St, ni);
    }), kt;
  }, []);
  nr(() => (ee.addTo(B.getMap()), () => {
    ee.remove();
  }), []);
  const { longitude: he, latitude: s, offset: re, style: Be, draggable: Qe = !1, popup: Ie = null, rotation: rt = 0, rotationAlignment: ut = "auto", pitchAlignment: lt = "auto" } = I;
  return nr(() => {
    gl(ee.getElement(), Be);
  }, [Be]), Sh(k, () => ee, []), (ee.getLngLat().lng !== he || ee.getLngLat().lat !== s) && ee.setLngLat([he, s]), re && !Jv(ee.getOffset(), re) && ee.setOffset(re), ee.isDraggable() !== Qe && ee.setDraggable(Qe), ee.getRotation() !== rt && ee.setRotation(rt), ee.getRotationAlignment() !== ut && ee.setRotationAlignment(ut), ee.getPitchAlignment() !== lt && ee.setPitchAlignment(lt), ee.getPopup() !== Ie && ee.setPopup(Ie), T_(I.children, ee.getElement());
}
_l(np(h0));
function n_(I) {
  return new Set(I ? I.trim().split(/\s+/) : []);
}
function d0(I, k) {
  const { map: B, mapLib: V } = lc(cc), J = Hs(() => document.createElement("div"), []), ee = Yr({ props: I });
  ee.current.props = I;
  const he = Hs(() => {
    const s = { ...I }, re = new V.Popup(s);
    return re.setLngLat([I.longitude, I.latitude]), re.once("open", (Be) => {
      var Qe, Ie;
      (Ie = (Qe = ee.current.props).onOpen) === null || Ie === void 0 || Ie.call(Qe, Be);
    }), re;
  }, []);
  if (nr(() => {
    const s = (re) => {
      var Be, Qe;
      (Qe = (Be = ee.current.props).onClose) === null || Qe === void 0 || Qe.call(Be, re);
    };
    return he.on("close", s), he.setDOMContent(J).addTo(B.getMap()), () => {
      he.off("close", s), he.isOpen() && he.remove();
    };
  }, []), nr(() => {
    gl(he.getElement(), I.style);
  }, [I.style]), Sh(k, () => he, []), he.isOpen() && ((he.getLngLat().lng !== I.longitude || he.getLngLat().lat !== I.latitude) && he.setLngLat([I.longitude, I.latitude]), I.offset && !so(he.options.offset, I.offset) && he.setOffset(I.offset), (he.options.anchor !== I.anchor || he.options.maxWidth !== I.maxWidth) && (he.options.anchor = I.anchor, he.setMaxWidth(I.maxWidth)), he.options.className !== I.className)) {
    const s = n_(he.options.className), re = n_(I.className);
    for (const Be of s)
      re.has(Be) || he.removeClassName(Be);
    for (const Be of re)
      s.has(Be) || he.addClassName(Be);
    he.options.className = I.className;
  }
  return T_(I.children, J);
}
_l(np(d0));
function uc(I, k, B, V) {
  const J = lc(cc), ee = Hs(() => I(J), []);
  return nr(() => {
    const he = k, s = typeof k == "function" && typeof B == "function" ? k : null, re = typeof k == "function" ? k : null, { map: Be } = J;
    return Be.hasControl(ee) || (Be.addControl(ee, he == null ? void 0 : he.position), s && s(J)), () => {
      re && re(J), Be.hasControl(ee) && Be.removeControl(ee);
    };
  }, []), ee;
}
function p0(I) {
  const k = uc(({ mapLib: B }) => new B.AttributionControl(I), {
    position: I.position
  });
  return nr(() => {
    gl(k._container, I.style);
  }, [I.style]), null;
}
_l(p0);
function f0(I) {
  const k = uc(({ mapLib: B }) => new B.FullscreenControl({
    container: I.containerId && document.getElementById(I.containerId)
  }), { position: I.position });
  return nr(() => {
    gl(k._controlContainer, I.style);
  }, [I.style]), null;
}
_l(f0);
function m0(I, k) {
  const B = Yr({ props: I }), V = uc(({ mapLib: J }) => {
    const ee = new J.GeolocateControl(I), he = ee._setupUI;
    return ee._setupUI = (s) => {
      ee._container.hasChildNodes() || he(s);
    }, ee.on("geolocate", (s) => {
      var re, Be;
      (Be = (re = B.current.props).onGeolocate) === null || Be === void 0 || Be.call(re, s);
    }), ee.on("error", (s) => {
      var re, Be;
      (Be = (re = B.current.props).onError) === null || Be === void 0 || Be.call(re, s);
    }), ee.on("outofmaxbounds", (s) => {
      var re, Be;
      (Be = (re = B.current.props).onOutOfMaxBounds) === null || Be === void 0 || Be.call(re, s);
    }), ee.on("trackuserlocationstart", (s) => {
      var re, Be;
      (Be = (re = B.current.props).onTrackUserLocationStart) === null || Be === void 0 || Be.call(re, s);
    }), ee.on("trackuserlocationend", (s) => {
      var re, Be;
      (Be = (re = B.current.props).onTrackUserLocationEnd) === null || Be === void 0 || Be.call(re, s);
    }), ee;
  }, { position: I.position });
  return B.current.props = I, Sh(k, () => V, []), nr(() => {
    gl(V._container, I.style);
  }, [I.style]), null;
}
_l(np(m0));
function _0(I) {
  const k = uc(({ mapLib: B }) => new B.NavigationControl(I), {
    position: I.position
  });
  return nr(() => {
    gl(k._container, I.style);
  }, [I.style]), null;
}
_l(_0);
function g0(I) {
  const k = uc(({ mapLib: ee }) => new ee.ScaleControl(I), {
    position: I.position
  }), B = Yr(I), V = B.current;
  B.current = I;
  const { style: J } = I;
  return I.maxWidth !== void 0 && I.maxWidth !== V.maxWidth && (k.options.maxWidth = I.maxWidth), I.unit !== void 0 && I.unit !== V.unit && k.setUnit(I.unit), nr(() => {
    gl(k._container, J);
  }, [J]), null;
}
_l(g0);
function xh(I, k) {
  if (!I)
    throw new Error(k);
}
function y0(I, k, B, V) {
  if (xh(B.id === V.id, "layer id changed"), xh(B.type === V.type, "layer type changed"), B.type === "custom" || V.type === "custom")
    return;
  const { layout: J = {}, paint: ee = {}, filter: he, minzoom: s, maxzoom: re, beforeId: Be } = B;
  if (Be !== V.beforeId && I.moveLayer(k, Be), J !== V.layout) {
    const Qe = V.layout || {};
    for (const Ie in J)
      so(J[Ie], Qe[Ie]) || I.setLayoutProperty(k, Ie, J[Ie]);
    for (const Ie in Qe)
      J.hasOwnProperty(Ie) || I.setLayoutProperty(k, Ie, void 0);
  }
  if (ee !== V.paint) {
    const Qe = V.paint || {};
    for (const Ie in ee)
      so(ee[Ie], Qe[Ie]) || I.setPaintProperty(k, Ie, ee[Ie]);
    for (const Ie in Qe)
      ee.hasOwnProperty(Ie) || I.setPaintProperty(k, Ie, void 0);
  }
  so(he, V.filter) || I.setFilter(k, he), (s !== V.minzoom || re !== V.maxzoom) && I.setLayerZoomRange(k, s, re);
}
function x0(I, k, B) {
  if (I.style && I.style._loaded && (!("source" in B) || I.getSource(B.source))) {
    const V = { ...B, id: k };
    delete V.beforeId, I.addLayer(V, B.beforeId);
  }
}
let v0 = 0;
function b0(I) {
  const k = lc(cc).map.getMap(), B = Yr(I), [, V] = pl(0), J = Hs(() => I.id || `jsx-layer-${v0++}`, []);
  if (nr(() => {
    if (k) {
      const he = () => V((s) => s + 1);
      return k.on("styledata", he), he(), () => {
        k.off("styledata", he), k.style && k.style._loaded && k.getLayer(J) && k.removeLayer(J);
      };
    }
  }, [k]), k && k.style && k.getLayer(J))
    try {
      y0(k, J, I, B.current);
    } catch (he) {
      console.warn(he);
    }
  else
    x0(k, J, I);
  return B.current = I, null;
}
let w0 = 0;
function T0(I, k, B) {
  if (I.style && I.style._loaded) {
    const V = { ...B };
    return delete V.id, delete V.children, I.addSource(k, V), I.getSource(k);
  }
  return null;
}
function E0(I, k, B) {
  xh(k.id === B.id, "source id changed"), xh(k.type === B.type, "source type changed");
  let V = "", J = 0;
  for (const he in k)
    he !== "children" && he !== "id" && !so(B[he], k[he]) && (V = he, J++);
  if (!J)
    return;
  const ee = k.type;
  if (ee === "geojson")
    I.setData(k.data);
  else if (ee === "image")
    I.updateImage({
      url: k.url,
      coordinates: k.coordinates
    });
  else if ("setCoordinates" in I && J === 1 && V === "coordinates")
    I.setCoordinates(k.coordinates);
  else if ("setUrl" in I)
    switch (V) {
      case "url":
        I.setUrl(k.url);
        break;
      case "tiles":
        I.setTiles(k.tiles);
        break;
    }
  else
    console.warn(`Unable to update <Source> prop: ${V}`);
}
function S0(I) {
  const k = lc(cc).map.getMap(), B = Yr(I), [, V] = pl(0), J = Hs(() => I.id || `jsx-source-${w0++}`, []);
  nr(() => {
    if (k) {
      const he = () => setTimeout(() => V((s) => s + 1), 0);
      return k.on("styledata", he), he(), () => {
        var s;
        if (k.off("styledata", he), k.style && k.style._loaded && k.getSource(J)) {
          const re = (s = k.getStyle()) === null || s === void 0 ? void 0 : s.layers;
          if (re)
            for (const Be of re)
              Be.source === J && k.removeLayer(Be.id);
          k.removeSource(J);
        }
      };
    }
  }, [k]);
  let ee = k && k.style && k.getSource(J);
  return ee ? E0(ee, I, B.current) : ee = T0(k, J, I), B.current = I, ee && Sa.Children.map(I.children, (he) => he && Qx(he, {
    source: J
  })) || null;
}
const M0 = Promise.resolve().then(() => Hv), C0 = Sa.forwardRef(function(k, B) {
  return c0(k, B, M0);
}), Hd = b0, A0 = S0;
function I0(I, k) {
  var B = Yr(null), V = Yr(null);
  V.current = k;
  var J = Yr(null);
  nr(function() {
    ee();
  });
  var ee = Yd(function() {
    var he = J.current, s = V.current, re = he || (s ? s instanceof Element ? s : s.current : null);
    B.current && B.current.element === re && B.current.subscriber === I || (B.current && B.current.cleanup && B.current.cleanup(), B.current = {
      element: re,
      subscriber: I,
      // Only calling the subscriber, if there's an actual element to report.
      // Setting cleanup to undefined unless a subscriber returns one, as an existing cleanup function would've been just called.
      cleanup: re ? I(re) : void 0
    });
  }, [I]);
  return nr(function() {
    return function() {
      B.current && B.current.cleanup && (B.current.cleanup(), B.current = null);
    };
  }, []), Yd(function(he) {
    J.current = he, ee();
  }, [ee]);
}
function o_(I, k, B) {
  return I[k] ? I[k][0] ? I[k][0][B] : (
    // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current
    // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.
    // @ts-ignore
    I[k][B]
  ) : k === "contentBoxSize" ? I.contentRect[B === "inlineSize" ? "width" : "height"] : void 0;
}
function P0(I) {
  I === void 0 && (I = {});
  var k = I.onResize, B = Yr(void 0);
  B.current = k;
  var V = I.round || Math.round, J = Yr(), ee = pl({
    width: void 0,
    height: void 0
  }), he = ee[0], s = ee[1], re = Yr(!1);
  nr(function() {
    return re.current = !1, function() {
      re.current = !0;
    };
  }, []);
  var Be = Yr({
    width: void 0,
    height: void 0
  }), Qe = I0(Yd(function(Ie) {
    return (!J.current || J.current.box !== I.box || J.current.round !== V) && (J.current = {
      box: I.box,
      round: V,
      instance: new ResizeObserver(function(rt) {
        var ut = rt[0], lt = I.box === "border-box" ? "borderBoxSize" : I.box === "device-pixel-content-box" ? "devicePixelContentBoxSize" : "contentBoxSize", Ke = o_(ut, lt, "inlineSize"), mt = o_(ut, lt, "blockSize"), kt = Ke ? V(Ke) : void 0, Qt = mt ? V(mt) : void 0;
        if (Be.current.width !== kt || Be.current.height !== Qt) {
          var St = {
            width: kt,
            height: Qt
          };
          Be.current.width = kt, Be.current.height = Qt, B.current ? B.current(St) : re.current || s(St);
        }
      })
    }), J.current.instance.observe(Ie, {
      box: I.box
    }), function() {
      J.current && J.current.instance.unobserve(Ie);
    };
  }, [I.box, V]), I.ref);
  return Hs(function() {
    return {
      ref: Qe,
      width: he.width,
      height: he.height
    };
  }, [Qe, he.width, he.height]);
}
class L0 {
  constructor() {
    mh(this, "_cls");
    mh(this, "_nameMap");
    mh(this, "params");
  }
  toJSON() {
    const k = this._cls, B = [];
    if (this.params)
      for (const [V, J] of Object.entries(this.params))
        V && B.push([this._getSerializedName(V), J]);
    return { _cls: k, kwargs: B };
  }
  _getSerializedName(k) {
    return this._nameMap.has(k) ? this._nameMap.get(k) : k;
  }
}
class s_ extends L0 {
  constructor(k = null) {
    super(), this.params = k, this._cls = "fiftyone.core.aggregations.Values", this._nameMap = new Map(
      Object.entries({
        fieldOrExpr: "field_or_expr",
        expr: "expr",
        missingValue: "missing_value",
        unwind: "unwind"
      })
    );
  }
}
const z0 = "/aggregate";
function k0({
  view: I,
  filters: k,
  dataset: B,
  sample_ids: V
} = {}) {
  const [J, ee] = _r.useState(!0), [he, s] = _r.useState(null);
  return [async (Be, Qe) => {
    ee(!0);
    const Ie = Be.map((ut) => ut.toJSON()), rt = await fu()("POST", z0, {
      filters: k,
      // extended view
      view: I,
      dataset: Qe || B.name,
      sample_ids: V,
      aggregations: Ie
    });
    s(rt.aggregate), ee(!1);
  }, he, J];
}
const D0 = ({
  path: I,
  dataset: k,
  filters: B,
  view: V
}) => {
  const [J, ee, he] = k0({
    dataset: k,
    filters: B,
    view: V
  });
  return _r.useEffect(() => {
    J(
      [
        new s_({
          fieldOrExpr: "id"
        }),
        new s_({
          fieldOrExpr: `${I}.point.coordinates`
        })
      ],
      k.name
    );
  }, [k, B, V, I]), {
    loading: he,
    samples: _r.useMemo(
      () => ee ? ee[0].reduce((s, re, Be) => (ee[1][Be] && (s[re] = ee[1][Be]), s), {}) : {},
      [ee]
    )
  };
};
function R0({ draw: I, onCreate: k }) {
  const B = _r.useRef(k);
  return B.current = k, uc(
    ({ map: V }) => (V.on("draw.create", (J) => {
      B.current(J), I.delete(J.features[0].id);
    }), I),
    ({ map: V }) => {
      V.off("draw.create", B.current);
    }
  ), null;
}
const hp = "@fiftyone/map", O0 = Object.freeze({
  clustering: !0,
  // https://docs.mapbox.com/help/glossary/zoom-level/
  clusterMaxZoom: 11,
  clusters: {
    paint: {
      "circle-color": "rgb(244, 113, 6)",
      "circle-opacity": 0.7,
      // Use step expressions (https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions-step)
      "circle-radius": ["step", ["get", "point_count"], 20, 10, 30, 25, 40]
    },
    textPaint: {
      "text-color": "white"
    }
  },
  pointPaint: {
    "circle-color": "rgb(244, 113, 6)",
    "circle-opacity": 0.7,
    "circle-radius": 4
  }
}), B0 = Eh({
  key: "@fiftyone/map/state.defaultActiveField",
  get: ({ get: I }) => I(F_)[0]
}), B_ = w_({
  key: "@fiftyone/map/state.activeField",
  default: B0
}), F_ = Eh({
  key: "@fiftyone/map/state.geoFields",
  get: ({ get: I }) => I(kx).filter((k) => k.embeddedDocType === "fiftyone.core.labels.GeoLocation").map(({ name: k }) => k).sort()
}), F0 = Eh({
  key: "hasSelection",
  get: ({ get: I }) => I(ml).scope === hp
}), U_ = {
  Street: "streets-v11",
  Dark: "dark-v10",
  Light: "light-v10",
  Outdoors: "outdoors-v11",
  Satellite: "satellite-v9"
}, U0 = Object.keys(U_), N0 = Eh({
  key: "defaultMapStyle",
  get: ({ get: I }) => I(Dx) === "dark" ? "Dark" : "Light"
}), N_ = w_({
  key: "@fiftyone/map/state.mapStyle",
  default: N0,
  effects: [
    Rx("@fiftyone/map/state.style", {
      sessionStorage: !0,
      map: (I) => ["Dark", "Light"].includes(I) ? void 0 : I
    })
  ]
}), j0 = "_options_1pz6v_1", Kd = "_link_1pz6v_16", V0 = (I, k, B, V = !1) => {
  const J = Yr(B);
  J.current = B, nr(() => {
    if (!I) return;
    const ee = (he) => J.current(he);
    return I && I.addEventListener(k, ee, V), () => {
      I && I.removeEventListener(k, ee);
    };
  }, [I, k]);
}, G0 = (I) => ({ values: U0.filter((B) => B.includes(I)) }), a_ = ({ value: I }) => /* @__PURE__ */ xt.jsx(xt.Fragment, { children: I }), $0 = ({ clearSelectionData: I, fitSelectionData: k, fitData: B }) => {
  const V = Th(), [J, ee] = du(N_), he = di(F_), [s, re] = du(B_), Be = di(F0), Qe = {
    background: V.neutral.softBg,
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
    padding: "0.25rem"
  }, Ie = _r.useCallback(() => {
    I(), B();
  }, [I, B]);
  return V0(window, "keydown", ({ key: rt }) => {
    switch (rt) {
      case "Escape":
        Ie();
        break;
      case "f":
        k();
        break;
    }
  }), /* @__PURE__ */ xt.jsxs("div", { className: j0, children: [
    /* @__PURE__ */ xt.jsxs("div", { children: [
      /* @__PURE__ */ xt.jsx(
        gh,
        {
          placeholder: "Map Style",
          value: J,
          onSelect: ee,
          useSearch: G0,
          component: a_,
          containerStyle: Qe,
          overflow: !0
        }
      ),
      he.length > 1 && /* @__PURE__ */ xt.jsx(
        gh,
        {
          placeholder: "Field",
          value: s,
          onSelect: re,
          useSearch: () => ({ values: he }),
          component: a_,
          containerStyle: Qe,
          overflow: !0
        }
      )
    ] }),
    /* @__PURE__ */ xt.jsxs("div", { children: [
      Be && /* @__PURE__ */ xt.jsx(_h, { to: Ie, className: Kd, title: "Reset (Esc)", children: /* @__PURE__ */ xt.jsx(ep, {}) }),
      /* @__PURE__ */ xt.jsx(_h, { to: k, className: Kd, title: "Fit data (f)", children: /* @__PURE__ */ xt.jsx(E_, {}) }),
      /* @__PURE__ */ xt.jsx(
        _h,
        {
          className: Kd,
          href: "https://docs.voxel51.com/user_guide/app.html#map-panel",
          title: "Help",
          to: m_(),
          target: "_blank",
          children: /* @__PURE__ */ xt.jsx(d_, {})
        }
      ),
      /* @__PURE__ */ xt.jsx(p_, { place: f_.MAP_ACTIONS })
    ] })
  ] });
}, j_ = { animate: !1, padding: 30 }, V_ = (I) => I.features.reduce(
  (k, { geometry: { coordinates: B } }) => k.extend(B),
  new up.LngLatBounds()
), Jd = (I, k) => {
  I.fitBounds(V_(k), j_);
}, Z0 = (I) => {
  const k = Object.entries(I);
  return k.length === 0 ? null : {
    type: "FeatureCollection",
    features: k.map(([B, V]) => ({
      type: "Feature",
      properties: { id: B },
      geometry: { type: "Point", coordinates: V }
    }))
  };
}, q0 = () => {
  const I = Th(), k = di(bh), B = di(wh), V = di(ip);
  let { loading: J, samples: ee } = D0({
    dataset: k,
    filters: V,
    view: B,
    path: di(B_)
  });
  const he = Ox(
    "map",
    O0
  ), s = di(N_), [{ selection: re }, Be] = du(
    ml
  ), Qe = rp(), Ie = _r.useRef(null), rt = _r.useMemo(
    () => Bx.debounce(
      () => {
        Ie.current && Ie.current.resize();
      },
      0,
      {
        trailing: !0
      }
    ),
    []
  ), { ref: ut } = P0({
    onResize: rt
  }), lt = _r.useMemo(() => {
    let ui = ee;
    if (re) {
      ui = {};
      for (const $i of re)
        ee[$i] && (ui[$i] = ee[$i]);
    }
    return Z0(ui);
  }, [ee, re]), Ke = _r.useMemo(() => lt && V_(lt), [ee]), [mt] = _r.useState(
    () => new Ov({
      displayControlsDefault: !1,
      defaultMode: "draw_polygon"
    })
  ), [kt, Qt] = _r.useState(!1), St = _r.useCallback(() => {
    var or;
    const ui = (or = Ie.current) == null ? void 0 : or.getMap();
    if (!ui) return;
    ui.on("click", "cluster", (Pt) => {
      var br;
      Pt.preventDefault();
      const Fi = ui.queryRenderedFeatures(Pt.point, {
        layers: ["cluster"]
      });
      mt.changeMode("simple_select");
      const Zr = (br = Fi[0].properties) == null ? void 0 : br.cluster_id;
      ui.getSource("points").getClusterExpansionZoom(Zr, (ao, Vt) => {
        var Zi;
        if (ao) return;
        const Sn = Fi[0].geometry;
        (Zi = Ie.current) == null || Zi.easeTo({
          center: Sn.coordinates,
          zoom: Vt
        });
      });
    });
    const $i = () => ui.getCanvas().style.cursor = "pointer", et = () => ui.getCanvas().style.cursor = "crosshair", Dr = () => ui.getCanvas().style.cursor = "all-scroll";
    ui.on("mouseenter", "cluster", $i), ui.on("mouseleave", "cluster", et), ui.on("mouseenter", "point", () => $i), ui.on("mouseleave", "point", () => et), ui.on("dragstart", Dr), ui.on("dragend", et);
  }, []), It = _r.useMemo(() => Object.keys(ee).length, [ee]);
  _r.useEffect(() => {
    Ie.current && lt && Jd(Ie.current, lt);
  }, [lt]), Fx(() => new Promise((ui) => {
    Ie.current.once("render", () => {
      ui(Ie.current.getCanvas());
    }), Ie.current.setBearing(Ie.current.getBearing());
  }));
  const ni = h_();
  return _r.useEffect(() => {
    ni(Qe);
  }, []), he.mapboxAccessToken ? (!Object.keys(ee).length || !lt) && !J ? /* @__PURE__ */ xt.jsx(dl, { children: "No data" }) : /* @__PURE__ */ xt.jsxs("div", { className: Dv, ref: ut, children: [
    J && !It ? /* @__PURE__ */ xt.jsx(dl, { style: { opacity: 0.5 }, children: "Pixelating..." }) : kt ? /* @__PURE__ */ xt.jsxs(dl, { children: [
      "Something went wrong... is your ",
      /* @__PURE__ */ xt.jsx(
        Zm,
        {
          style: { color: I.text.primary },
          href: "https://docs.voxel51.com/user_guide/app.html#map-panel",
          children: "Mapbox token"
        }
      ),
      " valid?"
    ] }) : /* @__PURE__ */ xt.jsxs(
      C0,
      {
        ref: Ie,
        mapLib: O_,
        mapStyle: `mapbox://styles/mapbox/${U_[s]}`,
        initialViewState: {
          bounds: Ke,
          fitBoundsOptions: j_
        },
        onStyleData: () => {
          Ie.current && (Ie.current.getCanvas().style.cursor = "crosshair");
        },
        mapboxAccessToken: he.mapboxAccessToken,
        onLoad: St,
        onRender: () => {
          mt.getMode() !== "draw_polygon" && mt.changeMode("draw_polygon");
        },
        onError: ({ error: ui }) => {
          throw Qt(!0), ui;
        },
        children: [
          /* @__PURE__ */ xt.jsxs(
            A0,
            {
              id: "points",
              type: "geojson",
              data: lt,
              cluster: he.clustering,
              clusterMaxZoom: he.clusterMaxZoom,
              children: [
                he.clustering && /* @__PURE__ */ xt.jsx(
                  Hd,
                  {
                    id: "cluster",
                    filter: ["has", "point_count"],
                    paint: {
                      "circle-color": I.primary.plainColor,
                      "circle-opacity": 0.7,
                      "circle-radius": [
                        "step",
                        ["get", "point_count"],
                        20,
                        10,
                        30,
                        25,
                        40
                      ],
                      ...he.clusters.paint
                    },
                    type: "circle"
                  }
                ),
                he.clustering && /* @__PURE__ */ xt.jsx(
                  Hd,
                  {
                    id: "cluster-count",
                    filter: ["has", "point_count"],
                    layout: {
                      "text-field": "{point_count_abbreviated}",
                      "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
                      "text-size": 12
                    },
                    paint: he.clusters.textPaint,
                    type: "symbol"
                  }
                ),
                /* @__PURE__ */ xt.jsx(
                  Hd,
                  {
                    id: "point",
                    filter: ["!", ["has", "point_count"]],
                    paint: he.pointPaint,
                    type: "circle"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ xt.jsx(
            R0,
            {
              draw: mt,
              onCreate: (ui) => {
                const {
                  features: [$i]
                } = ui, et = /* @__PURE__ */ new Set();
                for (let Dr = 0; Dr < lt.features.length; Dr++)
                  Nv(
                    $i,
                    lt.features[Dr]
                  ) && et.add(lt.features[Dr].properties.id);
                et.size && Be({
                  selection: Array.from(et),
                  scope: hp
                });
              }
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ xt.jsx(
      $0,
      {
        fitData: () => Ie.current && Jd(Ie.current, lt),
        fitSelectionData: () => Ie.current && Jd(Ie.current, lt),
        clearSelectionData: Qe
      }
    )
  ] }) : /* @__PURE__ */ xt.jsxs(dl, { children: [
    "No Mapbox token provided. ",
    /* @__PURE__ */ xt.jsx(
      Zm,
      {
        style: { color: I.text.primary },
        href: "https://docs.voxel51.com/user_guide/app.html#map-panel",
        children: "Learn more"
      }
    )
  ] });
};
var dp = {}, W0 = jx;
Object.defineProperty(dp, "__esModule", {
  value: !0
});
var G_ = dp.default = void 0, X0 = W0(Ux()), H0 = Nx();
G_ = dp.default = (0, X0.default)(/* @__PURE__ */ (0, H0.jsx)("path", {
  d: "m20.5 3-.16.03L15 5.1 9 3 3.36 4.9c-.21.07-.36.25-.36.48V20.5c0 .28.22.5.5.5l.16-.03L9 18.9l6 2.1 5.64-1.9c.21-.07.36-.25.36-.48V3.5c0-.28-.22-.5-.5-.5M15 19l-6-2.11V5l6 2.11z"
}), "Map");
function K0() {
  const { selection: I, scope: k } = di(ml), B = rp();
  return k !== hp ? null : /* @__PURE__ */ xt.jsx(
    __,
    {
      selectionCount: I == null ? void 0 : I.length.toString(),
      onClickSelection: B
    }
  );
}
g_({
  name: "Map",
  label: "Map",
  component: q0,
  type: y_.Panel,
  activator: J0,
  Icon: G_,
  panelOptions: {
    TabIndicator: K0,
    priority: x_
  }
});
function J0({ schema: I }) {
  for (const k in I)
    if (I[k].embeddedDocType === "fiftyone.core.labels.GeoLocation")
      return !0;
  return !1;
}
const Y0 = vx, ob = ({
  prepared: I
}) => {
  const k = Vx.usePreloadedQuery(Y0, I), V = di(Gx) === 0;
  return /* @__PURE__ */ _r.createElement(Xx, {
    fragment: k,
    hasDataset: !V
  }, /* @__PURE__ */ _r.createElement("div", {
    className: Hx.page,
    "data-cy": "dataset-page"
  }, V ? /* @__PURE__ */ _r.createElement(Kx, {
    mode: "ADD_SAMPLE"
  }) : /* @__PURE__ */ _r.createElement($x.Provider, {
    value: k
  }, /* @__PURE__ */ _r.createElement(Zx, null), /* @__PURE__ */ _r.createElement(qx, null))), /* @__PURE__ */ _r.createElement(Wx, null));
};
export {
  ob as default
};
